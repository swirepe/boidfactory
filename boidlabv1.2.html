<!DOCTYPE html>
<!--
  Boids Simulation – Single-file Lab (v1.2)
  
  Goals
  - Clean, readable structure with sectioned comments
  - Smartly documented example rules (cohesion/separation/alignment/novel)
  - Minimal external dependencies (CDN for editors/charts only)

  Structure
  - CSS: variables, layout, overlays, code pane, charts
  - HTML: full-screen canvas, overlays (config/stats/help), code pane tabs
  - JS: utilities → simulation core → UI → main loop → charts → helpers

  Notes
  - Example rule code is editable live; each rule must return a Vector.
  - The dynamic function scope provides: boid, gameState, neighbors, config, mouse, Vector.
  - Keep rule code side-effect free (only return a force vector) for clarity.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Boids Simulation</title>
    <style>
        :root {
            --hue: 200;
            --font-mono: 'SF Mono', 'Consolas', 'Courier New', monospace;
            --primary-color: hsl(var(--hue), 100%, 50%);
            --secondary-color: hsl(var(--hue), 50%, 70%);
            --background-color: #1a1a1a;
            --text-color: #f0f0f0;
            --overlay-bg-color: rgba(20, 20, 20, 0.9);
            --border-color: var(--primary-color);
        }
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--background-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas {
            display: block;
            cursor: none;
        }
        .overlay {
            position: fixed;
            top: 10px;
            background-color: var(--overlay-bg-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            max-height: calc(100vh - 80px);
            overflow-y: auto;
            transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.4s;
            transform: translateX(120%);
            opacity: 0;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
            z-index: 1002;
            font-family: var(--font-mono);
        }
        .overlay.visible {
            transform: translateX(0);
            opacity: 1;
        }
        .close-button {
            position: absolute;
            top: 5px;
            right: 10px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            padding: 5px;
            line-height: 1;
        }
        .close-button:hover {
            color: var(--primary-color);
        }
        .overlay-toggle-container {
            position: fixed;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1001;
        }
        /* Hide overlay buttons when code pane is maximized */
        body.code-pane-maximized .overlay-toggle-container { display: none; }
        /* Subtle enter/leave transitions for temporary Code overlay button */
        #overlay-code-button {
            opacity: 1;
            transform: translateY(0);
            transition: opacity 0.22s ease, transform 0.22s ease;
        }
        #overlay-code-button.entering,
        #overlay-code-button.leaving {
            opacity: 0;
            transform: translateY(-6px);
        }
        .overlay-toggle {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.2s, transform 0.2s;
            font-weight: bold;
            font-family: var(--font-mono);
        }
        .overlay-toggle:hover {
            background-color: hsl(var(--hue), 100%, 60%);
            transform: scale(1.05);
        }
        #config-overlay { right: 10px; width: 320px; }
        #stats-overlay { right: 10px; width: 320px; text-align: left; }
        #help-overlay { right: 10px; width: 450px; }

        /* Code Pane: supports docking to bottom, left, or maximized */
        #code-pane {
            position: fixed;
            background-color: var(--overlay-bg-color);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1), width 0.2s, height 0.2s;
        }
        /* Bottom dock (default) */
        #code-pane.dock-bottom { left: 0; bottom: 0; width: 100%; border-top: 2px solid var(--border-color); }
        #code-pane.dock-bottom:not(.visible) { transform: translateY(calc(100% - 40px)); }
        #code-pane.dock-bottom.visible { transform: translateY(0); height: 40vh; }
        /* Left dock */
        #code-pane.dock-left { top: 0; left: 0; height: 100vh; width: 40vw; min-width: 320px; border-right: 2px solid var(--border-color); }
        #code-pane.dock-left:not(.visible) { transform: translateX(-100%); }
        #code-pane.dock-left.visible { transform: translateX(0); }
        /* Left dock resizer */
        #code-pane .left-resizer { position: absolute; top: 0; right: -3px; bottom: 0; width: 8px; cursor: col-resize; z-index: 2; }
        #code-pane .left-resizer::before { content: ''; position: absolute; top: 0; bottom: 0; left: 3px; width: 2px; background: rgba(255,255,255,0.08); }
        #code-pane .left-resizer:hover::before { background: rgba(255,255,255,0.18); }
        /* Left dock resize tooltip */
        #code-pane .left-resize-tooltip { position: absolute; top: 8px; right: 10px; background: rgba(0,0,0,0.7); color: #fff; padding: 3px 6px; border-radius: 4px; font: 12px var(--font-mono); pointer-events: none; opacity: 0; transition: opacity 0.1s; }
        #code-pane .left-resize-tooltip.visible { opacity: 1; }
        /* Maximized */
        #code-pane.maximized { top: 0; left: 0; width: 100vw; height: 100vh; border-top: 2px solid var(--border-color); transform: none !important; }
        #code-pane.maximized .code-pane-toggle { background-color: var(--primary-color); }
        .code-pane-toggle {
            background-color: var(--primary-color);
            color: white;
            border: none;
            width: 100%;
            padding: 10px;
            cursor: pointer;
            font-size: 16px;
            font-family: var(--font-mono);
            display: flex;
            align-items: center;
            gap: 8px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.12);
            box-shadow: 0 1px 0 rgba(0,0,0,0.35);
        }
        .code-icon { width: 18px; height: 18px; opacity: 0.9; }
        .code-label { flex: 1; }
        /* Dock controls */
        .dock-controls { display: flex; gap: 6px; }
        .dock-btn {
            background: transparent;
            border: none;
            color: rgba(255,255,255,0.8);
            width: 32px;
            height: 32px;
            padding: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.15s ease, color 0.15s ease;
        }
        .dock-btn:hover { opacity: 1; }
        .dock-btn svg { width: 20px; height: 20px; display: block; }
        .dock-btn.active { color: var(--primary-color); opacity: 1; }
        .code-tabs { display: flex; align-items: center; gap: 6px; padding: 2px 6px; flex-shrink: 0; flex-wrap: wrap; row-gap: 4px; }
        .code-tabs .dock-controls { margin-left: auto; }
        .tab-button {
            flex-grow: 1;
            padding: 6px 8px;
            cursor: pointer;
            background-color: #333;
            border: none;
            color: #ddd;
            border-bottom: 3px solid transparent;
            transition: background-color 0.15s ease, border-color 0.15s ease, color 0.15s ease;
            font-family: var(--font-mono);
            opacity: 0.95;
        }
        .tab-button:hover { background-color: #3a3a3a; color: #fff; }
        .tab-button.active {
            background-color: var(--background-color);
            border-bottom-color: var(--primary-color);
            color: #fff;
            font-weight: 600;
            opacity: 1;
        }
        /* Indicator when a rule is using fallback due to recent runtime errors */
        .tab-button.fallback-active { position: relative; }
        .tab-button.fallback-active::after {
            content: '';
            position: absolute;
            top: 6px;
            right: 8px;
            width: 8px;
            height: 8px;
            background: #ff4d4f; /* subtle red dot */
            border-radius: 50%;
            box-shadow: 0 0 0 2px rgba(0,0,0,0.3);
        }
        @keyframes flash-success {
            50% { background-color: hsl(var(--hue), 100%, 30%); }
        }
        @keyframes flash-error {
            50% { background-color: #801c1c; }
        }
        .tab-button.reloaded-success {
            animation: flash-success 0.6s ease-in-out;
        }
        .tab-button.reloaded-error {
            animation: flash-error 0.6s ease-in-out;
        }
        .tab-content {
            display: none;
            flex-grow: 1;
        }
        .tab-content.active {
            display: block;
        }
        /* Maximized split controls and panes */
        .split-controls { display: none !important; }
        .split-controls label { font-family: var(--font-mono); font-size: 12px; color: #ddd; }
        .split-controls select { background: #333; color: #fff; border: 1px solid #555; padding: 4px 6px; border-radius: 4px; }
        .split-view { display: none; }
        #code-pane.maximized.split-on .split-view { display: flex; gap: 0; align-items: stretch; }
        .split-pane { flex: 1 1 50%; min-width: 0; padding: 6px; box-sizing: border-box; }
        /* Ensure tab contents are visible inside split panes even without 'active' */
        #code-pane.maximized.split-on .split-view .tab-content { display: block; width: 100%; }
        .split-sash { width: 8px; cursor: col-resize; background: transparent; position: relative; z-index: 1; }
        .split-sash::before { content: ''; position: absolute; top: 0; bottom: 0; left: 3px; width: 2px; background: rgba(255,255,255,0.08); }
        .split-sash:hover::before { background: rgba(255,255,255,0.18); }
        /* Hide tabs when in split mode, but keep row for dock icons */
        #code-pane.maximized.split-on .tab-button { display: none; }
        /* Show split toggle icon only in maximized mode */
        .dock-btn[data-action="toggle-split"] { display: none; }
        #code-pane.maximized .dock-btn[data-action="toggle-split"] { display: inline-flex; }
        /* Split pickers inside the tabs row */
        .split-picker { display: none; }
        #code-pane.maximized.split-on .code-tabs { display: flex; align-items: center; gap: 8px; padding: 0 6px; }
        #code-pane.maximized.split-on .split-picker { display: block; }
        #code-pane.maximized.split-on .dock-controls { margin-left: auto; }
        .rule-actions { display: inline-flex; gap: 6px; }
        .rule-btn { background: transparent; border: none; color: rgba(255,255,255,0.8); width: 28px; height: 28px; display: inline-flex; align-items: center; justify-content: center; cursor: pointer; opacity: 0.8; }
        .rule-btn:hover { opacity: 1; color: var(--primary-color); }
        .preset-controls { display: inline-flex; gap: 6px; align-items: center; }
        .preset-controls select { background: #333; color: #fff; border: 1px solid #555; padding: 4px 6px; border-radius: 4px; font-family: var(--font-mono); font-size: 12px; }
        /* Per-editor mini task bar */
        .editor-bar { display: flex; align-items: center; gap: 8px; padding: 6px; background: rgba(0,0,0,0.15); border: 1px solid rgba(255,255,255,0.08); border-radius: 6px; margin-bottom: 6px; }
        .editor-bar select { background: #333; color: #fff; border: 1px solid #555; padding: 4px 6px; border-radius: 4px; font-family: var(--font-mono); font-size: 12px; }
        .editor-bar .bar-btn { background: transparent; border: 1px solid rgba(255,255,255,0.15); color: #ddd; padding: 2px 8px; border-radius: 4px; cursor: pointer; font-family: var(--font-mono); font-size: 12px; opacity: 0.85; }
        .editor-bar .bar-btn:hover { opacity: 1; color: var(--primary-color); border-color: var(--primary-color); }
        
        .split-picker select { background: #333; color: #fff; border: 1px solid #555; padding: 4px 6px; border-radius: 4px; font-family: var(--font-mono); font-size: 12px; }
        .split-picker.split-left { justify-self: start; }
        .split-picker.split-right { justify-self: end; }
        /* Editor sizing by dock mode */
        .CodeMirror { border: none; }
        #code-pane.dock-bottom.visible .CodeMirror { height: calc(40vh - 92px) !important; }
        #code-pane.dock-left .CodeMirror { height: calc(100vh - 92px) !important; }
        #code-pane.maximized .CodeMirror { height: calc(100vh - 92px) !important; }
        /* Editor gutter tweaks */
        .CodeMirror-gutters { background: #2a2a2a !important; border-right: 1px solid #444 !important; }
        .CodeMirror-linenumbers { min-width: 2.5ch !important; }
        .CodeMirror-linenumber { padding: 0 6px 0 4px !important; color: #aaa !important; }
        /* Minimized left dock: show only icon in header */
        #code-pane.dock-left:not(.visible) .code-label { display: none; }
        #code-pane.dock-left:not(.visible) .code-tabs { display: none; }
        #code-pane.dock-left:not(.visible) .code-pane-toggle { width: 48px; justify-content: center; }
        .config-item {
            margin-bottom: 12px;
        }
        .config-item label {
            display: block;
            margin-bottom: 5px;
        }
        .config-item input[type="range"], .config-item select {
            width: 100%;
        }
        .config-item select {
             background-color: #333;
             color: white;
             border: 1px solid #555;
             padding: 5px;
             border-radius: 3px;
        }
        .config-item input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            padding: 0;
        }
        .config-note { color: #aaaaaa; font-size: 12px; margin: 4px 0 8px; font-family: var(--font-mono); }
        /* Config overlay tabs */
        .config-tab-bar { display: flex; gap: 8px; margin-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,0.12); }
        .config-tab {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.15);
            border-bottom: none;
            color: #ddd;
            padding: 6px 10px;
            border-radius: 6px 6px 0 0;
            cursor: pointer;
            font-family: var(--font-mono);
            font-size: 12px;
            opacity: 0.85;
        }
        .config-tab:hover { opacity: 1; color: var(--primary-color); border-color: var(--primary-color); }
        .config-tab.active {
            background: rgba(255,255,255,0.06);
            color: var(--primary-color);
            border-color: var(--primary-color);
            border-bottom: 1px solid var(--overlay-bg-color);
        }
        h2, h3 {
            color: var(--primary-color);
            margin-top: 0;
            font-family: var(--font-mono);
            font-weight: 500;
        }
        #stats-overlay h3 { color: var(--secondary-color); }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 300px;
            margin: 0 auto;
        }
        .chart-toggle {
            bottom: 5px;
            left: 5px;
            background-color: rgba(0,0,0,0.5);
            padding: 5px 8px;
            border-radius: 5px;
            font-size: 12px;
        }
        .chart-toggle label {
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .chart-container canvas {
            background-color: #111;
            border-radius: 5px;
            width: 100%;
            /* aspect-ratio: 1 / 1; */
            display: block;
        }
        #help-overlay code { background-color: #333; padding: 2px 5px; border-radius: 3px; }

        /* Form + button styling (exclude editor and config tabs) */
        button:not(.dock-btn):not(.close-button):not(.tab-button):not(.config-tab) {
            background: linear-gradient(180deg, hsl(var(--hue), 100%, 55%), hsl(var(--hue), 100%, 47%));
            color: #fff;
            border: 1px solid rgba(255,255,255,0.18);
            border-bottom-color: rgba(0,0,0,0.35);
            border-radius: 6px;
            padding: 6px 10px;
            font-family: var(--font-mono);
            font-size: 12px;
            cursor: pointer;
            box-shadow: 0 1px 0 rgba(0,0,0,0.35);
            transition: transform 0.06s ease, filter 0.12s ease;
        }
        button:not(.dock-btn):not(.close-button):not(.tab-button):not(.config-tab):hover { filter: brightness(1.05); }
        button:not(.dock-btn):not(.close-button):not(.tab-button):not(.config-tab):active { transform: translateY(1px); }
        .bar-btn { background: rgba(255,255,255,0.06) !important; border-color: rgba(255,255,255,0.18) !important; color: #eee !important; }
        .bar-btn:hover { color: #fff !important; }
        /* Config tabbar styled like tabs */
        .config-tab-bar { display: flex; gap: 6px; border-bottom: 1px solid rgba(255,255,255,0.12); margin-bottom: 6px; }
        .config-tab { background: #333; color: #ddd; border: none; padding: 6px 8px; border-bottom: 3px solid transparent; font-family: var(--font-mono); cursor: pointer; transition: background-color 0.15s ease, border-color 0.15s ease, color 0.15s ease; opacity: 0.95; }
        .config-tab:hover { background: #3a3a3a; color: #fff; }
        .config-tab.active { background: var(--background-color); border-bottom-color: var(--primary-color); color: #fff; font-weight: 600; opacity: 1; }
        /* Primary action button */
        .primary-btn { background: linear-gradient(180deg, hsl(var(--hue), 100%, 60%), hsl(var(--hue), 100%, 50%)) !important; color: #fff !important; border: 1px solid rgba(255,255,255,0.22) !important; }
        
        /* Text inputs/selects */
        .form-input,
        input[type="text"], input[type="number"], input[type="color"],
        select {
            background: #1e1e1e;
            color: #fff;
            border: 1px solid rgba(255,255,255,0.18);
            border-radius: 6px;
            padding: 6px 8px;
            font-family: var(--font-mono);
            font-size: 12px;
            outline: none;
        }
        .form-input:focus,
        input[type="text"]:focus, input[type="number"]:focus, input[type="color"]:focus,
        select:focus { border-color: var(--primary-color); box-shadow: 0 0 0 2px rgba(255,255,255,0.05); }

        /* Custom checkbox styling: darker when unchecked */
        input[type="checkbox"] {
            appearance: none;
            -webkit-appearance: none;
            width: 14px; height: 14px;
            border: 1px solid rgba(255,255,255,0.25);
            border-radius: 3px;
            background: #161616;
            display: inline-block; position: relative;
            cursor: pointer;
        }
        input[type="checkbox"]:hover { border-color: rgba(255,255,255,0.4); }
        input[type="checkbox"]:checked { background: hsl(var(--hue), 100%, 55%); border-color: hsl(var(--hue), 100%, 60%); }
        input[type="checkbox"]:checked::after { content: ''; position: absolute; left: 3px; top: 1px; width: 6px; height: 9px; border: 2px solid #fff; border-top: 0; border-left: 0; transform: rotate(45deg); }

        /* Rules actions row (avoid wrapping the 3 main actions) */
        .rules-actions-row { display: flex; gap: 8px; flex-wrap: nowrap; overflow-x: auto; padding-bottom: 2px; }

        /* Prevent editor toolbar from overflowing the canvas */
        #code-pane { overflow: hidden; }
        .tab-content { overflow: auto; }
        .editor-bar { flex-wrap: wrap; }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/dracula.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/lint/lint.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/show-hint.min.css">
</head>
<body>
    <canvas id="boids-canvas"></canvas>
    
    <div class="overlay-toggle-container">
        <button class="overlay-toggle" data-overlay="config-overlay">Config</button>
        <button class="overlay-toggle" data-overlay="stats-overlay">Stats</button>
        <button class="overlay-toggle" data-overlay="help-overlay">Help</button>
        <button class="overlay-toggle" data-overlay="info-overlay">Info</button>
        <button class="overlay-toggle" id="reset-button" title="Reset simulation (boids + stats)">Reset</button>
    </div>

    <div class="overlay" id="config-overlay"></div>
    <div class="overlay" id="stats-overlay"></div>
    <div class="overlay" id="help-overlay"></div>
    <div class="overlay" id="info-overlay"></div>

    <div id="code-pane" class="dock-bottom">
        <button class="code-pane-toggle">
            <!-- Minimalist editor icon (window with lines) -->
            <svg class="code-icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <rect x="3" y="5" width="18" height="14" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="1.5"/>
                <circle cx="6.5" cy="7.5" r="0.9" fill="currentColor"/>
                <circle cx="9.5" cy="7.5" r="0.9" fill="currentColor"/>
                <line x1="6" y1="11" x2="18" y2="11" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                <line x1="6" y1="14" x2="15" y2="14" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
            </svg>
            <span class="code-label">Code</span>
        </button>
        <div class="code-tabs">
            <span class="split-picker split-left"><select id="split-left"></select></span>
            <span class="split-picker split-right"><select id="split-right"></select></span>
            <button class="tab-button active" data-tab="cohesion">Cohesion</button>
            <button class="tab-button" data-tab="separation">Separation</button>
            <button class="tab-button" data-tab="alignment">Alignment</button>
            <button class="tab-button" data-tab="novel">Novel</button>
            <span class="dock-controls" aria-label="Code pane docking controls">
                <!-- Split toggle icon: two panes -->
                <button class="dock-btn" data-action="toggle-split" title="Toggle split view" aria-label="Toggle split view">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <rect x="4" y="5" width="16" height="14" rx="2"/>
                        <line x1="12" y1="6" x2="12" y2="19" stroke="currentColor" stroke-width="1.5"/>
                    </svg>
                </button>
                <!-- Bottom dock icon: bottom band inside a window -->
                <button class="dock-btn" data-dock="bottom" title="Dock bottom" aria-label="Dock bottom">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <rect x="4" y="5" width="16" height="14" rx="2"/>
                        <rect x="5.5" y="16" width="13" height="2.5" fill="currentColor" stroke="none"/>
                    </svg>
                </button>
                <!-- Left dock icon: left band inside a window -->
                <button class="dock-btn" data-dock="left" title="Dock left" aria-label="Dock left">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <rect x="4" y="5" width="16" height="14" rx="2"/>
                        <rect x="5.5" y="6.5" width="2.5" height="11" fill="currentColor" stroke="none"/>
                    </svg>
                </button>
                <!-- Maximize icon: full window fill -->
                <button class="dock-btn" data-dock="max" title="Maximize" aria-label="Maximize">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <rect x="4" y="5" width="16" height="14" rx="2"/>
                        <rect x="5.5" y="6.5" width="13" height="11" fill="currentColor" stroke="none"/>
                    </svg>
                </button>
            </span>
        </div>
        <div class="split-view" id="split-view">
            <div class="split-pane" data-slot="left"></div>
            <div class="split-sash" aria-hidden="true"></div>
            <div class="split-pane" data-slot="right"></div>
        </div>
        <div id="cohesion" class="tab-content active"><textarea></textarea></div>
        <div id="separation" class="tab-content"><textarea></textarea></div>
        <div id="alignment" class="tab-content"><textarea></textarea></div>
        <div id="novel" class="tab-content"><textarea></textarea></div>
        <div class="left-resizer" aria-hidden="true"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jshint/2.13.4/jshint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/lint/lint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/lint/javascript-lint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/show-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/javascript-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.1/chart.min.js"></script>
    
    <script>
    (() => {
        'use strict';

        /**
         * Typedefs to clarify rule API, in-scope vars, and common shapes.
         * These help autocomplete and readability in the embedded editors.
         */
        /**
         * @typedef {Object} Vector
         * @property {number} x
         * @property {number} y
         * @property {(v: Vector) => Vector} add
         * @property {(v: Vector) => Vector} sub
         * @property {(s: number) => Vector} mult
         * @property {(s: number) => Vector} div
         * @property {() => number} mag
         * @property {() => Vector} normalize
         * @property {(max: number) => Vector} limit
         * @property {() => number} heading
         * @property {() => Vector} clone
         */
        /** @typedef {{pos: Vector, vel: Vector, acc: Vector, maxSpeed: number, maxForce: number, hue: number, size: number, update: (gs: GameState) => void, draw: (ctx: CanvasRenderingContext2D) => void}} Boid */
        /** @typedef {{boids: Boid[], quadtree: any, width: number, height: number}} GameState */
        /** @typedef {{pos: {x: number, y: number}, down: boolean}} Mouse */
        /**
         * @typedef {Object} Config
         * @property {number} hue
         * @property {number} boidCount
         * @property {number} maxSpeed
         * @property {number} maxForce
         * @property {number} perceptionRadius
         * @property {boolean} visualizeQuadtree
         * @property {boolean} debug
         * @property {number} cohesionWeight
         * @property {number} separationWeight
         * @property {number} alignmentWeight
         * @property {number} novelWeight
         * @property {'triangle'|'circle'|'oval'|'ring'} boidShape
         * @property {number} boidSize
         * @property {number} boidSizeVariance
         * @property {string} header
         * @property {string} subheader
         */
        /**
         * @callback RuleFunction
         * @param {Boid} boid
         * @param {GameState} gameState
         * @param {Boid[]} neighbors
         * @param {Config} config
         * @param {Mouse} mouse
         * @param {typeof Vector} Vector
         * @param {{
         *   depositTrail: (x:number, y:number, amount?:number) => void,
         *   addDrawable: (fn: (ctx: CanvasRenderingContext2D, gs: GameState) => void) => void,
         *   spawnBoid: (x:number, y:number, opts?:{ hue?:number, size?:number, role?:'pred'|'prey', vel?:{x:number,y:number} }) => void,
         *   destroyBoid: (b: Boid) => void,
         *   shake: (amplitude:number, durationMs:number) => void
         * }} api - Optional helpers for visuals/overlays.
         * @returns {Vector}
         */

        // --- GLOBAL STATE & CONSTANTS ---
        const canvas = document.getElementById('boids-canvas');
        const ctx = canvas.getContext('2d');

        let config = {};
        const editors = {};
        const charts = {};
        
        let gameState = {
            boids: [],
            quadtree: null,
            width: 0,
            height: 0,
        };

        // Optional rule-driven visuals collection and pheromone trails
        const drawables = [];
        const pheromones = {
            enabled: true,
            cell: 8,
            cols: 0,
            rows: 0,
            grid: null,
            decay: 0.97,
        };
        // Quadtree hotspot heat (decayed over time)
        const qtHeat = {
            enabled: true,
            cell: 16,
            cols: 0,
            rows: 0,
            grid: null,
            decay: 0.98,
        };

        // Pending ops requested by rules (applied safely after updates)
        const _pendingSpawns = [];
        const _pendingKills = new Set();
        // Lightweight screen-shake state
        const _shake = { endTime: 0, amplitude: 0 };

        const RuleAPI = {
            depositTrail(x, y, amount = 1) {
                if (!pheromones.enabled || !pheromones.grid) return;
                const cx = Math.floor(Math.max(0, Math.min(gameState.width - 1, x)) / pheromones.cell);
                const cy = Math.floor(Math.max(0, Math.min(gameState.height - 1, y)) / pheromones.cell);
                const i = cy * pheromones.cols + cx;
                if (i >= 0 && i < pheromones.grid.length) pheromones.grid[i] += amount;
            },
            addDrawable(fn) {
                if (typeof fn !== 'function') return;
                const d = Math.max(0, Math.min(2, typeof config.visualDensity === 'number' ? config.visualDensity : 1));
                // If d < 1, probabilistically skip; if d > 1, occasionally duplicate for richness
                if (d < 1 && Math.random() > d) return;
                drawables.push(fn);
                if (d > 1 && Math.random() < (d - 1)) drawables.push(fn);
            },
            spawnBoid(x, y, opts = {}) {
                if (typeof x !== 'number' || typeof y !== 'number') return;
                _pendingSpawns.push({ x, y, opts });
            },
            destroyBoid(b) {
                if (b && typeof b === 'object') _pendingKills.add(b);
            },
            shake(amplitude = 6, durationMs = 220) {
                const now = performance.now();
                // If a shake is in progress, keep the stronger one
                const rem = Math.max(0, _shake.endTime - now);
                const cur = rem > 0 ? _shake.amplitude : 0;
                _shake.amplitude = Math.max(cur, Math.max(0, amplitude));
                _shake.endTime = Math.max(_shake.endTime, now + Math.max(0, durationMs|0));
            }
        };

        const mouse = {
            pos: { x: -1000, y: -1000 },
            prev: { x: -1000, y: -1000 },
            vel: { x: 0, y: 0 },
            down: false,
            clickEffect: null
        };

        let lastTime = 0;
        let fps = 0;
        const fpsHistory = [];
        const updateTimeHistory = [];
        const drawablesHistory = [];
        const angleHistory = [];
        // Quadtree perf histories
        const qtAvgNodesHistory = [];
        let quadStats = {
            // per-frame accumulators
            nodeCount: 0,
            leafCount: 0,
            maxDepth: 0,
            avgLeafFill: 0,
            queryCount: 0,
            nodesVisitedTotal: 0,
            nodesVisitedAccum: 0,
            nodesVisitedMax: 0,
            intersectsChecks: 0,
            pointTests: 0,
        };
        const MAX_ANGLE_HISTORY = 750;

        const userFunctions = [];

        // --- UTILITY CLASSES & FUNCTIONS ---

        class Vector {
            constructor(x = 0, y = 0) { this.x = x; this.y = y; }
            add(v) { this.x += v.x; this.y += v.y; return this; }
            sub(v) { this.x -= v.x; this.y -= v.y; return this; }
            mult(s) { this.x *= s; this.y *= s; return this; }
            div(s) { if (s !== 0) { this.x /= s; this.y /= s; } return this; }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            normalize() { const m = this.mag(); if (m > 0) this.div(m); return this; }
            limit(max) { if (this.mag() > max) { this.normalize().mult(max); } return this; }
            heading() { return Math.atan2(this.y, this.x); }
            clone() { return new Vector(this.x, this.y); }
            static add(v1, v2) { return new Vector(v1.x + v2.x, v1.y + v2.y); }
            static sub(v1, v2) { return new Vector(v1.x - v2.x, v1.y - v2.y); }
            static dist(v1, v2) { return Vector.sub(v1, v2).mag(); }
            static random2D() { const angle = Math.random() * Math.PI * 2; return new Vector(Math.cos(angle), Math.sin(angle)); }
        }

        function getURLParams() {
            const params = new URLSearchParams(window.location.search);
            const result = {};
            for (const [key, value] of params) {
                try {
                    result[key] = JSON.parse(value);
                } catch (e) {
                    result[key] = value;
                }
            }
            return result;
        }

        function updateURL(key, value) {
            const params = new URLSearchParams(window.location.search);
            params.set(key, JSON.stringify(value));
            const newUrl = `${window.location.pathname}?${params.toString()}`;
            window.history.pushState({ path: newUrl }, '', newUrl);
            logConfig(`URL updated: ${key} = ${JSON.stringify(value)}`);
        }

        function updateAllURLParams() {
            if (!config.debug) return;
            const params = new URLSearchParams();
            for (const key in config) {
                params.set(key, JSON.stringify(config[key]));
            }
            const newUrl = `${window.location.pathname}?${params.toString()}`;
            window.history.replaceState({ path: newUrl }, '', newUrl);
            logConfig('Debug mode: All config params updated in URL.');
        }
        
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function logConfig(...args) {
            if (config.debug) {
                console.log('[Boids Log]', ...args);
            }
        }

        // --- SIMULATION CORE ---

        class Rectangle {
            constructor(x, y, w, h) {
                this.x = x; this.y = y; this.w = w; this.h = h;
            }
            contains(boid) {
                return (boid.pos.x >= this.x - this.w &&
                        boid.pos.x < this.x + this.w &&
                        boid.pos.y >= this.y - this.h &&
                        boid.pos.y < this.y + this.h);
            }
            intersects(range) {
                return !(range.x - range.w > this.x + this.w ||
                         range.x + range.w < this.x - this.w ||
                         range.y - range.h > this.y + this.h ||
                         range.y + range.h < this.y - this.h);
            }
        }

        class QuadTree {
            constructor(boundary, capacity) {
                this.boundary = boundary;
                this.capacity = capacity;
                this.boids = [];
                this.divided = false;
                this.visitHits = 0; // number of times this node accepted a query this frame
            }

            subdivide() {
                const { x, y, w, h } = this.boundary;
                const nw = new Rectangle(x - w / 2, y - h / 2, w / 2, h / 2);
                this.northwest = new QuadTree(nw, this.capacity);
                const ne = new Rectangle(x + w / 2, y - h / 2, w / 2, h / 2);
                this.northeast = new QuadTree(ne, this.capacity);
                const sw = new Rectangle(x - w / 2, y + h / 2, w / 2, h / 2);
                this.southwest = new QuadTree(sw, this.capacity);
                const se = new Rectangle(x + w / 2, y + h / 2, w / 2, h / 2);
                this.southeast = new QuadTree(se, this.capacity);
                this.divided = true;
            }

            insert(boid) {
                if (!this.boundary.contains(boid)) return false;
                if (this.boids.length < this.capacity) {
                    this.boids.push(boid);
                    return true;
                }
                if (!this.divided) this.subdivide();
                return this.northeast.insert(boid) || this.northwest.insert(boid) || this.southeast.insert(boid) || this.southwest.insert(boid);
            }

            query(range, found = [], __root = true) {
                // Root-call accounting snapshot
                let beforeVisited = 0, beforeInter = 0, beforePts = 0;
                if (__root) {
                    beforeVisited = quadStats.nodesVisitedTotal;
                    beforeInter = quadStats.intersectsChecks;
                    beforePts = quadStats.pointTests;
                }

                quadStats.intersectsChecks++;
                if (!this.boundary.intersects(range)) return found;
                quadStats.nodesVisitedTotal++;
                this.visitHits++;
                // Deposit heat at node center (coarse) for hot regions overlay
                try {
                    if (qtHeat.grid && config.visualizeQuadtreeHot) {
                        const cx = Math.floor(Math.max(0, Math.min(gameState.width - 1, this.boundary.x)) / qtHeat.cell);
                        const cy = Math.floor(Math.max(0, Math.min(gameState.height - 1, this.boundary.y)) / qtHeat.cell);
                        const i = cy * qtHeat.cols + cx;
                        if (i >= 0 && i < qtHeat.grid.length) qtHeat.grid[i] += 0.2;
                    }
                } catch (e) {}
                for (let b of this.boids) {
                    quadStats.pointTests++;
                    if (range.contains(b)) found.push(b);
                }
                if (this.divided) {
                    this.northwest.query(range, found, false);
                    this.northeast.query(range, found, false);
                    this.southwest.query(range, found, false);
                    this.southeast.query(range, found, false);
                }
                if (__root) {
                    const dv = quadStats.nodesVisitedTotal - beforeVisited;
                    // const di = quadStats.intersectsChecks - beforeInter; // available if needed later
                    // const dp = quadStats.pointTests - beforePts;
                    quadStats.nodesVisitedAccum += dv;
                    if (dv > quadStats.nodesVisitedMax) quadStats.nodesVisitedMax = dv;
                    quadStats.queryCount++;
                }
                return found;
            }

            draw(ctx) {
                // Optional fill to indicate query visits this frame
                if (config.visualizeQuadtreeVisits && (this.visitHits||0) > 0) {
                    const a = Math.min(0.35, ((this.visitHits||0) / Math.max(1, quadStats.visitMax||1)) * 0.35);
                    ctx.fillStyle = `hsla(${(config.hue + 200) % 360}, 100%, 60%, ${a.toFixed(3)})`;
                    ctx.fillRect(this.boundary.x - this.boundary.w, this.boundary.y - this.boundary.h, this.boundary.w * 2, this.boundary.h * 2);
                }
                ctx.strokeStyle = `hsla(${config.hue}, 100%, 50%, 0.2)`;
                ctx.strokeRect(this.boundary.x - this.boundary.w, this.boundary.y - this.boundary.h, this.boundary.w * 2, this.boundary.h * 2);
                if (this.divided) {
                    this.northeast.draw(ctx); this.northwest.draw(ctx);
                    this.southeast.draw(ctx); this.southwest.draw(ctx);
                }
            }
        }
        
        class Boid {
            constructor(x, y) {
                this.pos = new Vector(x, y);
                this.vel = Vector.random2D().mult(Math.random() * 2 + 2);
                this.acc = new Vector();
                this.maxSpeed = config.maxSpeed;
                this.maxForce = config.maxForce;
                this.hue = (config.hue + (Math.random() * 60 - 30) + 360) % 360;
                this.size = Math.max(1, config.boidSize + (Math.random() * 2 - 1) * config.boidSizeVariance);
            }

            update(gameState) {
                const perceptionRadius = config.perceptionRadius;
                const range = new Rectangle(this.pos.x, this.pos.y, perceptionRadius, perceptionRadius);
                const neighbors = gameState.quadtree.query(range).filter(other => other !== this);
                this.acc.mult(0);
                for (const fn of userFunctions) {
                    if (fn.weight > 0 && fn.updateBoid) {
                        const force = fn.updateBoid(this, gameState, neighbors);
                        if (force instanceof Vector) {
                           force.mult(fn.weight);
                           this.acc.add(force);
                        }
                    }
                }
                this.vel.add(this.acc);
                this.vel.limit(this.maxSpeed);
                this.pos.add(this.vel);
                this.edges();
            }

            edges() {
                if (this.pos.x > gameState.width) this.pos.x = 0;
                else if (this.pos.x < 0) this.pos.x = gameState.width;
                if (this.pos.y > gameState.height) this.pos.y = 0;
                else if (this.pos.y < 0) this.pos.y = gameState.height;
            }

            draw(ctx) {
                const angle = this.vel.heading();
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.rotate(angle);
                ctx.fillStyle = `hsl(${this.hue}, 100%, 70%)`;
                ctx.strokeStyle = `hsl(${this.hue}, 100%, 70%)`;
                ctx.beginPath();
                switch (config.boidShape) {
                    case 'circle':
                        ctx.arc(0, 0, this.size / 1.5, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'ring':
                        ctx.arc(0, 0, this.size / 2, 0, Math.PI * 2);
                        ctx.lineWidth = Math.max(1, this.size / 4);
                        ctx.stroke();
                        break;
                    case 'oval':
                        ctx.scale(1.5, 0.6);
                        ctx.arc(0, 0, this.size / 2, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'triangle':
                    default:
                        ctx.moveTo(this.size, 0);
                        ctx.lineTo(-this.size / 2, -this.size / 2);
                        ctx.lineTo(-this.size / 2, this.size / 2);
                        ctx.closePath();
                        ctx.fill();
                        break;
                }
                ctx.restore();
            }
        }

        // --- DEFAULT USER FUNCTIONS ---
        
        const defaultFunctionsCode = {
          cohesion: `/**
  Cohesion — steer toward the average position of nearby boids.
  Steer toward the neighbors' centroid to keep the flock together.

  Rule API
  @function rule
  @param {Boid} boid - Current boid under update (pos, vel, acc, maxSpeed, maxForce, size, hue)
  @param {{boids: Boid[], quadtree: any, width: number, height: number}} gameState - Global sim state
  @param {Boid[]} neighbors - Nearby boids (pre-filtered by perception)
  @param {Object} config - Live configuration (e.g., perceptionRadius, weights, boidShape, etc.)
  @param {{pos: {x:number, y:number}, down: boolean}} mouse - Pointer state
  @param {typeof Vector} Vector - 2D vector helper class
  @param {{depositTrail:(x:number,y:number,a?:number)=>void, addDrawable:(fn:Function)=>void}} api - Optional visuals helpers
  @returns {Vector} Steering force to apply this frame
  Steps:
    1) Average neighbor positions within perception radius
    2) Desired velocity toward that center at maxSpeed
    3) Steering = desired - current velocity, limited to maxForce
*/
const radius = config.perceptionRadius;
let center = new Vector(0, 0);
let total = 0;
for (const other of neighbors) {
  if (other !== boid) {
    const d = Vector.dist(boid.pos, other.pos);
    if (d > 0 && d < radius) {
      center.add(other.pos);
      total++;
    }
  }
}
if (total === 0) return new Vector(0, 0);
center.div(total);
const desired = Vector.sub(center, boid.pos).normalize().mult(boid.maxSpeed);
return Vector.sub(desired, boid.vel).limit(boid.maxForce);`,

          separation: `/**
  Separation — steer away from nearby boids to avoid crowding.
  Avoid collisions using a strong inverse‑square repulsion at close range.

  Rule API
  @function rule
  @param {Boid} boid
  @param {{boids: Boid[], quadtree: any, width: number, height: number}} gameState
  @param {Boid[]} neighbors
  @param {Object} config
  @param {{pos: {x:number,y:number}, down: boolean}} mouse
  @param {typeof Vector} Vector
  @param {{depositTrail:(x:number,y:number,a?:number)=>void, addDrawable:(fn:Function)=>void}} api
  @returns {Vector}
  Strategy: Inverse-square falloff (1/d^2) gives strong close-range repulsion.
  Tip: Slightly higher force multiplier helps quick response.
*/
const desiredSeparation = Math.max(8, config.boidSize * 2.5);
let steer = new Vector(0, 0);
let total = 0;
for (const other of neighbors) {
  if (other !== boid) {
    const offset = Vector.sub(boid.pos, other.pos);
    const d = offset.mag();
    if (d > 0 && d < desiredSeparation) {
      // Inverse-square falloff: closer ⇒ stronger
      offset.normalize().div(d * d);
      steer.add(offset);
      total++;
    }
  }
}
if (total === 0) return new Vector(0, 0);
steer.div(total).normalize().mult(boid.maxSpeed);
return Vector.sub(steer, boid.vel).limit(boid.maxForce * 1.5);`,

          alignment: `/**
  Alignment — match the average heading (velocity) of neighbors.
  Blend your heading with the local mean velocity to synchronize motion.

  Rule API
  @function rule
  @param {Boid} boid
  @param {{boids: Boid[], quadtree: any, width: number, height: number}} gameState
  @param {Boid[]} neighbors
  @param {Object} config
  @param {{pos: {x:number,y:number}, down: boolean}} mouse
  @param {typeof Vector} Vector
  @param {{depositTrail:(x:number,y:number,a?:number)=>void, addDrawable:(fn:Function)=>void}} api
  @returns {Vector}
*/
const radius = config.perceptionRadius;
let avgVel = new Vector(0, 0);
let total = 0;
for (const other of neighbors) {
  if (other !== boid) {
    const d = Vector.dist(boid.pos, other.pos);
    if (d > 0 && d < radius) {
      avgVel.add(other.vel);
      total++;
    }
  }
}
if (total === 0) return new Vector(0, 0);
avgVel.div(total).normalize().mult(boid.maxSpeed);
return Vector.sub(avgVel, boid.vel).limit(boid.maxForce);`,

          novel: `/**
  Novel — mouse-driven flee force when mouse is down.
  When pressed, boids within a radius steer away from the cursor.

  Rule API
  @function rule
  @param {Boid} boid
  @param {{boids: Boid[], quadtree: any, width: number, height: number}} gameState
  @param {Boid[]} neighbors
  @param {Object} config
  @param {{pos: {x:number,y:number}, down: boolean}} mouse
  @param {typeof Vector} Vector
  @param {{depositTrail:(x:number,y:number,a?:number)=>void, addDrawable:(fn:Function)=>void}} api
  @returns {Vector}
  Behavior: if within fleeRadius of the cursor, push away proportionally.
*/
const mouseForce = new Vector(0, 0);
const mousePos = new Vector(mouse.pos.x, mouse.pos.y);
const fleeRadius = 150;
const d = Vector.dist(boid.pos, mousePos);
if (mouse.down && d < fleeRadius) {
  const strength = (fleeRadius - d) / fleeRadius; // 0..1
  const desired = Vector.sub(boid.pos, mousePos) // away from mouse
    .normalize()
    .mult(boid.maxSpeed * 2.0 * strength);
  const steer = Vector.sub(desired, boid.vel).limit(boid.maxForce * 2.0);
  mouseForce.add(steer);
}
return mouseForce;`
        };

        // --- RULE PRESETS ---
        // Tastefully documented presets. Each snippet implements the Rule API and returns a Vector.
        const rulePresets = [
          // Templates — quick starters to illustrate the Drawable API
          { id: 'template-drawable-ring', name: 'Template — Drawable Ring', code: `/**
  Drawable Ring (Template)
  Draws a faint ring at the boid position every frame. No steering.
  Use: replace visuals or steering to build your own rule.
  @returns {Vector}
*/
if (typeof api !== 'undefined' && api && api.addDrawable) {
  const x = boid.pos.x, y = boid.pos.y, r = 12;
  api.addDrawable(function(ctx){
    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.strokeStyle = 'hsla(' + (boid.hue) + ',100%,70%,0.18)';
    ctx.lineWidth = 1; ctx.stroke();
  });
}
return new Vector();` },

          { id: 'template-drawable-streak', name: 'Template — Drawable Streak', code: `/**
  Drawable Streak (Template)
  Draws a short line along current velocity; minimal forward bias.
  @returns {Vector}
*/
const v = boid.vel.clone().normalize().mult(18);
if (typeof api !== 'undefined' && api && api.addDrawable) {
  const x = boid.pos.x, y = boid.pos.y;
  api.addDrawable(function(ctx){
    ctx.beginPath(); ctx.moveTo(x - v.x, y - v.y); ctx.lineTo(x + v.x * 0.3, y + v.y * 0.3);
    ctx.strokeStyle = 'hsla(' + (boid.hue) + ',100%,70%,0.25)'; ctx.lineWidth = 1.5; ctx.stroke();
  });
}
return v.mult(0.001);` },

          { id: 'template-trail-heatmap', name: 'Template — Trail Heatmap', code: `/**
  Trail Heatmap (Template)
  Deposits into the pheromone grid to leave fading trails.
  @returns {Vector}
*/
if (typeof api !== 'undefined' && api && api.depositTrail) {
  api.depositTrail(boid.pos.x, boid.pos.y, 1.0);
}
return new Vector();` },

          { id: 'template-drawable-arrow', name: 'Template — Drawable Arrow', code: `/**
  Drawable Arrow (Template)
  Draws a velocity arrow with a small head; tiny forward bias.
  @returns {Vector}
*/
const dir = boid.vel.clone().normalize();
const L = 18; const x = boid.pos.x, y = boid.pos.y;
if (typeof api !== 'undefined' && api && api.addDrawable) {
  api.addDrawable(function(ctx){
    const tipX = x + dir.x * L, tipY = y + dir.y * L;
    const ortX = -dir.y, ortY = dir.x; // perpendicular
    ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(tipX, tipY);
    ctx.strokeStyle = 'hsla(' + (boid.hue) + ',100%,70%,0.28)'; ctx.lineWidth = 1.5; ctx.stroke();
    // Arrow head
    ctx.beginPath();
    ctx.moveTo(tipX, tipY);
    ctx.lineTo(tipX - dir.x * 5 + ortX * 3, tipY - dir.y * 5 + ortY * 3);
    ctx.moveTo(tipX, tipY);
    ctx.lineTo(tipX - dir.x * 5 - ortX * 3, tipY - dir.y * 5 - ortY * 3);
    ctx.strokeStyle = 'hsla(' + (boid.hue) + ',100%,70%,0.28)'; ctx.lineWidth = 1; ctx.stroke();
  });
}
return dir.mult(0.0015);` },

          { id: 'template-drawable-petals', name: 'Template — Drawable Petals', code: `/**
  Drawable Petals (Template)
  Draws petal-like arcs around the boid. Purely visual.
  @returns {Vector}
*/
if (typeof api !== 'undefined' && api && api.addDrawable) {
  const x=boid.pos.x, y=boid.pos.y, r=8, n=5;
  api.addDrawable(function(ctx){
    ctx.strokeStyle='hsla(' + (boid.hue) + ',100%,70%,0.18)'; ctx.lineWidth=1;
    for (let i=0;i<n;i++) { const a=i*(Math.PI*2/n); ctx.beginPath(); ctx.arc(x+Math.cos(a)*r, y+Math.sin(a)*r, r*0.6, a-0.7, a+0.7); ctx.stroke(); }
  });
}
return new Vector();` },

          { id: 'template-grid-cell-highlight', name: 'Template — Grid Cell Highlight', code: `/**
  Grid Cell Highlight (Template)
  Highlights the 16px grid cell the boid occupies; no steering.
  @returns {Vector}
*/
const CELL=16; const cx=Math.floor(boid.pos.x/CELL)*CELL, cy=Math.floor(boid.pos.y/CELL)*CELL;
if (typeof api !== 'undefined' && api && api.addDrawable) {
  api.addDrawable(function(ctx){
    ctx.strokeStyle='hsla(' + (boid.hue) + ',100%,70%,0.18)'; ctx.lineWidth=1;
    ctx.strokeRect(cx+0.5, cy+0.5, CELL-1, CELL-1);
  });
}
return new Vector();` },

          { id: 'template-metrics-overlay', name: 'Template — Metrics Overlay', code: `/**
  Metrics Overlay (Template)
  Shows speed and neighbor count near the boid. Handy for debugging.
  @returns {Vector}
*/
const speed = boid.vel.mag().toFixed(1);
const ncount = neighbors.length;
if (typeof api !== 'undefined' && api && api.addDrawable) {
  const x=boid.pos.x, y=boid.pos.y;
  api.addDrawable(function(ctx){
    ctx.fillStyle = '#ddd'; ctx.font = '10px monospace'; ctx.textAlign='left';
    ctx.fillText('v:'+speed+' n:'+ncount, x+6, y-6);
  });
}
return new Vector();` },
          // Core rules
          { id: 'cohesion-core', name: 'Cohesion (Core)', code: defaultFunctionsCode.cohesion },
          { id: 'alignment-core', name: 'Alignment (Core)', code: defaultFunctionsCode.alignment },
          { id: 'separation-core', name: 'Separation (Core)', code: defaultFunctionsCode.separation },
          { id: 'novel-core', name: 'Novel (Core)', code: defaultFunctionsCode.novel },

          // Presets — styled with JSDoc and succinct guidance
          { id: 'neighbor-centroid-pull', name: 'Neighbor Centroid Pull', code: `/**
  Neighbor Centroid Pull
  Pull gently toward the average neighbor position (soft cohesion)
  @returns {Vector}
*/
const r = config.perceptionRadius;
let c = new Vector(0, 0), n = 0;
for (const o of neighbors) {
  const d = Vector.dist(boid.pos, o.pos);
  if (d > 0 && d < r) { c.add(o.pos); n++; }
}
if (!n) return new Vector();
c.div(n);
const desired = Vector.sub(c, boid.pos).normalize().mult(boid.maxSpeed * 0.8);
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.8);` },

          { id: 'anti-alignment-swirl', name: 'Anti‑alignment Swirl', code: `/**
  Anti‑alignment Swirl
  Nudge against neighbors' mean heading to create swirling patterns
  @returns {Vector}
*/
const r = config.perceptionRadius;
let v = new Vector(0, 0), n = 0;
for (const o of neighbors) {
  const d = Vector.dist(boid.pos, o.pos);
  if (d > 0 && d < r) { v.add(o.vel); n++; }
}
if (!n) return new Vector();
v.div(n).normalize().mult(boid.maxSpeed);
const anti = v.mult(-1);
return Vector.sub(anti, boid.vel).limit(boid.maxForce * 0.6);` },

          { id: 'local-drag', name: 'Local Drag', code: `/**
  Local Drag
  Denser regions impose stronger drag (viscous slowdown)
  @returns {Vector}
*/
let density = 0;
const r = config.perceptionRadius;
for (const o of neighbors) {
  const d = Vector.dist(boid.pos, o.pos);
  if (d > 0 && d < r) density++;
}
const drag = Math.min(0.9, density * 0.01);
const desired = boid.vel.clone().mult(1 - drag);
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.4);` },

          { id: 'mouse-vortex', name: 'Mouse Vortex', code: `/**
  Mouse Vortex
  Spin around the mouse while pressed (tangential flow)
  @returns {Vector}
*/
if (!mouse.down) return new Vector();
const mp = new Vector(mouse.pos.x, mouse.pos.y);
const toM = Vector.sub(mp, boid.pos);
const d = toM.mag(); if (d < 20) return new Vector();
const tang = new Vector(-toM.y, toM.x).normalize();
const strength = Math.min(1, 200 / (d + 1));
const desired = tang.mult(boid.maxSpeed * strength);
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'mouse-attract', name: 'Mouse Attract / Repel', code: `/**
  Mouse Attract / Repel
  Attract when mouse is down, gently repel otherwise
  @returns {Vector}
*/
const mp = new Vector(mouse.pos.x, mouse.pos.y);
let dir = mouse.down ? Vector.sub(mp, boid.pos) : Vector.sub(boid.pos, mp);
const d = dir.mag(); if (d === 0) return new Vector();
dir.normalize();
const speed = mouse.down ? boid.maxSpeed : boid.maxSpeed * 0.6;
const desired = dir.mult(speed);
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'edge-soft-wall', name: 'Edge Soft Wall', code: `/**
  Edge Soft Wall
  Apply a soft inward force near boundaries
  @returns {Vector}
*/
const margin = 100;
let steer = new Vector();
if (boid.pos.x < margin) steer.x += (margin - boid.pos.x) / margin;
if (boid.pos.x > gameState.width - margin) steer.x -= (boid.pos.x - (gameState.width - margin)) / margin;
if (boid.pos.y < margin) steer.y += (margin - boid.pos.y) / margin;
if (boid.pos.y > gameState.height - margin) steer.y -= (boid.pos.y - (gameState.height - margin)) / margin;
if (steer.mag() > 0) steer.normalize().mult(boid.maxSpeed * 0.8).sub(boid.vel).limit(boid.maxForce * 0.8);
return steer;` },

          { id: 'ai-hopfield-attractor', name: 'AI — Hopfield Memory Attractor', code: `/**
  Hopfield Memory Attractor (Stylized)
  A few memory patterns (points) act as attractors; boids descend an energy-like field.
  Visuals: Soft glowing wells at memory points; vector toward nearest well.
  @returns {Vector}
*/
const memories = [
  new Vector(gameState.width*0.25, gameState.height*0.25),
  new Vector(gameState.width*0.75, gameState.height*0.3),
  new Vector(gameState.width*0.5, gameState.height*0.7)
];
let best = null, bestE = Infinity;
for (const m of memories) { const d=Vector.dist(boid.pos,m); const E=d*d; if (E<bestE){ bestE=E; best=m; } }
if (!best) return new Vector();
const desired = Vector.sub(best, boid.pos).normalize().mult(boid.maxSpeed*0.85);
if (typeof api!=='undefined'&&api&&api.addDrawable){ api.addDrawable((ctx)=>{
  for (const m of memories){ const g=ctx.createRadialGradient(m.x,m.y,4,m.x,m.y,40); g.addColorStop(0,'hsla(' + (((config.hue+60)%360)) + ',100%,65%,0.28)'); g.addColorStop(1,'hsla(' + (((config.hue+60)%360)) + ',100%,65%,0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(m.x,m.y,40,0,Math.PI*2); ctx.fill(); }
  ctx.beginPath(); ctx.moveTo(boid.pos.x,boid.pos.y); ctx.lineTo(best.x,best.y); ctx.strokeStyle='hsla(' + (boid.hue) + ',100%,70%,0.18)'; ctx.lineWidth=1; ctx.stroke();
}); }
return Vector.sub(desired, boid.vel).limit(boid.maxForce*0.9);` },

          { id: 'ml-tsne-local-structure', name: 'ML — t‑SNE Local Structure', code: `/**
  t‑SNE Local Structure (Inspired)
  Preserve local neighborhoods by attracting very close neighbors and repelling mid‑distance ones.
  Visuals: Curved connection hints to nearest neighbors with fading opacity.
  @returns {Vector}
*/
const R = config.perceptionRadius; const near = R*0.35; const mid = R*0.8;
let F = new Vector();
const pairs = [];
for (const o of neighbors){ const d=Vector.dist(boid.pos,o.pos); if (d>0 && d<R){ pairs.push({o,d}); } }
pairs.sort((a,b)=>a.d-b.d);
const k = Math.min(6, pairs.length);
for (let i=0;i<k;i++){
  const {o,d} = pairs[i];
  if (d<near){ // attract strongly
    F.add(Vector.sub(o.pos, boid.pos).normalize().mult(1.0*(near-d)/near));
  } else if (d<mid){ // repel softly
    F.add(Vector.sub(boid.pos, o.pos).normalize().mult(0.5*(mid-d)/mid));
  }
}
const desired = F.normalize().mult(boid.maxSpeed*0.85);
if (typeof api!=='undefined'&&api&&api.addDrawable){ const x=boid.pos.x,y=boid.pos.y; const top=pairs.slice(0,4); api.addDrawable((ctx)=>{
  for (const {o,d} of top){ ctx.beginPath(); ctx.moveTo(x,y); const mx=(x+o.pos.x)/2, my=(y+o.pos.y)/2; ctx.quadraticCurveTo(mx+(Math.random()-0.5)*8, my+(Math.random()-0.5)*8, o.pos.x, o.pos.y); ctx.strokeStyle='hsla(' + (((config.hue+100)%360)) + ',100%,70%,' + (0.28*(1-Math.min(1,d/R))).toFixed(3) + ')'; ctx.lineWidth=1; ctx.stroke(); }
}); }
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'cs-cellular-automaton-field', name: 'CS — Cellular Automaton Field', code: `/**
  Cellular Automaton Field (Conway‑like Influence)
  A coarse grid evolves; alive cells attract, dead repel slightly.
  Visuals: Grid cells with alive state highlighted beneath boids.
  @returns {Vector}
*/
const cell=24; const cols=Math.ceil(gameState.width/cell), rows=Math.ceil(gameState.height/cell);
if (!gameState._ca){ gameState._ca=new Uint8Array(cols*rows); for(let i=0;i<cols*rows;i++){ gameState._ca[i]=Math.random()<0.15?1:0; } gameState._caNext=new Uint8Array(cols*rows); gameState._caT=0; }
// Step CA occasionally
if ((performance.now()-gameState._caT)>600){ const N=(i,j)=>{ let s=0; for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++){ if(dx||dy){ const x=(i+dx+cols)%cols,y=(j+dy+rows)%rows; s+=gameState._ca[y*cols+x]; } } return s; }; for(let j=0;j<rows;j++){ for(let i=0;i<cols;i++){ const n=N(i,j), idx=j*cols+i; const a=gameState._ca[idx]; gameState._caNext[idx]= (a? (n===2||n===3): (n===3)) ? 1:0; } } gameState._ca.set(gameState._caNext); gameState._caT=performance.now(); }
const ci=Math.floor(boid.pos.x/cell), rj=Math.floor(boid.pos.y/cell); const alive=gameState._ca[(rj%rows)*cols+(ci%cols)]===1;
const dir = alive ? Vector.sub(new Vector(ci*cell+cell/2, rj*cell+cell/2), boid.pos).normalize() : Vector.sub(boid.pos, new Vector(ci*cell+cell/2, rj*cell+cell/2)).normalize();
const desired=dir.mult(boid.maxSpeed*0.6);
if (typeof api!=='undefined'&&api&&api.addDrawable){ api.addDrawable((ctx)=>{ ctx.fillStyle='hsla(' + (((config.hue+260)%360)) + ',100%,60%,0.06)'; for(let j=0;j<rows;j++){ for(let i=0;i<cols;i++){ if (gameState._ca[j*cols+i]) ctx.fillRect(i*cell,j*cell,cell,cell); } } }); }
return Vector.sub(desired, boid.vel).limit(boid.maxForce*0.7);` },

          { id: 'ai-gan-discriminator-edge', name: 'AI — GAN Discriminator Edge', code: `/**
  GAN Discriminator Edge (Stylized)
  Two modes ("real" and "fake"); steer toward real mode and away from fake potential.
  Visuals: Ring contours for both modes; edge lines show gradient direction.
  @returns {Vector}
*/
const real=new Vector(gameState.width*0.3, gameState.height*0.6);
const fake=new Vector(gameState.width*0.7, gameState.height*0.4);
function grad(c, s, toward=true){ const d=Vector.sub(c, boid.pos); const r2=Math.max(1,d.x*d.x+d.y*d.y); const g=d.mult( Math.exp(-r2/(2*s*s)) / (s*s) ); return toward? g : g.mult(-1); }
let g = grad(real, 110, true).add(grad(fake, 130, false));
const desired=g.normalize().mult(boid.maxSpeed*0.8);
if (typeof api!=='undefined'&&api&&api.addDrawable){ api.addDrawable((ctx)=>{ const centers=[[real,110,'+40'],[fake,130,'+300']]; for(const [c,s,shift] of centers){ for(let i=1;i<=3;i++){ ctx.beginPath(); ctx.arc(c.x,c.y,(s/3)*i,0,Math.PI*2); ctx.strokeStyle='hsla(' + (((config.hue+Number(shift))%360)) + ',100%,70%,' + (0.14 - i*0.03) + ')'; ctx.lineWidth=1; ctx.stroke(); } } }); }
return Vector.sub(desired, boid.vel).limit(boid.maxForce*0.8);` },

          { id: 'ml-rbf-svm-field', name: 'ML — RBF SVM Field', code: `/**
  RBF SVM Field (Toy)
  Two class centers define an RBF potential; steer along sign of decision function.
  Visuals: Concentric potential contours; direction arrow.
  @returns {Vector}
*/
const A=new Vector(gameState.width*0.3, gameState.height*0.3), B=new Vector(gameState.width*0.7, gameState.height*0.7);
const gamma=1/(140*140);
function phi(c){ const dx=boid.pos.x-c.x, dy=boid.pos.y-c.y; return Math.exp(-(dx*dx+dy*dy)*gamma); }
const f = phi(A) - phi(B);
const grad = new Vector((B.x-A.x)*gamma*f, (B.y-A.y)*gamma*f).normalize();
const desired = grad.mult(boid.maxSpeed*0.8);
if (typeof api!=='undefined'&&api&&api.addDrawable){ api.addDrawable((ctx)=>{ for(const c of [A,B]){ for(let i=1;i<=3;i++){ ctx.beginPath(); ctx.arc(c.x,c.y,i*40,0,Math.PI*2); ctx.strokeStyle='hsla(' + (((config.hue+180)%360)) + ',100%,70%,' + (0.12 - i*0.02) + ')'; ctx.lineWidth=1; ctx.stroke(); } } }); }
return Vector.sub(desired, boid.vel).limit(boid.maxForce*0.8);` },

          { id: 'cs-nearest-triangulation', name: 'CS — Nearest‑Triangulation Glide', code: `/**
  Nearest‑Triangulation Glide
  Build a local triangle from nearest two neighbors; glide toward triangle centroid.
  Visuals: Wireframe triangle to the nearest two neighbors.
  @returns {Vector}
*/
const arr = [];
for (const o of neighbors) {
  const d = Vector.dist(boid.pos, o.pos);
  if (d > 0) arr.push({ o, d });
}
arr.sort((a, b) => a.d - b.d);
if (arr.length < 2) return new Vector();

const a = arr[0].o.pos, b = arr[1].o.pos;
const c = boid.pos;
const centroid = new Vector((a.x + b.x + c.x) / 3, (a.y + b.y + c.y) / 3);
const desired = Vector.sub(centroid, c).normalize().mult(boid.maxSpeed * 0.8);
if (typeof api !== 'undefined' && api && api.addDrawable) {
  api.addDrawable((ctx) => {
    ctx.beginPath();
    ctx.moveTo(c.x, c.y);
    ctx.lineTo(a.x, a.y);
    ctx.lineTo(b.x, b.y);
    ctx.closePath();
    ctx.strokeStyle = 'hsla(' + (((config.hue + 220) % 360)) + ',100%,70%,0.18)';
    ctx.lineWidth = 1;
    ctx.stroke();
  });
}
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.8);` },

          { id: 'ai-ant-colony-intensify', name: 'AI — Ant Colony Intensify', code: `/**
  Ant Colony Intensify
  Follow pheromone gradient; deposit more when moving faster (positive feedback).
  Visuals: Glowing trails; bright vectors on steep gradients.
  @returns {Vector}
*/
const s = 6;
const pR = (x, y) => {
  const col = Math.floor(Math.max(0, Math.min(pheromones.cols - 1, x / pheromones.cell)));
  const row = Math.floor(Math.max(0, Math.min(pheromones.rows - 1, y / pheromones.cell)));
  return pheromones.grid[row * pheromones.cols + col] || 0;
};
const L = pR(boid.pos.x - s, boid.pos.y);
const Rv = pR(boid.pos.x + s, boid.pos.y);
const U = pR(boid.pos.x, boid.pos.y - s);
const D = pR(boid.pos.x, boid.pos.y + s);
const grad = new Vector(Rv - L, D - U);
let desired = grad.mag() > 1e-6
  ? grad.normalize().mult(boid.maxSpeed)
  : Vector.random2D().mult(boid.maxSpeed * 0.4);
if (typeof api !== 'undefined' && api && api.depositTrail) {
  const amt = Math.min(2.0, 0.6 + boid.vel.mag() * 0.2);
  api.depositTrail(boid.pos.x, boid.pos.y, amt);
}
if (typeof api !== 'undefined' && api && api.addDrawable) {
  const x = boid.pos.x, y = boid.pos.y;
  api.addDrawable((ctx) => {
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + desired.x * 12, y + desired.y * 12);
    ctx.strokeStyle = 'hsla(' + (((config.hue + 20) % 360)) + ',100%,70%,0.28)';
    ctx.lineWidth = 1.5;
    ctx.stroke();
  });
}
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'ml-belief-propagation', name: 'ML — Belief Propagation (Two Anchors)', code: `/**
  Belief Propagation (Two Anchors)
  Messages from two anchors combine into a belief gradient; steer accordingly.
  Visuals: Arrows from anchors with opacity indicating influence.
  @returns {Vector}
*/
const a1=new Vector(gameState.width*0.2, gameState.height*0.8);
const a2=new Vector(gameState.width*0.8, gameState.height*0.2);
function msg(c,s){ const d=Vector.sub(c,boid.pos); const r=Math.max(1,d.mag()); const w=Math.exp(-r*r/(2*s*s)); return d.normalize().mult(w); }
const m1=msg(a1,160), m2=msg(a2,140);
const belief=m1.add(m2).normalize();
const desired=belief.mult(boid.maxSpeed*0.85);
if (typeof api!=='undefined'&&api&&api.addDrawable){ api.addDrawable((ctx)=>{ const arr=[[a1,m1.mag()],[a2,m2.mag()]]; for(const [c,w] of arr){ ctx.beginPath(); ctx.moveTo(c.x,c.y); const v=Vector.sub(boid.pos,c).normalize(); ctx.lineTo(c.x+v.x*24, c.y+v.y*24); ctx.strokeStyle='hsla(' + (((config.hue+80)%360)) + ',100%,70%,' + (0.1+0.3*w) + ')'; ctx.lineWidth=2; ctx.stroke(); } }); }
return Vector.sub(desired, boid.vel).limit(boid.maxForce*0.9);` },

          { id: 'cs-consistent-hash-ring', name: 'CS — Consistent Hash Ring', code: `/**
  Consistent Hash Ring
  Partition the plane into ring sectors; boids steer along their sector arc.
  Visuals: A large ring with sector boundaries; arc indicator near the boid.
  @returns {Vector}
*/
const center=new Vector(gameState.width/2, gameState.height/2);
const ringR=Math.min(gameState.width,gameState.height)*0.35;
const sectors=8; const angle=Math.atan2(boid.pos.y-center.y, boid.pos.x-center.x);
const sector=Math.floor(((angle+Math.PI)/(2*Math.PI))*sectors)%sectors;
const tang=new Vector(-(boid.pos.y-center.y), boid.pos.x-center.x).normalize();
const desired=tang.mult(boid.maxSpeed*0.9);
if (typeof api!=='undefined'&&api&&api.addDrawable){ api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.arc(center.x,center.y,ringR,0,Math.PI*2); ctx.strokeStyle='hsla(' + (((config.hue+40)%360)) + ',100%,70%,0.18)'; ctx.lineWidth=1; ctx.stroke(); for(let i=0;i<sectors;i++){ const a=i*(2*Math.PI/sectors)-Math.PI; ctx.beginPath(); ctx.moveTo(center.x,center.y); ctx.lineTo(center.x+Math.cos(a)*ringR, center.y+Math.sin(a)*ringR); ctx.strokeStyle='hsla(' + (((config.hue+40)%360)) + ',100%,70%,0.08)'; ctx.stroke(); } }); }
return Vector.sub(desired, boid.vel).limit(boid.maxForce*0.9);` },

          { id: 'ai-rrt-explorer', name: 'AI — RRT Explorer', code: `/**
  RRT Explorer (Stylized)
  Sample a waypoint randomly; steer toward it; occasionally resample — resembling a rapidly-exploring random tree.
  Visuals: Waypoint star and faint segment from last sample.
  @returns {Vector}
*/
if (!boid._wp || Math.random()<0.02){ boid._prevWp=boid._wp || null; boid._wp=new Vector(Math.random()*gameState.width, Math.random()*gameState.height); }
const target=boid._wp; const desired=Vector.sub(target,boid.pos).normalize().mult(boid.maxSpeed*0.9);
if (typeof api!=='undefined'&&api&&api.addDrawable){ api.addDrawable((ctx)=>{ if (boid._prevWp){ ctx.beginPath(); ctx.moveTo(boid._prevWp.x,boid._prevWp.y); ctx.lineTo(target.x,target.y); ctx.strokeStyle='hsla(' + (((config.hue+300)%360)) + ',100%,70%,0.12)'; ctx.stroke(); } ctx.save(); ctx.translate(target.x,target.y); ctx.rotate(Math.PI/4); ctx.beginPath(); ctx.moveTo(-4,0); ctx.lineTo(0,-4); ctx.lineTo(4,0); ctx.lineTo(0,4); ctx.closePath(); ctx.strokeStyle='hsla(' + (((config.hue+300)%360)) + ',100%,70%,0.22)'; ctx.stroke(); ctx.restore(); }); }
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },
          { id: 'orbital-centroid', name: 'Orbit Centroid', code: `/**
  Orbit Centroid
  Circle around neighbors' centroid (tangential flow)
  @returns {Vector}
*/
const r = config.perceptionRadius;
let c = new Vector(), n = 0;
for (const o of neighbors) {
  const d = Vector.dist(boid.pos, o.pos);
  if (d > 0 && d < r) { c.add(o.pos); n++; }
}
if (!n) return new Vector();
c.div(n);
const toC = Vector.sub(c, boid.pos);
if (toC.mag() === 0) return new Vector();
const tang = new Vector(-toC.y, toC.x).normalize();
const desired = tang.mult(boid.maxSpeed * 0.9);
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.9);` },

          { id: 'novel-triadic-resonance', name: 'Novel — Triadic Resonance Flocking', code: `/**
  Triadic Resonance Flocking (Novel)

  Mechanically: blends Separation, Alignment, and Cohesion with a time‑varying
  “resonance” target derived from the triangle (boid + two nearest neighbors).
  The oscillating target injects structured unpredictability that ripples through
  the flock — producing braids, lattice waves, and sudden re‑groupings.

  Visuals: crisp triangulation links and partial circum‑arcs (no glow). Lines
  are hue‑tinted with subtle alpha so structures emerge at the flock level.

  Forces
  - Separation: inverse‑square repulsion from very close neighbors.
  - Alignment: toward the local average velocity.
  - Cohesion: toward the dynamic resonance point (mix of centroid + triangle center).

  Notes
  - Uses a per‑boid phase (persistent) to make local oscillations de‑synchronize.
  - Scales drawable density by config.visualDensity; avoids heavy per‑frame work.
  - Avoids glow/shadow effects as requested.

  @returns {Vector} steering
*/
(function(){
  const R = config.perceptionRadius;
  // Ensure a stable per‑boid phase and rate
  if (typeof boid._phase !== 'number') boid._phase = Math.random() * Math.PI * 2;
  if (typeof boid._rate !== 'number')  boid._rate  = 0.6 + Math.random() * 0.6; // rad/s
  const t = performance.now() * 0.001; // seconds
  const phase = boid._phase + t * boid._rate;
  const osc = 0.5 + 0.5 * Math.sin(phase);      // 0..1
  const osc2 = 0.5 + 0.5 * Math.sin(phase * 1.7 + 1.3);

  // Gather neighbors within R and find two nearest
  const pool = [];
  let vAvg = new Vector(); let vN = 0;
  for (const o of neighbors) {
    const d = Vector.dist(boid.pos, o.pos);
    if (d > 0 && d < R) {
      pool.push({ o, d });
      vAvg.add(o.vel); vN++;
    }
  }
  pool.sort((a,b)=>a.d-b.d);
  const n1 = pool[0]?.o || null;
  const n2 = pool[1]?.o || null;
  if (vN) vAvg.div(vN);

  // Separation: strong close‑range inverse‑square
  let sep = new Vector();
  for (const p of pool) {
    if (p.d < Math.max(8, config.boidSize * 2.2)) {
      const away = Vector.sub(boid.pos, p.o.pos);
      const m = away.mag(); if (m > 0) sep.add(away.div(m*m));
    }
  }

  // Cohesion target: blend of centroid and triangle “resonant” center
  // Centroid of local neighbors
  let c = new Vector(); let cN = 0; for (const p of pool){ c.add(p.o.pos); cN++; }
  if (cN) c.div(cN); else c = boid.pos.clone();
  // Triangle center: if two nearest exist, use circumcenter approximation; else fallback to centroid
  let triCenter = c.clone();
  if (n1 && n2) {
    const A = boid.pos, B = n1.pos, C = n2.pos;
    const ax=A.x, ay=A.y, bx=B.x, by=B.y, cx=C.x, cy=C.y;
    const d = 2 * (ax*(by-cy) + bx*(cy-ay) + cx*(ay-by));
    if (Math.abs(d) > 1e-3) {
      const ax2ay2 = ax*ax + ay*ay, bx2by2 = bx*bx + by*by, cx2cy2 = cx*cx + cy*cy;
      const ux = (ax2ay2*(by-cy) + bx2by2*(cy-ay) + cx2cy2*(ay-by)) / d;
      const uy = (ax2ay2*(cx-bx) + bx2by2*(ax-cx) + cx2cy2*(bx-ax)) / d;
      triCenter = new Vector(ux, uy);
    }
  }
  // Resonance point mixes centroid and triangle center with an oscillating bias
  const resonance = c.clone().mult(1 - osc).add(triCenter.clone().mult(osc));

  // Tangential swirl around resonance (adds unpredictability but stays coherent)
  const toRes = Vector.sub(resonance, boid.pos);
  const tang = new Vector(-toRes.y, toRes.x);
  const swirl = (toRes.mag() > 0 ? tang.normalize().mult(boid.maxSpeed * (0.25 + 0.35*osc2)) : new Vector());

  // Desired velocity from cohesion toward resonance + tangential swirl
  const cohDir = (toRes.mag() > 0 ? toRes.clone().normalize() : new Vector());
  const desired = cohDir.mult(boid.maxSpeed * (0.35 + 0.35*osc)).add(swirl);

  // Alignment: nudge toward local average velocity
  const align = (vN ? vAvg.clone().normalize().mult(boid.maxSpeed) : new Vector());

  // Combine forces (weights tuned for balance; separation stronger up close)
  let force = new Vector();
  force.add(Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.9)); // cohesion+swirl
  force.add(Vector.sub(align, boid.vel).limit(boid.maxForce * 0.4));   // alignment
  if (sep.mag() > 0) force.add(sep.normalize().mult(boid.maxForce * 1.4)); // separation

  // Optional trails (subtle, density‑aware)
  if (typeof api !== 'undefined' && api && api.depositTrail) {
    const amt = 0.4 + 0.4 * (osc2);
    api.depositTrail(boid.pos.x, boid.pos.y, amt);
  }

  // Visuals: draw edges to n1/n2 and a partial arc approximating the circumcircle (if stable)
  if (typeof api !== 'undefined' && api && api.addDrawable) {
    // Thin out by visualDensity and local neighbor count
    const density = Math.max(0, Math.min(2, typeof config.visualDensity === 'number' ? config.visualDensity : 1));
    const chance = 0.25 * density; if (Math.random() < chance) {
      const x = boid.pos.x, y = boid.pos.y;
      const hueBase = (boid.hue + 20) % 360;
      api.addDrawable(function(ctx){
        // Triangulation lines
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'hsla(' + (hueBase) + ',100%,65%,0.25)';
        if (n1) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(n1.pos.x, n1.pos.y); ctx.stroke(); }
        if (n2) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(n2.pos.x, n2.pos.y); ctx.stroke(); }
        if (n1 && n2) {
          // Partial arc around resonance center with radius to boid
          const vx = x - resonance.x, vy = y - resonance.y;
          const rad = Math.hypot(vx, vy);
          if (rad > 2 && Number.isFinite(rad)) {
            const a0 = Math.atan2(n1.pos.y - resonance.y, n1.pos.x - resonance.x);
            const a1 = Math.atan2(n2.pos.y - resonance.y, n2.pos.x - resonance.x);
            // Ensure minor arc direction
            let da = a1 - a0; while (da > Math.PI) da -= 2*Math.PI; while (da < -Math.PI) da += 2*Math.PI;
            const mid = a0 + da * 0.5;
            const span = Math.abs(da) * (0.4 + 0.3*osc); // shorter than chord angle
            ctx.setLineDash([4,3]);
            ctx.beginPath();
            ctx.arc(resonance.x, resonance.y, rad, mid - span/2, mid + span/2);
            ctx.strokeStyle = 'hsla(' + ((hueBase+40)%360) + ',100%,65%,0.22)';
            ctx.stroke();
            ctx.setLineDash([]);
          }
        }
      });
    }
  }

  return force.limit(boid.maxForce * 1.8);
})();` },

          { id: 'jitter', name: 'Subtle Jitter', code: `/**
  Subtle Jitter
  Add gentle noise for shimmering, organic motion
  @returns {Vector}
*/
const jitter = Vector.random2D().mult(0.2);
const desired = boid.vel.clone().add(jitter).normalize().mult(boid.maxSpeed);
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.3);` },

          { id: 'polarize-hues', name: 'Contrast Neighbor Color', code: `/**
  Contrast Neighbor Color
  Drift hue toward complement of neighbors' average hue
  @returns {Vector}
*/
let h = 0, n = 0;
for (const o of neighbors) { h += o.hue; n++; }
if (n > 0) {
  const avg = (h / n) % 360;
  const contrast = (avg + 180) % 360;
  const step = 0.5; // deg/frame
  let delta = (contrast - boid.hue + 540) % 360 - 180;
  boid.hue = (boid.hue + Math.sign(delta) * Math.min(Math.abs(delta), step) + 360) % 360;
}
return new Vector();` },

          { id: 'nearest-three', name: 'Nearest Three Cohesion', code: `/**
  Nearest Three Cohesion
  Use the three nearest neighbors to compute centroid
  @returns {Vector}
*/
const r = config.perceptionRadius;
const arr = [];
for (const o of neighbors) {
  const d = Vector.dist(boid.pos, o.pos);
  if (d > 0 && d < r) arr.push({ o, d });
}
arr.sort((a, b) => a.d - b.d);
const take = arr.slice(0, 3);
if (!take.length) return new Vector();
let c = new Vector();
for (const t of take) c.add(t.o.pos);
c.div(take.length);
const desired = Vector.sub(c, boid.pos).normalize().mult(boid.maxSpeed);
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'density-separation', name: 'Density Separation', code: `/**
  Density Separation
  Activate strong separation only when very crowded
  @returns {Vector}
*/
let close = 0;
for (const o of neighbors) if (Vector.dist(boid.pos, o.pos) < config.boidSize * 2.2) close++;
if (close < 3) return new Vector();
let steer = new Vector();
for (const o of neighbors) {
  const d = Vector.dist(boid.pos, o.pos);
  if (d > 0 && d < config.boidSize * 2.2) steer.add(Vector.sub(boid.pos, o.pos).normalize().div(d));
}
steer.normalize().mult(boid.maxSpeed).sub(boid.vel).limit(boid.maxForce * 1.6);
return steer;` },

          { id: 'pair-alignment', name: 'Pair Alignment', code: `/**
  Pair Alignment
  Align primarily with the single nearest neighbor
  @returns {Vector}
*/
let minD = Infinity, t = null;
for (const o of neighbors) {
  const d = Vector.dist(boid.pos, o.pos);
  if (d > 0 && d < minD) { minD = d; t = o; }
}
if (!t) return new Vector();
const desired = t.vel.clone().normalize().mult(boid.maxSpeed);
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.8);` },

          { id: 'center-spiral', name: 'Spiral to Center', code: `/**
  Spiral to Center
  Create slow spirals toward the canvas center
  @returns {Vector}
*/
const center = new Vector(gameState.width / 2, gameState.height / 2);
const toC = Vector.sub(center, boid.pos);
if (toC.mag() === 0) return new Vector();
const tang = new Vector(-toC.y, toC.x).normalize();
const desired = tang.mult(boid.maxSpeed * 0.6).add(toC.clone().normalize().mult(boid.maxSpeed * 0.2));
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'random-walk', name: 'Random Walk Bias', code: `/**
  Random Walk Bias
  Add a slowly changing random heading for variety
  @returns {Vector}
*/
if (!boid._randDir || Math.random() < 0.01) boid._randDir = Vector.random2D();
const desired = boid._randDir.clone().mult(boid.maxSpeed * 0.7);
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.6);` },

          { id: 'mouse-spiral-in', name: 'Mouse Spiral In', code: `/**
  Mouse Spiral In
  Spiral inward toward the mouse while pressed
  @returns {Vector}
*/
if (!mouse.down) return new Vector();
const mp = new Vector(mouse.pos.x, mouse.pos.y);
const toM = Vector.sub(mp, boid.pos);
const tang = new Vector(-toM.y, toM.x).normalize();
const desired = tang.mult(boid.maxSpeed * 0.6).add(toM.clone().normalize().mult(boid.maxSpeed * 0.4));
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'split-flock', name: 'Split Flock by Hue', code: `/**
  Split Flock by Hue
  Flock with similar hue; repel dissimilar neighbors
  @returns {Vector}
*/
let like = new Vector(), unlike = new Vector();
let ln = 0, un = 0;
for (const o of neighbors) {
  const diff = Math.abs(((boid.hue - o.hue + 540) % 360) - 180);
  if (diff < 40) { like.add(o.pos); ln++; } else { unlike.add(Vector.sub(boid.pos, o.pos).normalize()); un++; }
}
let steer = new Vector();
if (ln) { like.div(ln); steer.add(Vector.sub(like, boid.pos).normalize()); }
if (un) { steer.add(unlike.div(un)); }
if (steer.mag() > 0) steer.normalize().mult(boid.maxSpeed).sub(boid.vel).limit(boid.maxForce);
return steer;` },

          { id: 'velocity-match-mouse', name: 'Velocity Match (Mouse)', code: `/**
  Velocity Match (Mouse)
  Align with a rotating tangential vector around the mouse
  @returns {Vector}
*/
const mp = new Vector(mouse.pos.x, mouse.pos.y);
const toM = Vector.sub(boid.pos, mp);
const tang = new Vector(-toM.y, toM.x).normalize();
const desired = tang.mult(boid.maxSpeed * 0.7);
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.8);` },

          { id: 'breathing-speed', name: 'Breathing Speed', code: `/**
  Breathing Speed
  Smoothly oscillate target speed over time
  @returns {Vector}
*/
const t = (performance.now() % 4000) / 4000 * 2 * Math.PI;
const sp = 0.5 + 0.5 * Math.sin(t);
const desired = boid.vel.clone().normalize().mult(boid.maxSpeed * (0.5 + 0.5 * sp));
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.5);` },

          { id: 'size-pressure', name: 'Size by Pressure', code: `/**
  Size by Pressure
  Adjust size based on local density (pressure)
  @returns {Vector}
*/
let density = 0;
for (const o of neighbors) if (Vector.dist(boid.pos, o.pos) < config.perceptionRadius * 0.5) density++;
const target = 6 + Math.min(10, density * 0.5);
boid.size += Math.sign(target - boid.size) * 0.2;
return new Vector();` },

          { id: 'seek-voids', name: 'Seek Voids', code: `/**
  Seek Voids
  Move toward least crowded angular sector around the boid
  @returns {Vector}
*/
const sectors = 8;
const counts = new Array(sectors).fill(0);
for (const o of neighbors) {
  const ang = Math.atan2(o.pos.y - boid.pos.y, o.pos.x - boid.pos.x);
  const i = (Math.floor((ang + Math.PI) / (2 * Math.PI) * sectors)) % sectors;
  counts[i]++;
}
let minI = 0; for (let i = 1; i < sectors; i++) if (counts[i] < counts[minI]) minI = i;
const ang = (minI / sectors) * 2 * Math.PI - Math.PI;
const dir = new Vector(Math.cos(ang), Math.sin(ang));
const desired = dir.mult(boid.maxSpeed);
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'pairwise-tether', name: 'Pairwise Tether', code: `/**
  Pairwise Tether
  Spring-like attraction to nearest neighbor with rest length
  @returns {Vector}
*/
let minD = Infinity, t = null;
for (const o of neighbors) {
  const d = Vector.dist(boid.pos, o.pos);
  if (d > 0 && d < minD) { minD = d; t = o; }
}
if (!t) return new Vector();
const rest = config.perceptionRadius * 0.4;
const dir = Vector.sub(t.pos, boid.pos);
const d = dir.mag(); if (d === 0) return new Vector();
const k = 0.02; const f = (d - rest) * k;
const desired = dir.normalize().mult(Math.max(-boid.maxSpeed, Math.min(boid.maxSpeed, f * boid.maxSpeed)));
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'orbit-mouse', name: 'Orbit Mouse', code: `/**
  Orbit Mouse
  Orbit the mouse at a gentle distance, balancing tangential and radial components
  @returns {Vector}
*/
const mp = new Vector(mouse.pos.x, mouse.pos.y);
const toM = Vector.sub(mp, boid.pos);
const d = toM.mag(); if (d === 0) return new Vector();
const targetDist = 120;
const tang = new Vector(-toM.y, toM.x).normalize();
const radial = (d - targetDist) / targetDist;
const desired = tang.mult(boid.maxSpeed * 0.7).add(toM.normalize().mult(boid.maxSpeed * 0.3 * (-radial)));
// Visual: draw faint orbit ring around the mouse occasionally
if (typeof api !== 'undefined' && api && api.addDrawable && Math.random() < 0.08) {
  const cx = mp.x, cy = mp.y, R = targetDist;
  api.addDrawable((ctx) => {
    ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI * 2);
    ctx.strokeStyle = 'hsla(' + (((config.hue + 40) % 360)) + ', 100%, 60%, 0.12)';
    ctx.lineWidth = 1; ctx.stroke();
  });
}
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          // ——— Nature-Inspired (10) ———
          { id: 'nature-ants-trail', name: 'Nature — Ants Trail Following', code: `/**
  Ants Trail Following
  Favor neighbors ahead within a forward cone to emulate pheromone trails.
  Steps:
    1) Compute forward unit vector f from boid velocity.
    2) For neighbors within angle cone (~60°), average their velocities.
    3) Steer to match that average (like following a trail laid ahead).
    4) Deposit a trail at the current position for others to follow.
  @returns {Vector}
*/
const f = boid.vel.clone().normalize();
const cosTheta = Math.cos(Math.PI / 3); // 60° cone
let sum = new Vector(); let n = 0;
for (const o of neighbors) {
  const dir = Vector.sub(o.pos, boid.pos).normalize();
  const ahead = (f.x * dir.x + f.y * dir.y) > cosTheta;
  if (ahead) { sum.add(o.vel); n++; }
}
if (!n) return new Vector();
const desired = sum.div(n).normalize().mult(boid.maxSpeed);
// Leave a pheromone trail mark (amount scales with speed)
if (typeof api !== 'undefined' && api && api.depositTrail) {
  api.depositTrail(boid.pos.x, boid.pos.y, Math.min(1.5, 0.2 + boid.vel.mag() * 0.1));
}
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'nature-predator-shadow', name: 'Nature — Predator Shadowing', code: `/**
  Predator Shadowing
  Treat the fastest neighbor as a potential predator and slip laterally out of its line of approach.
  Idea: move perpendicular to predator->boid vector (evasion without stopping).
  @returns {Vector}
*/
let pred = null; let maxSp = -1;
for (const o of neighbors) { const sp = o.vel.mag(); if (sp > maxSp) { maxSp = sp; pred = o; } }
if (!pred) return new Vector();
const toMe = Vector.sub(boid.pos, pred.pos); if (toMe.mag() === 0) return new Vector();
const lateral = new Vector(-toMe.y, toMe.x).normalize();
const desired = lateral.mult(boid.maxSpeed);
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.9);` },

          { id: 'nature-butterfly-chase', name: 'Nature — Butterfly Mate Chase', code: `/**
  Butterfly Mate Chase
  Chase nearest similar-hue neighbor with a gentle sinusoidal lateral weave.
  @returns {Vector}
*/
let tgt = null; let minD = Infinity;
for (const o of neighbors) {
  const hueDiff = Math.abs(((boid.hue - o.hue + 540) % 360) - 180);
  const d = Vector.dist(boid.pos, o.pos);
  if (hueDiff < 35 && d < minD) { minD = d; tgt = o; }
}
if (!tgt) return new Vector();
const dir = Vector.sub(tgt.pos, boid.pos);
const base = dir.clone().normalize();
const t = performance.now() * 0.003;
const weave = new Vector(-base.y, base.x).mult(0.4 * Math.sin(t));
const desired = base.add(weave).normalize().mult(boid.maxSpeed * 0.9);
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'nature-river-current', name: 'Nature — River Current Drift', code: `/**
  River Current Drift
  Add a position-dependent current (fast midstream, slow near banks) to mimic rivers.
  Field: v_c = (a * sin(π y / H), 0), peaking at screen center.
  @returns {Vector}
*/
const a = 0.6 * boid.maxSpeed;
const H = gameState.height || 1;
const current = new Vector(a * Math.sin(Math.PI * boid.pos.y / H), 0);
const desired = boid.vel.clone().add(current).normalize().mult(boid.maxSpeed);
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.5);` },

          { id: 'nature-thermal-soar', name: 'Nature — Thermal Soaring', code: `/**
  Thermal Soaring
  Birds circle and climb in periodic updraft cells; emulate tangential drift around thermal centers.
  @returns {Vector}
*/
const scale = 220;
const cx = Math.round(boid.pos.x / scale) * scale + scale * 0.5;
const cy = Math.round(boid.pos.y / scale) * scale + scale * 0.5;
const toC = new Vector(cx - boid.pos.x, cy - boid.pos.y);
if (toC.mag() === 0) return new Vector();
const tang = new Vector(-toC.y, toC.x).normalize();
const radial = toC.clone().normalize().mult(0.3);
const desired = tang.mult(boid.maxSpeed * 0.8).add(radial.mult(boid.maxSpeed * 0.2));
// Visual: mark thermal center with a soft dot
if (typeof api !== 'undefined' && api && api.addDrawable && Math.random() < 0.08) {
  const x = cx, y = cy;
  api.addDrawable((ctx) => { ctx.beginPath(); ctx.arc(x, y, 5, 0, Math.PI * 2); ctx.fillStyle = 'hsla(' + (config.hue) + ', 100%, 70%, 0.18)'; ctx.fill(); });
}
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'nature-wolf-encircle', name: 'Nature — Pack Encircle (Mouse)', code: `/**
  Pack Encircle (Mouse)
  When mouse is down (as prey), take up ring positions and orbit to encircle.
  Angle target derived from hue for variety.
  @returns {Vector}
*/
if (!mouse.down) return new Vector();
const mp = new Vector(mouse.pos.x, mouse.pos.y);
const toM = Vector.sub(mp, boid.pos);
const baseAng = ((boid.hue % 360) / 360) * 2 * Math.PI;
const targetR = 140;
const posOnRing = new Vector(Math.cos(baseAng), Math.sin(baseAng)).mult(targetR);
const targetPt = mp.clone().add(posOnRing);
const desired = Vector.sub(targetPt, boid.pos).normalize().mult(boid.maxSpeed * 0.9);
// Visual: ring and spoke to target (sparse)
if (typeof api !== 'undefined' && api && api.addDrawable && Math.random() < 0.08) {
  const cx = mp.x, cy = mp.y, R = targetR, tx = targetPt.x, ty = targetPt.y;
  api.addDrawable((ctx) => {
    ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI * 2);
    ctx.strokeStyle = 'hsla(' + (((config.hue + 20) % 360)) + ', 100%, 60%, 0.12)'; ctx.lineWidth = 1; ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(tx, ty);
    ctx.strokeStyle = 'hsla(' + (config.hue) + ', 100%, 70%, 0.12)'; ctx.lineWidth = 1; ctx.stroke();
  });
}
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'nature-murmuration-accel', name: 'Nature — Murmuration (Accel Coupling)', code: `/**
  Murmuration (Acceleration Coupling)
  React to neighbors' instantaneous accelerations to transmit waves through the flock.
  @returns {Vector}
*/
let sumA = new Vector(); let nA = 0;
for (const o of neighbors) { if (o !== boid) { sumA.add(o.acc); nA++; } }
if (!nA) return new Vector();
const desired = sumA.div(nA).limit(boid.maxForce * 2);
return desired;` },

          { id: 'nature-salmon-upstream', name: 'Nature — Salmon Upstream', code: `/**
  Salmon Upstream
  Swim against a vertically varying flow (opposing a sinusoidal downstream).
  @returns {Vector}
*/
const flowDown = Math.sin(boid.pos.y / 40) * 0.7 * boid.maxSpeed;
const oppose = new Vector(-flowDown, -0.1 * boid.maxSpeed);
const desired = boid.vel.clone().add(oppose).normalize().mult(boid.maxSpeed);
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.6);` },

          { id: 'nature-edge-perch', name: 'Nature — Edge Perching Tendency', code: `/**
  Edge Perching Tendency
  Mild attraction toward horizontal bands as if preferring perches/thermals at certain altitudes.
  @returns {Vector}
*/
const bands = [0.25, 0.5, 0.75];
let bestY = null; let bestScore = Infinity;
for (const b of bands) {
  const y = b * (gameState.height || 1);
  const dy = Math.abs(y - boid.pos.y); if (dy < bestScore) { bestScore = dy; bestY = y; }
}
if (bestY == null) return new Vector();
const desired = new Vector(0, bestY - boid.pos.y).limit(boid.maxForce * 2);
return desired;` },

          { id: 'nature-herd-leader', name: 'Nature — Herd Leader Bias', code: `/**
  Herd Leader Bias
  Favor following the single nearest neighbor (leader) more than the crowd.
  @returns {Vector}
*/
let leader = null; let dmin = Infinity;
for (const o of neighbors) { const d = Vector.dist(boid.pos, o.pos); if (d > 0 && d < dmin) { dmin = d; leader = o; } }
if (!leader) return new Vector();
const desired = leader.vel.clone().normalize().mult(boid.maxSpeed);
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          // ——— CS / ML / AI-Inspired (10) ———
          { id: 'ai-gradient-descent-density', name: 'AI — Gradient Descent on Density', code: `/**
  Gradient Descent on Density
  Minimize crowding by descending the local density gradient (move toward open space).
  Implementation: sum normalized offsets from neighbors (an estimator of ∇density),
  then step opposite that sum with a small learning rate.
  @returns {Vector}
*/
let g = new Vector();
for (const o of neighbors) { g.add(Vector.sub(boid.pos, o.pos).normalize()); }
if (g.mag() === 0) return new Vector();
const lr = 0.8; // learning rate
const desired = g.normalize().mult(boid.maxSpeed * lr);
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'ai-simulated-annealing', name: 'AI — Simulated Annealing Drift', code: `/**
  Simulated Annealing Drift
  Add exploratory noise that cools over time to escape local minima, then settle.
  @returns {Vector}
*/
const T0 = 1.0, halfLifeMs = 12000; // initial temp and cooling rate
const t = performance.now();
const T = T0 * Math.pow(0.5, t / halfLifeMs);
const rnd = Vector.random2D().mult(boid.maxSpeed * 0.5 * T);
return Vector.sub(rnd, new Vector()).limit(boid.maxForce * 0.6);` },

          { id: 'ai-pid-speed', name: 'AI — PID Speed Controller', code: `/**
  PID Speed Controller
  Keep speed near a target using a simple proportional term (I/D omitted for stability without memory).
  @returns {Vector}
*/
const v = boid.vel.mag();
const target = boid.maxSpeed * 0.75;
const err = target - v;
const kp = 0.6;
const desired = boid.vel.clone().normalize().mult(v + kp * err);
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.6);` },

          { id: 'ai-robust-median-heading', name: 'AI — Robust Median Heading', code: `/**
  Robust Median Heading
  Compute a circular median of neighbor headings (robust to outliers) and align to it.
  @returns {Vector}
*/
const angs = [];
for (const o of neighbors) { if (o !== boid) angs.push(Math.atan2(o.vel.y, o.vel.x)); }
if (!angs.length) return new Vector();
angs.sort((a,b) => a-b);
const med = angs[Math.floor(angs.length/2)];
const dir = new Vector(Math.cos(med), Math.sin(med));
const desired = dir.mult(boid.maxSpeed);
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'ai-reward-shaping', name: 'AI — Reward Shaping (Mouse Attraction)', code: `/**
  Reward Shaping (Mouse Attraction)
  Encourage moving toward the mouse (reward) while avoiding high density (penalty).
  @returns {Vector}
*/
const toMouse = new Vector(mouse.pos.x - boid.pos.x, mouse.pos.y - boid.pos.y);
let density = 0; for (const o of neighbors) if (Vector.dist(boid.pos, o.pos) < config.perceptionRadius * 0.7) density++;
const reward = toMouse.normalize().mult(boid.maxSpeed * 0.6);
const penalty = new Vector(); if (density > 0) penalty.add(boid.vel.clone().mult(-0.2 * Math.min(1, density / 8)));
const desired = reward.add(penalty).normalize().mult(boid.maxSpeed);
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'ai-entropy-seeking', name: 'AI — Entropy-Seeking Heading', code: `/**
  Entropy-Seeking Heading
  Avoid dominant local heading by nudging perpendicular to the majority, increasing directional diversity.
  @returns {Vector}
*/
let v = new Vector(); let n = 0; for (const o of neighbors) { v.add(o.vel); n++; }
if (!n) return new Vector();
const mean = v.div(n);
const perp = new Vector(-mean.y, mean.x).normalize();
const desired = perp.mult(boid.maxSpeed * 0.7);
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.8);` },

          { id: 'ai-hash-goal-explore', name: 'AI — Hash-Cell Exploration', code: `/**
  Hash-Cell Exploration
  Map space to a grid and use a simple hash to pick a persistent pseudo-random heading per cell.
  @returns {Vector}
*/
const cell = 120; const cx = Math.floor(boid.pos.x / cell), cy = Math.floor(boid.pos.y / cell);
let h = (cx * 73856093) ^ (cy * 19349663);
h ^= (h << 13); h ^= (h >> 17); h ^= (h << 5);
const ang = ((h >>> 0) % 6283) / 1000 - Math.PI; // [-π, π)
const dir = new Vector(Math.cos(ang), Math.sin(ang));
const desired = dir.mult(boid.maxSpeed * 0.9);
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.8);` },

          { id: 'ai-laplacian-smoothing', name: 'AI — Laplacian Velocity Smoothing', code: `/**
  Laplacian Velocity Smoothing
  Steer toward the distance-weighted average neighbor velocity (graph Laplacian intuition).
  @returns {Vector}
*/
let sumV = new Vector(); let sumW = 0;
for (const o of neighbors) { const d = Math.max(1, Vector.dist(boid.pos, o.pos)); const w = 1 / (d*d); sumV.add(o.vel.clone().mult(w)); sumW += w; }
if (sumW === 0) return new Vector();
const avg = sumV.div(sumW).normalize().mult(boid.maxSpeed);
return Vector.sub(avg, boid.vel).limit(boid.maxForce);` },

          { id: 'ai-attention-k', name: 'AI — Attention to k Nearest', code: `/**
  Attention to k Nearest
  Focus on the k nearest neighbors with inverse-distance weights (attention-like).
  @returns {Vector}
*/
const k = 5; const arr = neighbors.slice().map(o => ({ o, d: Vector.dist(boid.pos, o.pos) })).filter(x => x.d > 0);
arr.sort((a,b)=>a.d-b.d);
let acc = new Vector(); let wsum = 0; for (let i=0;i<Math.min(k,arr.length);i++){ const w=1/arr[i].d; acc.add(arr[i].o.vel.clone().mult(w)); wsum+=w; }
if (!wsum) return new Vector();
const desired = acc.div(wsum).normalize().mult(boid.maxSpeed);
// Visual: lines to attended neighbors (sparse)
if (typeof api !== 'undefined' && api && api.addDrawable && Math.random() < 0.12) {
  const bx = boid.pos.x, by = boid.pos.y; const take = Math.min(k, arr.length);
  api.addDrawable((ctx) => {
    ctx.strokeStyle = 'hsla(' + (((config.hue + 80) % 360)) + ', 100%, 70%, 0.12)'; ctx.lineWidth = 1;
    for (let i = 0; i < take; i++) { ctx.beginPath(); ctx.moveTo(bx, by); ctx.lineTo(arr[i].o.pos.x, arr[i].o.pos.y); ctx.stroke(); }
  });
}
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'ai-decision-tree', name: 'AI — Decision Tree (Stateful Guard)', code: `/**
  Decision Tree (Stateful Guard)
  If local density > threshold, prioritize separation-like open-space seeking; else use cohesion-like pull.
  @returns {Vector}
*/
let close = 0; for (const o of neighbors) if (Vector.dist(boid.pos, o.pos) < config.perceptionRadius * 0.6) close++;
if (close > 6) {
  // open space
  let g = new Vector(); for (const o of neighbors) g.add(Vector.sub(boid.pos, o.pos).normalize());
  if (g.mag()===0) return new Vector();
  return g.normalize().mult(boid.maxSpeed).sub(boid.vel).limit(boid.maxForce);
} else {
  // cohesion
  let c = new Vector(); let n=0; for (const o of neighbors){ c.add(o.pos); n++; }
  if (!n) return new Vector(); c.div(n);
  return Vector.sub(c.sub(boid.pos).normalize().mult(boid.maxSpeed), boid.vel).limit(boid.maxForce);
}` },

          // ——— Physics / Math-Inspired (10) ———
          { id: 'phys-lennard-jones', name: 'Physics — Lennard-Jones Potential', code: `/**
  Lennard-Jones Potential
  Models short-range repulsion and longer-range attraction: F(r) ~ 24ε[(2(σ/r)^13) - (σ/r)^7].
  Implementation uses a smoothed approximation to avoid singularities.
  @returns {Vector}
*/
const sigma = Math.max(8, config.boidSize);
const epsilon = 0.3;
let F = new Vector();
for (const o of neighbors) {
  const rVec = Vector.sub(o.pos, boid.pos); let r = rVec.mag(); if (r < 1) r = 1;
  const sr = sigma / r; const sr6 = Math.pow(sr,6); const sr12 = sr6*sr6;
  const mag = 24*epsilon*((2*sr12) - sr6) / r; // derivative scaled
  F.add(rVec.normalize().mult(mag));
}
// Visual: local connection mesh (sparse)
if (typeof api !== 'undefined' && api && api.addDrawable && Math.random() < 0.08) {
  api.addDrawable((ctx) => {
    ctx.strokeStyle = 'hsla(' + (((config.hue + 140) % 360)) + ', 100%, 65%, 0.1)'; ctx.lineWidth = 1;
    for (const o of neighbors) { const d = Vector.dist(boid.pos, o.pos); if (d < config.perceptionRadius * 0.6) { ctx.beginPath(); ctx.moveTo(boid.pos.x, boid.pos.y); ctx.lineTo(o.pos.x, o.pos.y); ctx.stroke(); } }
  });
}
return F.limit(boid.maxForce);` },

          { id: 'phys-coulomb-hue', name: 'Physics — Coulomb by Hue', code: `/**
  Coulomb by Hue
  Assign pseudo-charge from hue: similar hues attract, dissimilar repel (cosine in hue circle).
  F ~ k q_i q_j / r^2 along the line.
  @returns {Vector}
*/
let force = new Vector();
for (const o of neighbors) {
  const dh = Math.abs(((boid.hue - o.hue + 540) % 360) - 180);
  const qi = Math.cos((boid.hue/180)*Math.PI), qj = Math.cos((o.hue/180)*Math.PI);
  const q = Math.cos(dh/180*Math.PI) * qi * qj;
  let rVec = Vector.sub(o.pos, boid.pos); let r = rVec.mag(); if (r < 4) r = 4;
  const mag = (q) / (r*r);
  force.add(rVec.normalize().mult(mag));
}
return force.limit(boid.maxForce);` },

          { id: 'phys-harmonic-center', name: 'Physics — Harmonic to Center', code: `/**
  Harmonic to Center
  Spring toward screen center with mild damping: F = -k(x - x_c).
  @returns {Vector}
*/
const cx = (gameState.width||0)/2, cy = (gameState.height||0)/2;
const k = 0.0025;
const toC = new Vector(cx - boid.pos.x, cy - boid.pos.y);
return toC.mult(k * boid.maxSpeed * 50).limit(boid.maxForce);` },

          { id: 'phys-gyroscopic', name: 'Physics — Gyroscopic Precession', code: `/**
  Gyroscopic Precession
  Accelerate perpendicular to current acceleration to create smooth arcs.
  @returns {Vector}
*/
const a = boid.acc.clone(); if (a.mag() === 0) return new Vector();
const perp = new Vector(-a.y, a.x).normalize().mult(boid.maxSpeed*0.6);
return Vector.sub(perp, boid.vel).limit(boid.maxForce*0.8);` },

          { id: 'phys-rotating-field', name: 'Physics — Rotating Vector Field', code: `/**
  Rotating Vector Field
  A simple divergence-free field: v = (sin(y/L), -sin(x/L)) producing curls.
  @returns {Vector}
*/
const L = 90;
const field = new Vector(Math.sin(boid.pos.y / L), -Math.sin(boid.pos.x / L)).mult(boid.maxSpeed*0.8);
// Visual: field hint arrow (sparse)
if (typeof api !== 'undefined' && api && api.addDrawable && Math.random() < 0.12) {
  const x = boid.pos.x, y = boid.pos.y; const fx = field.x * 0.2, fy = field.y * 0.2;
  api.addDrawable((ctx) => { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + fx, y + fy); ctx.strokeStyle = 'hsla(' + (config.hue) + ', 100%, 70%, 0.18)'; ctx.lineWidth = 1; ctx.stroke(); });
}
return Vector.sub(field, boid.vel).limit(boid.maxForce);` },

          { id: 'math-lissajous', name: 'Math — Lissajous Driver', code: `/**
  Lissajous Driver
  Target a parametric Lissajous heading: x = sin(a t), y = sin(b t + δ) applied as desired direction.
  @returns {Vector}
*/
const t = performance.now() * 0.002;
const a = 1.0, b = 1.7, d = Math.PI/3;
const dir = new Vector(Math.sin(a*t), Math.sin(b*t + d)).normalize();
const desired = dir.mult(boid.maxSpeed);
return Vector.sub(desired, boid.vel).limit(boid.maxForce*0.7);` },

          { id: 'phys-brownian', name: 'Physics — Brownian Jitter', code: `/**
  Brownian Jitter
  Add small unbiased random impulses to simulate thermal noise.
  @returns {Vector}
*/
return Vector.random2D().mult(boid.maxForce * 0.5);` },

          { id: 'math-scalar-potential', name: 'Math — Scalar Potential Flow', code: `/**
  Scalar Potential Flow
  Move along negative gradient of φ(x,y) = sin(x/L) cos(y/L) to follow potential valleys.
  @returns {Vector}
*/
const L = 120;
const dphidx = Math.cos(boid.pos.x / L) * Math.cos(boid.pos.y / L) / L;
const dphidy = -Math.sin(boid.pos.x / L) * Math.sin(boid.pos.y / L) / L;
const grad = new Vector(dphidx, dphidy);
const desired = grad.mult(-1).normalize().mult(boid.maxSpeed*0.8);
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'math-golden-spiral-center', name: 'Math — Golden Spiral to Center', code: `/**
  Golden Spiral to Center
  Steer along a logarithmic spiral toward the screen center with golden ratio turn.
  @returns {Vector}
*/
const cx = (gameState.width||0)/2, cy = (gameState.height||0)/2;
const toC = new Vector(cx - boid.pos.x, cy - boid.pos.y);
if (toC.mag() === 0) return new Vector();
const phi = (1 + Math.sqrt(5)) / 2; // golden ratio
const tang = new Vector(-toC.y, toC.x).normalize();
const desired = toC.normalize().mult(boid.maxSpeed*0.5).add(tang.mult(boid.maxSpeed*0.5/phi));
// Visual: tiny spiral stroke fragment (sparse)
if (typeof api !== 'undefined' && api && api.addDrawable && Math.random() < 0.1) {
  const x = boid.pos.x, y = boid.pos.y; const vx = desired.x * 0.25, vy = desired.y * 0.25;
  api.addDrawable((ctx) => { ctx.beginPath(); ctx.moveTo(x, y); ctx.quadraticCurveTo(x + vy * 0.5, y - vx * 0.5, x + vx, y + vy); ctx.strokeStyle = 'hsla(' + (((config.hue + 300) % 360)) + ', 100%, 70%, 0.15)'; ctx.lineWidth = 1; ctx.stroke(); });
}
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'math-fibonacci-spacing', name: 'Math — Fibonacci Spacing', code: `/**
  Fibonacci Spacing
  Encourage nearest-neighbor distance toward τ·size (τ ≈ golden ratio), repelling if closer and attracting if farther.
  @returns {Vector}
*/
let near = null; let dmin = Infinity;
for (const o of neighbors) { const d = Vector.dist(boid.pos, o.pos); if (d>0 && d<dmin) { dmin=d; near=o; } }
if (!near || !isFinite(dmin)) return new Vector();
const tau = (1 + Math.sqrt(5)) / 2;
const rest = Math.max(8, boid.size * tau);
const dir = Vector.sub(near.pos, boid.pos);
const sign = dmin > rest ? 1 : -1;
const desired = dir.normalize().mult(sign * boid.maxSpeed * Math.min(1, Math.abs(dmin-rest)/rest));
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          // ——— Visual Showcase (20) ———
          { id: 'visual-comet-trails', name: 'Visual — Comet Trails', code: `/**
  Comet Trails
  Draw short streaks behind boids; gentle forward bias.
  @returns {Vector}
*/
if (typeof api !== 'undefined' && api && api.addDrawable && Math.random() < 0.25) {
  const x=boid.pos.x,y=boid.pos.y; const t=boid.vel.clone().normalize().mult(10);
  api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.moveTo(x-t.x, y-t.y); ctx.lineTo(x, y); ctx.strokeStyle='hsla(' + (boid.hue) + ',100%,70%,0.28)'; ctx.lineWidth=1.5; ctx.stroke(); });
}
return boid.vel.clone().normalize().mult(0.001);` },

          { id: 'visual-ribbon-curves', name: 'Visual — Ribbon Curves', code: `/**
  Ribbon Curves
  Curvy quadratic strokes along velocity normals; slight lateral steer.
  @returns {Vector}
*/
const n = new Vector(-boid.vel.y, boid.vel.x).normalize();
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.18){
  const x=boid.pos.x,y=boid.pos.y; const v=boid.vel.clone().normalize().mult(12);
  api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.moveTo(x-v.x, y-v.y); ctx.quadraticCurveTo(x+n.x*6, y+n.y*6, x+v.x*0.4, y+v.y*0.4); ctx.strokeStyle='hsla(' + (((boid.hue+40)%360)) + ',100%,65%,0.22)'; ctx.lineWidth=1.2; ctx.stroke(); });
}
return n.mult(0.002);` },

          { id: 'visual-pulse-rings', name: 'Visual — Pulse Rings', code: `/**
  Pulse Rings
  Soft rings that expand from boid positions; minimal steering.
  @returns {Vector}
*/
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.08){
  const x=boid.pos.x,y=boid.pos.y,r=6+Math.random()*10;
  api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.strokeStyle='hsla(' + (((config.hue+80)%360)) + ',100%,70%,0.2)'; ctx.lineWidth=1; ctx.stroke();});
}
return new Vector();` },

          { id: 'visual-starburst', name: 'Visual — Starburst', code: `/**
  Starburst
  Short cross lines at select boids; slight radial push.
  @returns {Vector}
*/
const sp = boid.vel.clone().normalize(); const pr = new Vector(-sp.y, sp.x);
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.06){
  const x=boid.pos.x,y=boid.pos.y; const L=8;
  api.addDrawable((ctx)=>{ ctx.strokeStyle='hsla(' + (((config.hue+120)%360)) + ',100%,75%,0.22)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(x-L*sp.x,y-L*sp.y); ctx.lineTo(x+L*sp.x,y+L*sp.y); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x-L*pr.x,y-L*pr.y); ctx.lineTo(x+L*pr.x,y+L*pr.y); ctx.stroke();});
}
return sp.mult(0.002);` },

          { id: 'visual-aurora-bands', name: 'Visual — Aurora Bands', code: `/**
  Aurora Bands
  Horizontal translucent bands tied to y; no steering.
  @returns {Vector}
*/
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.05){
  const y=boid.pos.y; const h=12;
  api.addDrawable((ctx)=>{ ctx.fillStyle='hsla(' + (((config.hue+180)%360)) + ',100%,60%,0.06)'; ctx.fillRect(0,y-h/2,gameState.width,h); });
}
return new Vector();` },

          { id: 'visual-flow-ribbons', name: 'Visual — Flow Ribbons', code: `/**
  Flow Ribbons
  Draw two offset strokes along velocity; slight forward drive.
  @returns {Vector}
*/
const dir = boid.vel.clone().normalize(); const ort = new Vector(-dir.y, dir.x);
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.2){
  const x=boid.pos.x,y=boid.pos.y; const L=14;
  api.addDrawable((ctx)=>{ ctx.strokeStyle='hsla(' + (boid.hue) + ',100%,70%,0.18)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(x+ort.x*2,y+ort.y*2); ctx.lineTo(x+dir.x*L+ort.x*2,y+dir.y*L+ort.y*2); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x-ort.x*2,y-ort.y*2); ctx.lineTo(x+dir.x*L-ort.x*2,y+dir.y*L-ort.y*2); ctx.stroke();});
}
return dir.mult(0.002);` },

          { id: 'visual-fireflies', name: 'Visual — Fireflies', code: `/**
  Fireflies
  Twinkling dots with slight wander.
  @returns {Vector}
*/
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.15){
  const x=boid.pos.x,y=boid.pos.y; const a=0.2+Math.random()*0.5;
  api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.arc(x,y,1.8,0,Math.PI*2); ctx.fillStyle='hsla(' + (boid.hue) + ',100%,80%,' + a.toFixed(2) + ')'; ctx.fill(); });
}
return Vector.random2D().mult(0.003);` },

          { id: 'visual-vortex-spirals', name: 'Visual — Vortex Spirals', code: `/**
  Vortex Spirals
  Spiral glyphs perpendicular to velocity; slight swirl.
  @returns {Vector}
*/
const nrm=new Vector(-boid.vel.y, boid.vel.x).normalize();
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.08){
  const x=boid.pos.x,y=boid.pos.y; const r=8;
  api.addDrawable((ctx)=>{ ctx.beginPath(); for(let a=0;a<Math.PI*1.5;a+=0.3){ const R=r*a/(Math.PI*1.5); const px=x+Math.cos(a)*R, py=y+Math.sin(a)*R; if(a===0)ctx.moveTo(px,py); else ctx.lineTo(px,py);} ctx.strokeStyle='hsla(' + (((config.hue+220)%360)) + ',100%,70%,0.18)'; ctx.lineWidth=1; ctx.stroke();});
}
return nrm.mult(0.002);` },

          { id: 'visual-chord-weave', name: 'Visual — Chord Weave', code: `/**
  Chord Weave
  Connect random nearby boids to form chordal meshes.
  @returns {Vector}
*/
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.08){
  const bx=boid.pos.x,by=boid.pos.y; const maxL=config.perceptionRadius*0.5;
  api.addDrawable((ctx)=>{ ctx.strokeStyle='hsla(' + (((config.hue+260)%360)) + ',100%,70%,0.10)'; ctx.lineWidth=1; for(const o of neighbors){ const d=Vector.dist(boid.pos,o.pos); if(d<maxL && Math.random()<0.2){ ctx.beginPath(); ctx.moveTo(bx,by); ctx.lineTo(o.pos.x,o.pos.y); ctx.stroke(); } } });
}
return new Vector();` },

          { id: 'visual-lattice-ripples', name: 'Visual — Lattice Ripples', code: `/**
  Lattice Ripples
  Horizontal/vertical hints forming a loose lattice.
  @returns {Vector}
*/
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.07){
  const x=boid.pos.x,y=boid.pos.y,dx=10,dy=10;
  api.addDrawable((ctx)=>{ ctx.strokeStyle='hsla(' + (((config.hue+20)%360)) + ',100%,60%,0.08)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(x-dx,y); ctx.lineTo(x+dx,y); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x,y-dy); ctx.lineTo(x,y+dy); ctx.stroke();});
}
return new Vector();` },

          { id: 'visual-kaleido-fan', name: 'Visual — Kaleido Fan', code: `/**
  Kaleido Fan
  Short fan of rays from boid heading.
  @returns {Vector}
*/
const d=boid.vel.clone().normalize(); const ang=Math.atan2(d.y,d.x);
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.06){
  const x=boid.pos.x,y=boid.pos.y; const rays=5; const L=12;
  api.addDrawable((ctx)=>{ ctx.strokeStyle='hsla(' + (((config.hue+300)%360)) + ',100%,70%,0.15)'; ctx.lineWidth=1; for(let i=-2;i<=2;i++){ const a=ang+i*0.12; ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+Math.cos(a)*L,y+Math.sin(a)*L); ctx.stroke(); }});
}
return d.mult(0.002);` },

          { id: 'visual-petal-swirl', name: 'Visual — Petal Swirl', code: `/**
  Petal Swirl
  Petal-like arcs around moving boids.
  @returns {Vector}
*/
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.08){
  const x=boid.pos.x,y=boid.pos.y; const r=7; const n=4;
  api.addDrawable((ctx)=>{ ctx.strokeStyle='hsla(' + (((config.hue+340)%360)) + ',100%,70%,0.18)'; ctx.lineWidth=1; for(let i=0;i<n;i++){ const a=i*(Math.PI*2/n); ctx.beginPath(); ctx.arc(x+Math.cos(a)*r,y+Math.sin(a)*r, r*0.6, a-0.8, a+0.8); ctx.stroke(); } });
}
return new Vector();` },

          { id: 'visual-tide-lines', name: 'Visual — Tide Lines', code: `/**
  Tide Lines
  Faint angled stripes; minimal steer along stripe.
  @returns {Vector}
*/
const a=0.4; const dir=new Vector(Math.cos(a),Math.sin(a));
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.05){
  const y=boid.pos.y; api.addDrawable((ctx)=>{ ctx.strokeStyle='hsla(' + (((config.hue+30)%360)) + ',100%,65%,0.06)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(gameState.width,y+Math.tan(a)*gameState.width); ctx.stroke(); });
}
return dir.mult(0.001);` },

          { id: 'visual-wave-interference', name: 'Visual — Wave Interference', code: `/**
  Wave Interference
  Concentric arcs offset by phase; mild oscillatory steer.
  @returns {Vector}
*/
const t=performance.now()*0.002; const w=0.6; const osc=Math.sin(t+w*boid.pos.x*0.02);
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.06){
  const x=boid.pos.x,y=boid.pos.y,r=8+osc*4; api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.strokeStyle='hsla(' + (((config.hue+200)%360)) + ',100%,70%,0.12)'; ctx.stroke(); });
}
return boid.vel.clone().normalize().mult(0.0015*osc);` },

          { id: 'visual-orbit-petals', name: 'Visual — Orbit Petals', code: `/**
  Orbit Petals
  Petal arcs around the mouse position; draws only when pressed.
  @returns {Vector}
*/
if (!mouse.down) return new Vector();
const mp=new Vector(mouse.pos.x,mouse.pos.y); const toM=Vector.sub(mp,boid.pos); const tang=new Vector(-toM.y,toM.x).normalize();
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.1){
  const x=mp.x,y=mp.y,r=120; api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.arc(x,y,r,Math.atan2(tang.y,tang.x)-0.3, Math.atan2(tang.y,tang.x)+0.3); ctx.strokeStyle='hsla(' + (((config.hue+40)%360)) + ',100%,65%,0.15)'; ctx.lineWidth=1; ctx.stroke();});
}
return Vector.sub(tang.mult(boid.maxSpeed*0.6), boid.vel).limit(boid.maxForce*0.6);` },

          { id: 'visual-braids', name: 'Visual — Braids', code: `/**
  Braids
  Paired offset strokes that weave as velocities change.
  @returns {Vector}
*/
const dvec=boid.vel.clone().normalize(); const o=new Vector(-dvec.y,dvec.x).mult(3);
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.18){
  const x=boid.pos.x,y=boid.pos.y,L=14; api.addDrawable((ctx)=>{ ctx.strokeStyle='hsla(' + (((config.hue+280)%360)) + ',100%,70%,0.14)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(x+o.x,y+o.y); ctx.lineTo(x+dvec.x*L+o.x,y+dvec.y*L+o.y); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x-o.x,y-o.y); ctx.lineTo(x+dvec.x*L-o.x,y+dvec.y*L-o.y); ctx.stroke();});
}
return dvec.mult(0.002);` },

          { id: 'visual-constellation-lines', name: 'Visual — Constellation Lines', code: `/**
  Constellation Lines
  Connect sparse nearby boids to form constellations.
  @returns {Vector}
*/
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.04){
  const bx=boid.pos.x,by=boid.pos.y; api.addDrawable((ctx)=>{ ctx.strokeStyle='hsla(' + (((config.hue+90)%360)) + ',100%,70%,0.12)'; ctx.lineWidth=1; for(const o of neighbors){ const d=Vector.dist(boid.pos,o.pos); if(d<80 && Math.random()<0.05){ ctx.beginPath(); ctx.moveTo(bx,by); ctx.lineTo(o.pos.x,o.pos.y); ctx.stroke(); } } });
}
return new Vector();` },

          { id: 'visual-shockwave-rings', name: 'Visual — Shockwave Rings', code: `/**
  Shockwave Rings
  Radiating rings from the mouse when pressed; boids mildly flee.
  @returns {Vector}
*/
if (!mouse.down) return new Vector();
const mp=new Vector(mouse.pos.x,mouse.pos.y); const d=Vector.dist(boid.pos,mp); const dir=Vector.sub(boid.pos,mp).normalize();
if (typeof api!=='undefined'&&api&&api.addDrawable){ const r= (performance.now()/12)%200; api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.arc(mp.x,mp.y,r,0,Math.PI*2); ctx.strokeStyle='hsla(' + (config.hue) + ',100%,65%,0.18)'; ctx.lineWidth=1; ctx.stroke();}); }
return dir.mult(boid.maxSpeed*Math.max(0, 1-d/200)).sub(boid.vel).limit(boid.maxForce);` },

          { id: 'visual-heartline-field', name: 'Visual — Heartline Field', code: `/**
  Heartline Field
  Draw bezier heart curves centered on boids; low-force drift.
  @returns {Vector}
*/
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.04){
  const x=boid.pos.x,y=boid.pos.y,s=6;
  api.addDrawable((ctx)=>{ ctx.strokeStyle='hsla(' + (((config.hue+330)%360)) + ',100%,70%,0.18)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(x, y-s); ctx.bezierCurveTo(x-s, y-s*1.6, x-s*1.2, y, x, y+s); ctx.moveTo(x, y-s); ctx.bezierCurveTo(x+s, y-s*1.6, x+s*1.2, y, x, y+s); ctx.stroke();});
}
return new Vector();` },

          { id: 'visual-neon-echoes', name: 'Visual — Neon Echoes', code: `/**
  Neon Echoes
  Two echoing outlines trailing behind boids.
  @returns {Vector}
*/
const u=boid.vel.clone().normalize(); if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.2){ const x=boid.pos.x,y=boid.pos.y; api.addDrawable((ctx)=>{ ctx.strokeStyle='hsla(' + (((config.hue+20)%360)) + ',100%,70%,0.16)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(x-u.x*6,y-u.y*6); ctx.lineTo(x-u.x*2,y-u.y*2); ctx.stroke(); ctx.strokeStyle='hsla(' + (((config.hue+200)%360)) + ',100%,70%,0.12)'; ctx.beginPath(); ctx.moveTo(x-u.x*10,y-u.y*10); ctx.lineTo(x-u.x*6,y-u.y*6); ctx.stroke();}); }
return u.mult(0.002);` },

          { id: 'viz-separation-radius', name: 'Visual — Separation Radius', code: `/**
  Separation Radius Visualizer
  Draws a translucent ring around each boid indicating the separation radius.
  The ring subtly brightens with local crowding (more neighbors inside radius).
  No steering — purely visual.
  @returns {Vector}
*/
const R = Math.max(8, (config.perceptionRadius || 50) * 0.6); // treat 60% of perception as separation zone
let crowd = 0;
for (const o of neighbors) {
  const d = Vector.dist(boid.pos, o.pos);
  if (d > 0 && d < R) crowd++;
}
if (typeof api !== 'undefined' && api && api.addDrawable) {
  const x = boid.pos.x, y = boid.pos.y;
  const baseAlpha = 0.08;
  const boost = Math.min(0.18, crowd * 0.012);
  const alpha = (baseAlpha + boost).toFixed(3);
  api.addDrawable((ctx) => {
    // Outer ring
    ctx.beginPath(); ctx.arc(x, y, R, 0, Math.PI * 2);
    ctx.strokeStyle = 'hsla(' + (((config.hue+260)%360)) + ',100%,70%,' + alpha + ')';
    ctx.lineWidth = 1; ctx.stroke();
    // Inner subtle fill to hint radius
    const g = ctx.createRadialGradient(x, y, Math.max(1,R*0.85), x, y, R);
    g.addColorStop(0, 'hsla(' + (((config.hue+260)%360)) + ',100%,70%,0.00)');
    g.addColorStop(1, 'hsla(' + (((config.hue+260)%360)) + ',100%,70%,' + (alpha*0.6) + ')');
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(x, y, R, 0, Math.PI*2); ctx.fill();
  });
}
return new Vector();` },

          { id: 'viz-perception-color-blend', name: 'Visual — Perception Color Blend', code: `/**
  Perception Radius Color Blend
  Draws the perception radius and gradually blends each boid's hue toward the
  circular-mean hue of perceived neighbors (handles wrap-around correctly).
  No steering — purely visual and cosmetic.
  @returns {Vector}
*/
const R = Math.max(8, (config.perceptionRadius || 50));
// Compute circular mean of neighbor hues within perception radius
let sx = 0, sy = 0, n = 0;
for (const o of neighbors) {
  const d = Vector.dist(boid.pos, o.pos);
  if (d > 0 && d < R) {
    const a = (o.hue || 0) * Math.PI / 180;
    sx += Math.cos(a); sy += Math.sin(a); n++;
  }
}
if (n > 0 && (config.perceptionBlend !== false)) {
  const meanAng = Math.atan2(sy, sx) * 180 / Math.PI;
  const targetHue = (meanAng + 360) % 360;
  // Smoothly move boid.hue toward targetHue using shortest angular distance
  const delta = ((targetHue - boid.hue + 540) % 360) - 180;
  const rate = Math.max(0, Math.min(1, (typeof config.perceptionBlendRate === 'number' ? config.perceptionBlendRate : 0.08)));
  if (rate > 0) {
  boid.hue = (boid.hue + rate * delta + 360) % 360;
  }
}
// Visualize perception radius with current (blended) hue
if (typeof api !== 'undefined' && api && api.addDrawable) {
  const x = boid.pos.x, y = boid.pos.y;
  const alpha = 0.12;
  const ringHue = Math.round(boid.hue) % 360;
  api.addDrawable((ctx) => {
    ctx.beginPath(); ctx.arc(x, y, R, 0, Math.PI * 2);
    ctx.strokeStyle = 'hsla(' + (ringHue) + ',100%,70%,' + alpha + ')';
    ctx.lineWidth = 1; ctx.stroke();
    // faint inner gradient
    const g = ctx.createRadialGradient(x, y, Math.max(1, R*0.7), x, y, R);
    g.addColorStop(0, 'hsla(' + (ringHue) + ',100%,70%,0.00)');
    g.addColorStop(1, 'hsla(' + (ringHue) + ',100%,70%,' + (alpha*0.5) + ')');
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(x, y, R, 0, Math.PI*2); ctx.fill();
  });
}
return new Vector();` },

          { id: 'novel-kuramoto-aurora', name: 'Novel — Kuramoto Aurora Swarm', code: `/**
  Kuramoto Aurora Swarm (Emergent Phase-Coupled Dynamics)

  Concept
  ————
  Each boid carries an internal oscillator phase θ with a natural frequency ω.
  Local, distance-limited Kuramoto coupling drives phases to form waves/spirals,
  while steering biases create graceful, unpredictable motion. The visuals paint
  the phase and order into glowing auroras, with occasional connections.

  Mechanics (different from core rules)
  ————————————————————————————————
  - Phase update (per frame, small-step):
      θ_i += ω_i + K * R * sin(μ - θ_i)
    where μ is the mean neighbor phase and R is local order (coherence).
  - Steering:
      • Swirl: rotate current velocity by a small phase-dependent angle
      • Cohere-to-wave: nudge toward local centroid scaled by cos(θ)
      • Flow-glide: small drift along the phase-gradient proxy
  - Visuals:
      • Halo colored by θ (aurora); intensity by local order R
      • Occasional links to in-phase neighbors, additive glow
      • Faint trail deposition scaled by R

  Parameters
  ————————
    K: coupling strength (0.06)
    ω range: base ± jitter (base 0.02 rad/frame)
    swirlAngle = 0.25 * sin(θ)

  Returns
  —————
  A steering vector; Rule uses Vector API and optional api helpers.
  */
// ---- Phase state ----
if (typeof boid._phase !== 'number') {
  boid._phase = Math.random() * Math.PI * 2;
  const wBase = (typeof config.kuramotoOmegaBase === 'number') ? config.kuramotoOmegaBase : 0.02;
  const wJit = (typeof config.kuramotoOmegaJitter === 'number') ? config.kuramotoOmegaJitter : 0.01;
  boid._omega = (wBase + (Math.random()-0.5)*wJit) * (Math.random()<0.5?-1:1);
}
// Neighborhood stats within perception
const Rp = (config.perceptionRadius||50);
let sx=0, sy=0, n=0, cx=0, cy=0;
for (const o of neighbors) {
  const d = Vector.dist(boid.pos, o.pos); if (d>0 && d < Rp) {
    const a = (typeof o._phase==='number'? o._phase : (o.hue||0)*Math.PI/180);
    sx += Math.cos(a); sy += Math.sin(a); n++;
    cx += o.pos.x; cy += o.pos.y;
  }
}
let R = 0, mu = boid._phase; // local order and mean phase
if (n>0) { R = Math.min(1, Math.sqrt(sx*sx + sy*sy)/n); mu = Math.atan2(sy, sx); }
// ---- Phase update (small step) ----
const K = (typeof config.kuramotoK === 'number') ? config.kuramotoK : 0.06; // coupling
const dtheta = boid._omega + K * R * Math.sin(mu - boid._phase);
boid._phase = (boid._phase + dtheta + Math.PI*2) % (Math.PI*2);

// Map phase to hue for aurora
const hue = (boid._phase * 180 / Math.PI) % 360;
boid.hue = hue;

// ---- Steering fields ----
// Swirl: rotate velocity by a small phase-driven angle
const swirlAngle = 0.25 * Math.sin(boid._phase);
const v = boid.vel.clone();
const cs = Math.cos(swirlAngle), sn = Math.sin(swirlAngle);
const vrot = new Vector(v.x*cs - v.y*sn, v.x*sn + v.y*cs);
let steer = Vector.sub(vrot.normalize().mult(boid.maxSpeed), boid.vel).limit(boid.maxForce*0.6);

// Cohere-to-wave: toward centroid, scaled by cos(phase)
if (n>0) {
  cx/=n; cy/=n; const toC = new Vector(cx - boid.pos.x, cy - boid.pos.y);
  const coh = toC.normalize().mult(boid.maxSpeed * (0.25 + 0.35*Math.max(0, Math.cos(boid._phase))))
  steer.add(Vector.sub(coh, boid.vel).limit(boid.maxForce*0.5));
}

// Phase-gradient proxy: drift along –∇θ ≈ sum (unit to neighbor) * sin(Δθ)
let g = new Vector();
for (const o of neighbors) {
  const d = Vector.dist(boid.pos, o.pos); if (d>0 && d<Rp) {
    const u = new Vector((o.pos.x - boid.pos.x)/d, (o.pos.y - boid.pos.y)/d);
    const a = (typeof o._phase==='number'? o._phase : (o.hue||0)*Math.PI/180);
    g.add(u.mult(Math.sin(a - boid._phase)));
  }
}
if (g.mag()>0) {
  const glide = g.normalize().mult(boid.maxSpeed*0.25);
  steer.add(Vector.sub(glide, boid.vel).limit(boid.maxForce*0.4));
}

// ---- Visuals ----
if (typeof api !== 'undefined' && api && api.addDrawable) {
  const x=boid.pos.x, y=boid.pos.y; const ringA = (0.08 + R*0.18).toFixed(3);
  api.addDrawable((ctx)=>{
    // Aurora halo (phase-colored)
    const r0=10, r1=26+R*10;
    const gg=ctx.createRadialGradient(x,y, r0, x,y, r1);
    gg.addColorStop(0, 'hsla(' + hue + ',100%,60%,' + (0.22+R*0.18).toFixed(3) + ')');
    gg.addColorStop(1, 'hsla(' + hue + ',100%,60%,0.00)');
    ctx.fillStyle=gg; ctx.beginPath(); ctx.arc(x,y,r1,0,Math.PI*2); ctx.fill();
    // Perception ring (thin)
    ctx.beginPath(); ctx.arc(x,y, Math.max(14, Rp*0.5), 0, Math.PI*2);
    ctx.strokeStyle = 'hsla(' + hue + ',100%,70%,' + ringA + ')'; ctx.lineWidth=1; ctx.stroke();
  });
  // Occasional in-phase links (glow)
  if (Math.random()<0.06 && n>0) {
    // pick close, in-phase neighbor
    let pick=null, pd=1e9; for(const o of neighbors){ const d=Vector.dist(boid.pos,o.pos); if(d>8 && d<Rp){ const a=(typeof o._phase==='number'?o._phase:(o.hue||0)*Math.PI/180); if (Math.cos(a - boid._phase)>0.8 && d<pd){ pd=d; pick=o; } } }
    if (pick) {
      const x1=x,y1=y,x2=pick.pos.x,y2=pick.pos.y; const hue2=(hue+pick.hue)/2;
      api.addDrawable((ctx)=>{ ctx.save(); ctx.globalCompositeOperation='lighter'; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.strokeStyle='hsla(' + hue2 + ',100%,70%,0.20)'; ctx.lineWidth=1.5; ctx.stroke(); ctx.restore(); });
    }
  }
}
// Trails intensified by coherence
if (typeof api !== 'undefined' && api && api.depositTrail) {
  api.depositTrail(boid.pos.x, boid.pos.y, Math.min(1.6, 0.4 + R*0.9));
}

  return steer.limit(boid.maxForce);` },

          { id: 'novel-reaction-diffusion', name: 'Novel — Reaction‑Diffusion Trails', code: `/**
  Reaction‑Diffusion Trails (Gray‑Scott Inspired)

  Concept
  ————
  Two scalar fields A and B evolve on a coarse grid via Gray‑Scott‑like dynamics.
  Boids deposit B; A is replenished. Reaction and diffusion carve out living
  patterns that guide motion: boids drift along B's isocontours and avoid high B.

  Fields (per grid cell)
  ———————————————
    A, B
    A' = A + D * Laplacian(A) - A*B*B + feed*(1 - A)
    B' = B + D * Laplacian(B) + A*B*B - (kill + feed)*B

  Steering
  ——————
    • Edge follow: glide tangentially to ∇B (isocontour following)
    • Avoid peak: slight push away from high B

  Visuals
  —————
    • Additive aurora for B intensity near boid
    • Faint vector showing tangential drift

  Config
  —————
    Uses config.rdFeed, config.rdKill, config.rdDiffusion, config.rdDeposit
  */
// Grid sizing (reuse pheromone tiling)
const cols = pheromones.cols, rows = pheromones.rows, cell = pheromones.cell;
if (!gameState._rdA || gameState._rdA.length !== cols*rows) {
  gameState._rdA = new Float32Array(cols*rows);
  gameState._rdB = new Float32Array(cols*rows);
  for (let i=0;i<cols*rows;i++) { gameState._rdA[i] = 1.0; gameState._rdB[i] = 0.0; }
}
const A = gameState._rdA, B = gameState._rdB;
const feed = (typeof config.rdFeed==='number'?config.rdFeed:0.037);
const kill = (typeof config.rdKill==='number'?config.rdKill:0.06);
const D = (typeof config.rdDiffusion==='number'?config.rdDiffusion:0.95) * 0.2; // small per-frame blend
const dep = (typeof config.rdDeposit==='number'?config.rdDeposit:0.55);

// Helpers
function idx(i,j){ return j*cols + i; }
function clamp(v, lo, hi){ return v<lo?lo:(v>hi?hi:v); }

// Map boid pos to cell
const ci = clamp(Math.floor(boid.pos.x / cell), 1, cols-2);
const cj = clamp(Math.floor(boid.pos.y / cell), 1, rows-2);
// Deposit B at boid; consume A
const k = idx(ci, cj);
B[k] = clamp(B[k] + dep*0.02, 0, 1);
A[k] = clamp(A[k] - dep*0.01, 0, 1);

// Update a tiny 3x3 patch around the boid (stochastic sparse updates per frame)
for (let dj=-1; dj<=1; dj++) for (let di=-1; di<=1; di++) {
  const i = ci+di, j=cj+dj; const p = idx(i,j);
  // 4-neighborhood laplacian (poor-man)
  const lapA = A[idx(i-1,j)] + A[idx(i+1,j)] + A[idx(i,j-1)] + A[idx(i,j+1)] - 4*A[p];
  const lapB = B[idx(i-1,j)] + B[idx(i+1,j)] + B[idx(i,j-1)] + B[idx(i,j+1)] - 4*B[p];
  const a = A[p], b = B[p];
  const reaction = a*b*b;
  const a2 = a + D*lapA - reaction + feed*(1-a);
  const b2 = b + D*lapB + reaction - (kill+feed)*b;
  A[p] = clamp(a2, 0, 1);
  B[p] = clamp(b2, 0, 1);
}

// Compute gradient of B for steering
const gx = (B[idx(ci+1,cj)] - B[idx(ci-1,cj)]) * 0.5;
const gy = (B[idx(ci,cj+1)] - B[idx(ci,cj-1)]) * 0.5;
const grad = new Vector(gx, gy);
let steer = new Vector();
if (grad.mag()>1e-6) {
  const tang = new Vector(-grad.y, grad.x).normalize(); // isocontour direction
  const glide = tang.mult(boid.maxSpeed*0.6);
  steer.add(Vector.sub(glide, boid.vel).limit(boid.maxForce*0.7));
  const away = grad.clone().normalize().mult(boid.maxSpeed*0.25);
  steer.add(Vector.sub(away, boid.vel).limit(boid.maxForce*0.3));
}

// Visuals — B aurora and tangential hint
if (typeof api!=='undefined' && api && api.addDrawable) {
  const x=boid.pos.x, y=boid.pos.y; const vB=B[k];
  const hue = (config.hue + Math.floor(180*vB)) % 360; const alpha = (0.08 + vB*0.25).toFixed(3);
  api.addDrawable((ctx)=>{
    const r=12+vB*24; const g=ctx.createRadialGradient(x,y,2,x,y,r);
    g.addColorStop(0, 'hsla(' + hue + ',100%,60%,' + (0.18+vB*0.18).toFixed(3) + ')');
    g.addColorStop(1, 'hsla(' + hue + ',100%,60%,0.00)');
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    if (grad.mag()>1e-6) {
      const tnorm = new Vector(-grad.y, grad.x).normalize();
      ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+tnorm.x*14, y+tnorm.y*14);
      ctx.strokeStyle='hsla(' + hue + ',100%,70%,' + alpha + ')'; ctx.lineWidth=1; ctx.stroke();
    }
  });
}

return steer.limit(boid.maxForce);` },

          { id: 'novel-predator-prey', name: 'Novel — Predator–Prey Pursuit', code: `/**
  Predator–Prey Pursuit (Emergent Chase & Flee)

  Concept
  ————
  A fraction of boids are marked as predators; the rest are prey. Predators
  hunt nearby prey; prey flee nearby predators. This creates emergent waves of
  pursuit and evasion, with visually contrasting hues and connective cues.

  Config
  —————
    predatorFrac   (default 0.12) — fraction of predators
    predatorBoost  (default 1.25) — speed factor for predators
    preyPanic      (default 1.15) — speed factor for prey when fleeing

  Visuals
  —————
    • Predators: contrasting hue (hue+180), faint pursuit lines
    • Prey: base hue, occasional panic halo while fleeing

  Returns
  —————
  A steering vector that biases toward (predator) or away (prey) neighbors.
  */
// Defaults from config
const frac = (typeof config.predatorFrac==='number') ? Math.max(0, Math.min(0.9, config.predatorFrac)) : 0.12;
const pBoost = (typeof config.predatorBoost==='number') ? Math.max(0.5, Math.min(2.0, config.predatorBoost)) : 1.25;
const panic = (typeof config.preyPanic==='number') ? Math.max(0.5, Math.min(2.0, config.preyPanic)) : 1.15;

// Assign role once
if (!boid._role) {
  boid._role = (Math.random() < frac) ? 'pred' : 'prey';
}
// Set visual hue by role
if (boid._role === 'pred') boid.hue = ((config.hue||200) + 180) % 360; else boid.hue = (config.hue||200);

// Find nearest target/opponent within perception
const Rp = (config.perceptionRadius||50);
let nearest = null, nd = 1e9;
for (const o of neighbors) {
  const d = Vector.dist(boid.pos, o.pos);
  if (d>0 && d<Rp) {
    if (boid._role === 'pred' && o._role !== 'pred') { if (d<nd) { nd=d; nearest=o; } }
    if (boid._role !== 'pred' && o._role === 'pred') { if (d<nd) { nd=d; nearest=o; } }
  }
}

let steer = new Vector();
if (nearest) {
  const dir = (boid._role==='pred') ? Vector.sub(nearest.pos, boid.pos) : Vector.sub(boid.pos, nearest.pos);
  const spd = (boid._role==='pred') ? (boid.maxSpeed*pBoost) : (boid.maxSpeed*panic);
  const desired = dir.normalize().mult(spd);
  steer = Vector.sub(desired, boid.vel).limit(boid.maxForce * (boid._role==='pred' ? 1.2 : 1.0));
}

// Soft bias to keep momentum if no interaction
if (nearest === null) {
  const desired = boid.vel.clone().normalize().mult(boid.maxSpeed*0.9);
  steer.add(Vector.sub(desired, boid.vel).limit(boid.maxForce*0.4));
}

// Visuals
if (typeof api!=='undefined' && api && api.addDrawable) {
  const x=boid.pos.x, y=boid.pos.y;
  if (boid._role==='pred' && nearest) {
    api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(nearest.pos.x, nearest.pos.y); ctx.strokeStyle='hsla(' + (((config.hue+180)%360)) + ',100%,70%,0.15)'; ctx.lineWidth=1; ctx.stroke(); });
  } else if (boid._role!=='pred' && nearest) {
    // panic halo
    const a = (0.10 + Math.max(0, (Rp-nd)/Rp)*0.20).toFixed(3);
    api.addDrawable((ctx)=>{ const r=12; const g=ctx.createRadialGradient(x,y,2,x,y,22); g.addColorStop(0,'hsla(' + (config.hue) + ',100%,60%,'+(0.18)+')'); g.addColorStop(1,'hsla(' + (config.hue) + ',100%,60%,0.00)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,22,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(x,y, Math.max(10, Rp*0.45), 0, Math.PI*2); ctx.strokeStyle='hsla(' + (config.hue) + ',100%,70%,'+a+')'; ctx.lineWidth=1; ctx.stroke(); });
  }
}

return steer.limit(boid.maxForce);` },

          // ——— Interaction‑Driven (Clicks/Drags) ———
          { id: 'click-gravity-well-strong', name: 'Click — Gravity Well (Strong)', code: `/**
  Gravity Well (Strong)
  When mouse is down, pull boids strongly toward the cursor with 1/r falloff.
  @returns {Vector}
*/
if (!mouse.down) return new Vector();
const mp = new Vector(mouse.pos.x, mouse.pos.y);
const toM = Vector.sub(mp, boid.pos);
const d = Math.max(1, toM.mag());
const force = toM.normalize().mult(boid.maxSpeed * Math.min(1.5, 120 / d));
// Visual
if (typeof api !== 'undefined' && api && api.addDrawable) { const x=mp.x,y=mp.y; api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.arc(x,y,80,0,Math.PI*2); ctx.strokeStyle='hsla(' + (config.hue) + ',100%,65%,0.12)'; ctx.lineWidth=1; ctx.stroke(); }); }
return Vector.sub(force, boid.vel).limit(boid.maxForce * 2.0);` },

          { id: 'click-explosion', name: 'Click — Explosion', code: `/**
  Explosion
  Strong outward impulse away from mouse when pressed.
  @returns {Vector}
*/
if (!mouse.down) return new Vector();
const mp = new Vector(mouse.pos.x, mouse.pos.y);
const away = Vector.sub(boid.pos, mp); const d = Math.max(1, away.mag());
const magnitude = Math.min(2.2, 160 / d);
const desired = away.normalize().mult(boid.maxSpeed * magnitude);
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 2.5);` },

          { id: 'click-vortex-strong', name: 'Click — Vortex (Strong)', code: `/**
  Vortex (Strong)
  Combines tangential spin with mild inward pull around the mouse when pressed.
  @returns {Vector}
*/
if (!mouse.down) return new Vector();
const mp = new Vector(mouse.pos.x, mouse.pos.y);
const toM = Vector.sub(mp, boid.pos); const d = Math.max(1, toM.mag());
const tang = new Vector(-toM.y, toM.x).normalize();
const desired = tang.mult(boid.maxSpeed * 1.1).add(toM.normalize().mult(boid.maxSpeed * 0.25));
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 2.0);` },

          { id: 'click-brake-zone', name: 'Click — Brake Zone', code: `/**
  Brake Zone
  Boids near the cursor are rapidly braked (anti-velocity) while mouse is down.
  @returns {Vector}
*/
if (!mouse.down) return new Vector();
const mp = new Vector(mouse.pos.x, mouse.pos.y); const dist = Vector.dist(boid.pos, mp);
if (dist > 120) return new Vector();
const brake = boid.vel.clone().mult(-1.0);
return brake.limit(boid.maxForce * 2.0);` },

          { id: 'click-speed-boost', name: 'Click — Speed Boost', code: `/**
  Speed Boost
  Boids near the cursor get a forward push along their heading.
  @returns {Vector}
*/
if (!mouse.down) return new Vector();
const mp = new Vector(mouse.pos.x, mouse.pos.y); const dist = Vector.dist(boid.pos, mp);
if (dist > 140) return new Vector();
const boost = boid.vel.clone().normalize().mult(boid.maxSpeed * 0.9);
return Vector.sub(boost, boid.vel).limit(boid.maxForce * 1.8);` },

          { id: 'drag-wind-gust', name: 'Drag — Wind Gust', code: `/**
  Wind Gust
  While dragging, apply a directional wind along mouse velocity, stronger near the cursor.
  @returns {Vector}
*/
if (!mouse.down) return new Vector();
const w = new Vector(mouse.vel.x || 0, mouse.vel.y || 0);
if (w.mag() < 0.1) return new Vector();
const mp = new Vector(mouse.pos.x, mouse.pos.y);
const d = Math.max(1, Vector.dist(boid.pos, mp));
const desired = w.normalize().mult(boid.maxSpeed * Math.min(1.2, 180 / d));
// Visual
if (typeof api !== 'undefined' && api && api.addDrawable) { const x=mp.x,y=mp.y, L=24; const mag=Math.max(1e-6, desired.mag()); const ux=desired.x/mag*L, uy=desired.y/mag*L; api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+ux,y+uy); ctx.strokeStyle='hsla(' + (config.hue) + ',100%,70%,0.16)'; ctx.lineWidth=2; ctx.stroke(); }); }
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 2.2);` },

          { id: 'drag-barrier-repel', name: 'Drag — Barrier Repel', code: `/**
  Barrier Repel
  Treat the short segment from previous to current mouse position as a barrier; boids near it are repelled.
  @returns {Vector}
*/
if (!mouse.down) return new Vector();
const ax = mouse.prev.x, ay = mouse.prev.y, bx = mouse.pos.x, by = mouse.pos.y;
const abx = bx - ax, aby = by - ay; const ab2 = abx*abx + aby*aby;
if (ab2 < 25) return new Vector();
// Project boid onto segment
const apx = boid.pos.x - ax, apy = boid.pos.y - ay;
let t = (apx*abx + apy*aby) / ab2; t = Math.max(0, Math.min(1, t));
const cx = ax + abx * t, cy = ay + aby * t;
const dx = boid.pos.x - cx, dy = boid.pos.y - cy; const dist2 = dx*dx + dy*dy;
if (dist2 > 900) return new Vector();
const n = new Vector(dx, dy).normalize();
const desired = n.mult(boid.maxSpeed * Math.min(1.5, 300 / Math.sqrt(dist2 + 1)));
// Visual
if (typeof api !== 'undefined' && api && api.addDrawable) { const x1=ax,y1=ay,x2=bx,y2=by; api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.strokeStyle='hsla(' + (config.hue) + ',100%,60%,0.15)'; ctx.lineWidth=2; ctx.stroke(); }); }
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 2.0);` },

          { id: 'drag-line-tractor', name: 'Drag — Line Tractor', code: `/**
  Line Tractor
  Attract boids toward the dragged segment (previous → current mouse pos); stronger when closer.
  @returns {Vector}
*/
if (!mouse.down) return new Vector();
const ax = mouse.prev.x, ay = mouse.prev.y, bx = mouse.pos.x, by = mouse.pos.y;
const abx = bx - ax, aby = by - ay; const ab2 = abx*abx + aby*aby;
if (ab2 < 25) return new Vector();
const apx = boid.pos.x - ax, apy = boid.pos.y - ay; let t = (apx*abx + apy*aby)/ab2; t = Math.max(0, Math.min(1, t));
const cx = ax + abx*t, cy = ay + aby*t;
const toLine = new Vector(cx - boid.pos.x, cy - boid.pos.y); const d = Math.max(1, toLine.mag());
const desired = toLine.normalize().mult(boid.maxSpeed * Math.min(1.5, 240 / d));
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 2.0);` },

          { id: 'drag-shear-field', name: 'Drag — Shear Field', code: `/**
  Shear Field
  While dragging, push boids perpendicular to mouse velocity, scaled by distance from the cursor line.
  @returns {Vector}
*/
if (!mouse.down) return new Vector();
const v = new Vector(mouse.vel.x || 0, mouse.vel.y || 0); if (v.mag() < 0.1) return new Vector();
const tangent = v.clone().normalize(); const normal = new Vector(-tangent.y, tangent.x);
const mp = new Vector(mouse.pos.x, mouse.pos.y);
const rel = Vector.sub(boid.pos, mp);
const side = Math.sign(rel.x*normal.x + rel.y*normal.y) || 1;
const dist = Math.abs(rel.x*normal.x + rel.y*normal.y);
const desired = normal.mult(side * boid.maxSpeed * Math.min(1.2, 180 / Math.max(20, dist)));
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 2.0);` },

          { id: 'click-implosion', name: 'Click — Implosion', code: `/**
  Implosion
  Strong inward pull near the cursor; very high near-field intensity.
  @returns {Vector}
*/
if (!mouse.down) return new Vector();
const mp = new Vector(mouse.pos.x, mouse.pos.y);
const toM = Vector.sub(mp, boid.pos); const d = Math.max(1, toM.mag());
const desired = toM.normalize().mult(boid.maxSpeed * Math.min(2.4, 240 / d));
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 3.0);` },

          // --- Flashy drawable-focused presets (occasional visuals only) ---
          { id: 'spark-burst', name: 'Flash — Spark Burst', code: `/**
  Spark Burst (Flashy)
  Occasionally emits a radial burst of spark lines around the boid.
  Visual-only (rare): ~3% chance per frame per boid.
  @returns {Vector}
*/
if (typeof api !== 'undefined' && api && api.addDrawable && Math.random() < 0.03) {
  const x = boid.pos.x, y = boid.pos.y;
  const spokes = 8 + Math.floor(Math.random() * 8);
  const len = 10 + Math.random() * 24;
  const hue = (boid.hue + Math.floor(Math.random() * 30)) % 360;
  api.addDrawable((ctx) => {
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    for (let i = 0; i < spokes; i++) {
      const a = (i / spokes) * Math.PI * 2 + Math.random() * 0.2;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.cos(a) * len, y + Math.sin(a) * len);
      ctx.strokeStyle = 'hsla(' + hue + ', 100%, 70%, 0.22)';
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    ctx.restore();
  });
}
return new Vector();` },

          { id: 'glow-orb', name: 'Flash — Glow Orb', code: `/**
  Glow Orb (Flashy)
  Occasionally draws a soft glowing orb around the boid.
  Visual-only (rare): ~5% chance per frame per boid.
  @returns {Vector}
*/
if (typeof api !== 'undefined' && api && api.addDrawable && Math.random() < 0.05) {
  const x = boid.pos.x, y = boid.pos.y;
  const r = 10 + Math.random() * 18;
  const hue = boid.hue;
  api.addDrawable((ctx) => {
    const g = ctx.createRadialGradient(x, y, 0.1 * r, x, y, r);
    g.addColorStop(0, 'hsla(' + hue + ', 100%, 65%, 0.30)');
    g.addColorStop(1, 'hsla(' + hue + ', 100%, 65%, 0.00)');
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fillStyle = g;
    ctx.fill();
  });
}
return new Vector();` },

          { id: 'comet-flares', name: 'Flash — Comet Flares', code: `/**
  Comet Flares (Flashy)
  Fast boids occasionally produce a long, bright streak.
  Visual-only (speed-gated, rare): chance scales with speed.
  @returns {Vector}
*/
const speed = boid.vel.mag();
const chance = Math.min(0.08, speed / (boid.maxSpeed * 12)); // small chance
if (typeof api !== 'undefined' && api && api.addDrawable && Math.random() < chance) {
  const dir = boid.vel.clone().normalize();
  const x = boid.pos.x, y = boid.pos.y;
  const L = 40 + Math.random() * 50;
  const hue = (boid.hue + 10) % 360;
  api.addDrawable((ctx) => {
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.beginPath();
    ctx.moveTo(x - dir.x * L * 0.8, y - dir.y * L * 0.8);
    ctx.lineTo(x + dir.x * L * 0.1, y + dir.y * L * 0.1);
    ctx.strokeStyle = 'hsla(' + hue + ', 100%, 70%, 0.22)';
    ctx.lineWidth = 2.0;
    ctx.stroke();
    ctx.restore();
  });
}
return new Vector();` },

          { id: 'shockwave-rings', name: 'Flash — Shockwave Rings', code: `/**
  Shockwave Rings (Flashy)
  Occasionally draws concentric rings around the boid.
  Visual-only (rare): ~4% chance per frame per boid.
  @returns {Vector}
*/
if (typeof api !== 'undefined' && api && api.addDrawable && Math.random() < 0.04) {
  const x = boid.pos.x, y = boid.pos.y;
  const base = 8 + Math.random() * 10;
  const hue = (config.hue + 40) % 360;
  api.addDrawable((ctx) => {
    ctx.save();
    for (let i = 0; i < 3; i++) {
      ctx.beginPath();
      ctx.arc(x, y, base + i * 6, 0, Math.PI * 2);
      ctx.strokeStyle = 'hsla(' + hue + ', 100%, 70%, ' + (0.18 - i * 0.04) + ')';
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    ctx.restore();
  });
}
return new Vector();` },

          { id: 'twinkle-trails', name: 'Flash — Twinkle Trails', code: `/**
  Twinkle Trails (Flashy)
  Occasionally draws small star twinkles near the boid.
  Visual-only (rare): ~6% chance per frame per boid.
  @returns {Vector}
*/
if (typeof api !== 'undefined' && api && api.addDrawable && Math.random() < 0.06) {
  const x = boid.pos.x + (Math.random() - 0.5) * 10;
  const y = boid.pos.y + (Math.random() - 0.5) * 10;
  const s = 4 + Math.random() * 3;
  const hue = (boid.hue + 300) % 360;
  api.addDrawable((ctx) => {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(Math.random() * Math.PI);
    ctx.beginPath();
    ctx.moveTo(-s, 0); ctx.lineTo(0, -s); ctx.lineTo(s, 0); ctx.lineTo(0, s); ctx.closePath();
    ctx.strokeStyle = 'hsla(' + hue + ', 100%, 70%, 0.22)';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.restore();
  });
}
return new Vector();` },

          { id: 'sine-flow-field', name: 'Flow — Sine Field', code: `/**
  Sine Flow Field
  Steers along a static sine/cosine-based vector field.
  Occasionally draws tiny flow hints.
  @returns {Vector}
*/
const ax = boid.pos.x * 0.01;
const ay = boid.pos.y * 0.0125;
const angle = Math.sin(ay) * 1.2 + Math.cos(ax) * 0.8;
const dir = new Vector(Math.cos(angle), Math.sin(angle));
const desired = dir.mult(boid.maxSpeed * 0.85);
// occasional drawable hint
if (typeof api !== 'undefined' && api && api.addDrawable && Math.random() < 0.02) {
  const x = boid.pos.x, y = boid.pos.y;
  api.addDrawable((ctx) => { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + dir.x * 10, y + dir.y * 10); ctx.strokeStyle = 'hsla(' + (((config.hue+90)%360)) + ', 100%, 70%, 0.16)'; ctx.lineWidth = 1; ctx.stroke(); });
}
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.9);` },

          { id: 'twin-vortices', name: 'Flow — Twin Vortices', code: `/**
  Twin Vortices
  Swirl around the nearer of two vortices.
  @returns {Vector}
*/
const c1 = new Vector(gameState.width * 0.33, gameState.height * 0.5);
const c2 = new Vector(gameState.width * 0.67, gameState.height * 0.5);
const d1 = Vector.sub(c1, boid.pos), d2 = Vector.sub(c2, boid.pos);
const use = (d1.mag() < d2.mag()) ? d1 : d2;
if (use.mag() === 0) return new Vector();
const tang = new Vector(-use.y, use.x).normalize();
const desired = tang.mult(boid.maxSpeed * 0.9);
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.9);` },

          { id: 'edge-runner', name: 'Edge — Runner', code: `/**
  Edge Runner
  Near edges, run clockwise along the boundary.
  @returns {Vector}
*/
const m = 80; // margin
let dir2 = null;
if (boid.pos.y < m) dir2 = new Vector(1, 0);
else if (boid.pos.x > gameState.width - m) dir2 = new Vector(0, 1);
else if (boid.pos.y > gameState.height - m) dir2 = new Vector(-1, 0);
else if (boid.pos.x < m) dir2 = new Vector(0, -1);
if (!dir2) return new Vector();
const desired2 = dir2.mult(boid.maxSpeed * 0.8);
return Vector.sub(desired2, boid.vel).limit(boid.maxForce * 0.8);` },

          { id: 'trail-mesh', name: 'Trail — Mesh', code: `/**
  Trail Mesh
  Occasionally deposits into pheromone grid to form a mesh.
  @returns {Vector}
*/
if (typeof api !== 'undefined' && api && api.depositTrail && Math.random() < 0.18) {
  const speed = Math.max(0.2, boid.vel.mag());
  api.depositTrail(boid.pos.x, boid.pos.y, Math.min(2.0, 0.5 + speed * 0.2));
}
return new Vector();` },

          { id: 'lane-weave', name: 'Flow — Lane Weave', code: `/**
  Lane Weave
  Create horizontal lanes; alternate left/right drift by band.
  @returns {Vector}
*/
const band = Math.floor(boid.pos.y / 80) % 2;
const dir3 = band === 0 ? new Vector(1, 0.25) : new Vector(-1, -0.25);
const desired3 = dir3.normalize().mult(boid.maxSpeed * 0.8);
return Vector.sub(desired3, boid.vel).limit(boid.maxForce * 0.7);` },

          { id: 'binary-factions', name: 'Group — Binary Factions', code: `/**
  Binary Factions
  Boids split into two factions; seek same faction weakly, separate from others.
  @returns {Vector}
*/
if (boid._faction === undefined) boid._faction = (Math.random() < 0.5 ? 0 : 1);
let sameC = new Vector(), sameN = 0, oppC = new Vector(), oppN = 0;
const r = config.perceptionRadius;
for (const o of neighbors) {
  const d = Vector.dist(boid.pos, o.pos);
  if (d > 0 && d < r) {
    if (o._faction === boid._faction) { sameC.add(o.pos); sameN++; }
    else { oppC.add(o.pos); oppN++; }
  }
}
let steer = new Vector();
if (sameN) {
  sameC.div(sameN);
  const toward = Vector.sub(sameC, boid.pos).normalize().mult(boid.maxSpeed * 0.6);
  steer.add(Vector.sub(toward, boid.vel).limit(boid.maxForce * 0.6));
}
if (oppN) {
  oppC.div(oppN);
  const away = Vector.sub(boid.pos, oppC).normalize().mult(boid.maxSpeed * 0.6);
  steer.add(Vector.sub(away, boid.vel).limit(boid.maxForce * 0.8));
}
return steer;` },

          { id: 'nature-murmuration-spiral', name: 'Nature — Murmuration Spiral', code: `/**
  Murmuration Spiral
  Orbit gently around local centroid with a spiral bias, evoking starling murmurations.
  Visuals: Soft spiral arcs from the boid toward the centroid.
  @returns {Vector}
*/
let c = new Vector(); let n = 0; const R = config.perceptionRadius;
for (const o of neighbors){ const d=Vector.dist(boid.pos,o.pos); if(d>0&&d<R){ c.add(o.pos); n++; } }
if (!n) return new Vector(); c.div(n);
const toC = Vector.sub(c, boid.pos); const tang = new Vector(-toC.y, toC.x).normalize();
const desired = tang.mult(boid.maxSpeed*0.7).add(toC.normalize().mult(boid.maxSpeed*0.15));
if (typeof api!=='undefined'&&api&&api.addDrawable){ const x=boid.pos.x,y=boid.pos.y; const tx=tang.x, ty=tang.y; api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.moveTo(x,y); ctx.quadraticCurveTo(x+tx*10, y+ty*10, c.x, c.y); ctx.strokeStyle='hsla(' + (((config.hue+40)%360)) + ',100%,70%,0.16)'; ctx.lineWidth=1; ctx.stroke(); }); }
return Vector.sub(desired, boid.vel).limit(boid.maxForce*0.9);` },

          { id: 'nature-thermal-soaring', name: 'Nature — Thermal Soaring', code: `/**
  Thermal Soaring
  Circle in rising air columns (thermals); strength decreases with radius.
  Visuals: Concentric rings at thermal centers; tangent arrows for boids.
  @returns {Vector}
*/
const thermals=[ new Vector(gameState.width*0.3, gameState.height*0.5), new Vector(gameState.width*0.7, gameState.height*0.4) ];
let bestT=null, bestD=1e9; for(const t of thermals){ const d=Vector.dist(boid.pos,t); if(d<bestD){ bestD=d; bestT=t; } }
const toT=Vector.sub(bestT, boid.pos); const r=Math.max(1,toT.mag()); const tang=new Vector(-toT.y, toT.x).normalize();
const desired=tang.mult(boid.maxSpeed*Math.min(1,160/r)).add(toT.normalize().mult(boid.maxSpeed*0.12));
if (typeof api!=='undefined'&&api&&api.addDrawable){ api.addDrawable((ctx)=>{ for(let i=1;i<=3;i++){ ctx.beginPath(); ctx.arc(bestT.x,bestT.y, i*28, 0, Math.PI*2); ctx.strokeStyle='hsla(' + (((config.hue+60)%360)) + ',100%,70%,' + (0.14-i*0.03) + ')'; ctx.stroke(); } }); }
return Vector.sub(desired, boid.vel).limit(boid.maxForce*0.85);` },

          { id: 'nature-river-meander', name: 'Nature — River Meander', code: `/**
  River Meander
  Follow a 2D meandering flow field resembling river curves.
  Visuals: Short blue flow hints in local direction.
  @returns {Vector}
*/
const ax=boid.pos.x*0.006, ay=boid.pos.y*0.01; const ang=Math.sin(ax*2.0)+Math.cos(ay*1.5);
const dir=new Vector(Math.cos(ang), Math.sin(ang*0.6)).normalize();
const desired=dir.mult(boid.maxSpeed*0.8);
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.15){ const x=boid.pos.x,y=boid.pos.y; api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+dir.x*12,y+dir.y*12); ctx.strokeStyle='hsla(' + (((config.hue+200)%360)) + ',100%,70%,0.22)'; ctx.stroke(); }); }
return Vector.sub(desired, boid.vel).limit(boid.maxForce*0.8);` },

          { id: 'nature-phyllotaxis-orbit', name: 'Nature — Phyllotaxis Orbit', code: `/**
  Phyllotaxis Orbit
  Orbit center with golden-angle radial drift for sunflower-like patterns.
  Visuals: Golden angle spoke marker.
  @returns {Vector}
*/
const center=new Vector(gameState.width/2, gameState.height/2); const GA=2.399963229728653; // golden angle
const to=Vector.sub(boid.pos, center); const r=to.mag(); const tang=new Vector(-to.y, to.x).normalize();
const desired=tang.mult(boid.maxSpeed*0.8).add(to.normalize().mult(Math.sin(boid.pos.x*0.002+boid.pos.y*0.002)*0.2));
if (typeof api!=='undefined'&&api&&api.addDrawable){ const a=Math.atan2(to.y,to.x); const mark=new Vector(Math.cos(a+GA)*14, Math.sin(a+GA)*14); api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.moveTo(boid.pos.x, boid.pos.y); ctx.lineTo(boid.pos.x+mark.x, boid.pos.y+mark.y); ctx.strokeStyle='hsla(' + (((config.hue+20)%360)) + ',100%,70%,0.22)'; ctx.stroke(); }); }
return Vector.sub(desired, boid.vel).limit(boid.maxForce*0.8);` },

          { id: 'nature-pollen-drift', name: 'Nature — Pollen Drift', code: `/**
  Pollen Drift
  Gentle random drift with weak attraction to flower sources; leaves fine trails.
  Visuals: Tiny twinkle dots; soft trails via pheromones.
  @returns {Vector}
*/
const flowers=[ new Vector(gameState.width*0.2,gameState.height*0.7), new Vector(gameState.width*0.8,gameState.height*0.3) ];
let best=null, bestD=1e9; for(const f of flowers){ const d=Vector.dist(boid.pos,f); if(d<bestD){ bestD=d; best=f; } }
let desired=Vector.random2D().mult(boid.maxSpeed*0.3).add(Vector.sub(best,boid.pos).normalize().mult(boid.maxSpeed*0.3));
if (typeof api!=='undefined'&&api&&api.depositTrail){ api.depositTrail(boid.pos.x,boid.pos.y,0.4); }
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.15){ const x=boid.pos.x+(Math.random()-0.5)*6, y=boid.pos.y+(Math.random()-0.5)*6; api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.arc(x,y,1.6,0,Math.PI*2); ctx.fillStyle='hsla(' + (((config.hue+70)%360)) + ',100%,70%,0.28)'; ctx.fill(); }); }
return Vector.sub(desired,boid.vel).limit(boid.maxForce*0.7);` },

          { id: 'nature-predator-shadow', name: 'Nature — Predator Shadow', code: `/**
  Predator Shadow
  Avoid a soaring raptor shadow that circles the scene.
  Visuals: Predator circle marker; away arrows.
  @returns {Vector}
*/
const t=performance.now()/1500; const cx=gameState.width*0.5, cy=gameState.height*0.5; const pred=new Vector(cx+Math.cos(t)*220, cy+Math.sin(t*0.9)*180);
const away=Vector.sub(boid.pos, pred); const d=Math.max(1,away.mag());
const desired=away.normalize().mult(boid.maxSpeed*Math.min(1.2, 200/d));
if (typeof api!=='undefined'&&api&&api.addDrawable){ api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.arc(pred.x,pred.y,18,0,Math.PI*2); ctx.strokeStyle='hsla(' + (((config.hue+350)%360)) + ',100%,70%,0.22)'; ctx.stroke(); }); }
return Vector.sub(desired,boid.vel).limit(boid.maxForce*0.9);` },

          { id: 'nature-dipole-field', name: 'Nature — Magnetic Dipole Field', code: `/**
  Magnetic Dipole Field (Nature‑ish)
  Two poles induce curved field lines; boids follow tangents.
  Visuals: Curving field segments between poles.
  @returns {Vector}
*/
const p1=new Vector(gameState.width*0.35,gameState.height*0.5), p2=new Vector(gameState.width*0.65,gameState.height*0.5);
function fVec(c){ const d=Vector.sub(boid.pos,c); const r2=Math.max(25, d.x*d.x+d.y*d.y); return new Vector(-d.y/r2, d.x/r2); }
const dir=fVec(p1).add(fVec(p2)); const desired=dir.normalize().mult(boid.maxSpeed*0.8);
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.2){ const x=boid.pos.x,y=boid.pos.y; const u=dir.clone().normalize(); api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+u.x*14,y+u.y*14); ctx.strokeStyle='hsla(' + (((config.hue+180)%360)) + ',100%,70%,0.18)'; ctx.stroke(); }); }
return Vector.sub(desired,boid.vel).limit(boid.maxForce*0.85);` },

          { id: 'nature-surface-waves', name: 'Nature — Surface Waves', code: `/**
  Surface Waves
  Traveling sinusoidal waves modulate headings; evokes ripples on water.
  Visuals: Parallel wave bands across the canvas.
  @returns {Vector}
*/
const kx=0.02, ky=0.015, w=performance.now()/800; const ph=Math.sin(boid.pos.x*kx + boid.pos.y*ky + w);
const base=new Vector(1,0); const ort=new Vector(0,1);
const dir=new Vector(base.x + ort.x*ph, base.y + ort.y*ph).normalize();
const desired=dir.mult(boid.maxSpeed*0.8);
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.08){ api.addDrawable((ctx)=>{ ctx.strokeStyle='hsla(' + (((config.hue+190)%360)) + ',100%,70%,0.08)'; for(let y=40;y<gameState.height;y+=60){ ctx.beginPath(); for(let x=0;x<gameState.width;x+=12){ const py=y+6*Math.sin(x*kx + y*ky + w); if(x===0) ctx.moveTo(x,py); else ctx.lineTo(x,py); } ctx.stroke(); } }); }
return Vector.sub(desired,boid.vel).limit(boid.maxForce*0.8);` },

          { id: 'nature-bee-waggle', name: 'Nature — Bee Waggle', code: `/**
  Bee Waggle
  Near the hive, perform a figure‑8 waggle dance; otherwise travel to flowers.
  Visuals: Figure‑8 loop and hive marker.
  @returns {Vector}
*/
const hive=new Vector(gameState.width*0.15, gameState.height*0.6); const flowers=[ new Vector(gameState.width*0.8, gameState.height*0.3) ];
const toH=Vector.sub(hive,boid.pos); const d=toH.mag();
let desired;
if (d<120){ const t=performance.now()/600; const fx=Math.sin(t)*0.8, fy=Math.sin(t*2)*0.4; desired=new Vector(fx,fy).normalize().mult(boid.maxSpeed*0.7); }
else { const f=flowers[0]; desired=Vector.sub(f,boid.pos).normalize().mult(boid.maxSpeed*0.85); }
if (typeof api!=='undefined'&&api&&api.addDrawable){ api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.arc(hive.x,hive.y,10,0,Math.PI*2); ctx.strokeStyle='hsla(' + (((config.hue+50)%360)) + ',100%,70%,0.22)'; ctx.stroke(); }); }
return Vector.sub(desired,boid.vel).limit(boid.maxForce*0.8);` },

          { id: 'nature-coral-branch-trails', name: 'Nature — Coral Branch Trails', code: `/**
  Coral Branch Trails
  Deposit trails; move along gentle branching curves.
  Visuals: Faint branching trails forming coral‑like structures.
  @returns {Vector}
*/
const aX=Math.sin(boid.pos.y*0.01)*0.6, aY=Math.cos(boid.pos.x*0.01)*0.6; const dir=new Vector(aX, aY).normalize();
const desired=dir.mult(boid.maxSpeed*0.7);
if (typeof api!=='undefined'&&api&&api.depositTrail){ api.depositTrail(boid.pos.x,boid.pos.y,0.7); }
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.12){ const x=boid.pos.x,y=boid.pos.y; api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.moveTo(x,y); ctx.quadraticCurveTo(x+dir.y*6, y-dir.x*6, x+dir.x*10, y+dir.y*10); ctx.strokeStyle='hsla(' + (((config.hue+160)%360)) + ',100%,70%,0.18)'; ctx.stroke(); }); }
return Vector.sub(desired,boid.vel).limit(boid.maxForce*0.7);` },

          { id: 'nature-karman-vortex-street', name: 'Nature — Kármán Vortex Street', code: `/**
  Kármán Vortex Street (Behind Obstacles)
  Two obstacles shed alternating vortices that swirl boids downstream.
  Visuals: Obstacle markers; circular swirl hints.
  @returns {Vector}
*/
const obs=[ new Vector(gameState.width*0.35, gameState.height*0.5), new Vector(gameState.width*0.55, gameState.height*0.52) ];
let force=new Vector(); const t=performance.now()/900;
for(let i=0;i<obs.length;i++){ const o=obs[i]; const off=i%2===0?1:-1; const d=Vector.sub(boid.pos,o); const r=Math.max(1,d.mag()); const swirl=new Vector(-d.y, d.x).normalize().mult(off*Math.min(1,160/r)); force.add(swirl); }
const flow=new Vector(1,0).mult(0.4);
const desired=force.add(flow).normalize().mult(boid.maxSpeed*0.85);
if (typeof api!=='undefined'&&api&&api.addDrawable){ api.addDrawable((ctx)=>{ for(const o of obs){ ctx.beginPath(); ctx.arc(o.x,o.y,6,0,Math.PI*2); ctx.strokeStyle='hsla(' + (((config.hue+20)%360)) + ',100%,70%,0.22)'; ctx.stroke(); } }); }
return Vector.sub(desired,boid.vel).limit(boid.maxForce*0.85);` },

          { id: 'ai-pca-principal-flow', name: 'ML — PCA Principal Flow', code: `/**
  PCA Principal Flow
  Estimate local covariance from neighbor relative positions; steer along the first principal component.
  Visuals: Draw the principal axis around the boid.
  @returns {Vector}
*/
const pts = [];
for (const o of neighbors) pts.push([o.pos.x - boid.pos.x, o.pos.y - boid.pos.y]);
if (pts.length < 2) return new Vector();
let sx=0, sy=0; for (const p of pts){ sx+=p[0]; sy+=p[1]; }
sx/=pts.length; sy/=pts.length;
let sxx=0, sxy=0, syy=0; for (const p of pts){ const x=p[0]-sx, y=p[1]-sy; sxx+=x*x; sxy+=x*y; syy+=y*y; }
// Eigenvector of 2x2 covariance for largest eigenvalue
const tr = sxx+syy; const det = sxx*syy - sxy*sxy; const tmp = Math.sqrt(Math.max(0,tr*tr/4 - det));
const l1 = tr/2 + tmp; // top eigenvalue
let vx=1, vy=0; if (Math.abs(sxy) > 1e-6 || Math.abs(sxx - l1) > 1e-6) { vx = sxy; vy = l1 - sxx; }
const mag = Math.hypot(vx,vy)||1; vx/=mag; vy/=mag;
const dir = new Vector(vx, vy);
const desired = dir.mult(boid.maxSpeed*0.9);
if (typeof api!=='undefined'&&api&&api.addDrawable){ const x=boid.pos.x,y=boid.pos.y; api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.moveTo(x-vx*12,y-vy*12); ctx.lineTo(x+vx*12,y+vy*12); ctx.strokeStyle='hsla(' + (((config.hue+260)%360)) + ',100%,70%,0.22)'; ctx.lineWidth=1.2; ctx.stroke(); }); }
return Vector.sub(desired, boid.vel).limit(boid.maxForce*0.9);` },

          { id: 'ai-perceptron-boundary', name: 'ML — Perceptron Decision Boundary', code: `/**
  Perceptron Decision Boundary
  Classify sides of a line w·x + b = 0; steer toward positive side.
  Visuals: Draw the decision line and normal arrow.
  @returns {Vector}
*/
const w = new Vector(1, -0.6); const b = -0.3*gameState.width;
const x = new Vector(boid.pos.x, boid.pos.y);
const score = w.x*x.x + w.y*x.y + b;
const n = new Vector(w.x, w.y).normalize();
const desired = (score >= 0 ? n : n.clone().mult(-1)).mult(boid.maxSpeed*0.7);
if (typeof api!=='undefined'&&api&&api.addDrawable){ const p0=new Vector(0, (-b - w.x*0)/Math.max(1e-6,w.y)); const p1=new Vector(gameState.width, (-b - w.x*gameState.width)/Math.max(1e-6,w.y)); api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.strokeStyle='hsla(' + (((config.hue+180)%360)) + ',100%,70%,0.18)'; ctx.lineWidth=1; ctx.stroke(); const cx=boid.pos.x, cy=boid.pos.y; ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+n.x*14, cy+n.y*14); ctx.strokeStyle='hsla(' + (boid.hue) + ',100%,70%,0.22)'; ctx.stroke(); }); }
return Vector.sub(desired, boid.vel).limit(boid.maxForce*0.7);` },

          { id: 'ai-q-learning-trace', name: 'AI — Q-Learning Trace', code: `/**
  Q-Learning Trace (Heuristic)
  Treat pheromone as value; ascend its gradient (exploit) and lay an eligibility-like trace.
  Visuals: Green vector when ascending gradient; faint dots marking trace.
  @returns {Vector}
*/
const s=6; const pR=(x,y)=>{ const col=Math.floor(Math.max(0,Math.min(pheromones.cols-1,x/pheromones.cell))); const row=Math.floor(Math.max(0,Math.min(pheromones.rows-1,y/pheromones.cell))); return pheromones.grid[row*pheromones.cols+col]||0; };
const L=pR(boid.pos.x-s,boid.pos.y), Rv=pR(boid.pos.x+s,boid.pos.y), U=pR(boid.pos.x,boid.pos.y-s), D=pR(boid.pos.x,boid.pos.y+s);
const grad=new Vector(Rv-L, D-U);
let desired = grad.mag()>1e-6 ? grad.normalize().mult(boid.maxSpeed*0.9) : Vector.random2D().mult(boid.maxSpeed*0.5);
if (typeof api!=='undefined'&&api&&api.depositTrail) api.depositTrail(boid.pos.x, boid.pos.y, 0.6);
if (typeof api!=='undefined'&&api&&api.addDrawable){ const x=boid.pos.x,y=boid.pos.y; api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+desired.x*10,y+desired.y*10); ctx.strokeStyle='hsla(' + (((config.hue+90)%360)) + ',100%,70%,0.25)'; ctx.lineWidth=1.5; ctx.stroke(); }); }
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'novel-predator-prey-genesis', name: 'Novel — Predator–Prey Genesis', code: `/**
  Predator–Prey Genesis (Birth, Death, and Dazzling Choreography)
  A living system: predators hunt and convert energy, prey flee and multiply.
  Birth and death are explicit via api.spawnBoid() and api.destroyBoid().

  Parameters
  - predatorFrac: initial predator fraction (≈ 0.12)
  - predatorBoost: predator speed multiplier (≈ 1.25)
  - preyPanic: prey speed multiplier when a predator is near (≈ 1.15)

  Visual Language (no glow effects)
  - Capture: faceted starburst + expanding ripple rings, brief screen shake
  - Birth: nested petals and offset twin rings
  - Motion: crisp pursuit rays (predators), skitter arcs (prey), heat trails

  Mechanics
  - Energy: predators slowly starve; eating grants a burst; death on depletion.
            prey trickle-charge; reproduction consumes energy and splits momentum.
  - Spawn cap: honors config.maxBoids to prevent runaway growth.
  @returns {Vector}
*/
(function(){
  // 1) Initialize role/energy once per boid
  const frac = (typeof config.predatorFrac==='number') ? Math.max(0, Math.min(0.9, config.predatorFrac)) : 0.12;
  if (!boid._ppgInit) {
    boid._role = (Math.random() < frac) ? 'pred' : 'prey';
    boid._e = boid._role==='pred' ? 0.9 : 0.7; // energy
    boid._age = 0;
    boid._ppgInit = 1;
  }

  const pBoost = (typeof config.predatorBoost==='number') ? Math.max(0.5, Math.min(2.0, config.predatorBoost)) : 1.25;
  const panic = (typeof config.preyPanic==='number') ? Math.max(0.5, Math.min(2.0, config.preyPanic)) : 1.15;
  const role = boid._role || 'prey';
  boid._age++;

  // 2) Role-based neighborhood query
  let target = null;
  let nearestD = Infinity;
  for (const o of neighbors) {
    if (o === boid) continue;
    const d = Vector.dist(boid.pos, o.pos);
    if (role==='pred') {
      if ((o._role||'prey')==='prey' && d < nearestD) { nearestD = d; target = o; }
    } else {
      if ((o._role||'prey')==='pred' && d < nearestD) { nearestD = d; target = o; }
    }
  }

  // 3) Steering
  let desired = new Vector();
  const maxSpd = boid.maxSpeed;
  if (role==='pred') {
    // Pursue the nearest prey or wander toward mouse
    if (target) {
      desired = Vector.sub(target.pos, boid.pos).normalize().mult(maxSpd * pBoost);
      // Faceted pursuit ray
      if (typeof api!=='undefined'&&api&&api.addDrawable && Math.random() < 0.65) {
        const x=boid.pos.x,y=boid.pos.y; const v=desired.clone().normalize().mult(18);
        api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+v.x,y+v.y); ctx.strokeStyle='hsla('+(((config.hue+180)%360))+',100%,60%,0.28)'; ctx.lineWidth=1.5; ctx.stroke(); });
      }
    } else if (mouse && mouse.pos) {
      desired = Vector.sub(mouse.pos, boid.pos).normalize().mult(maxSpd * 0.8);
    }
    // Starvation pressure
    boid._e -= 0.0018 + 0.0008 * (desired.mag()/Math.max(1e-3, maxSpd));
  } else {
    // Flee the nearest predator or drift with subtle curvature
    if (target) {
      desired = Vector.sub(boid.pos, target.pos).normalize().mult(maxSpd * panic);
      // Skitter arc visualization
      if (typeof api!=='undefined'&&api&&api.addDrawable && Math.random() < 0.5) {
        const x=boid.pos.x,y=boid.pos.y; const v=desired.clone().normalize();
        api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.arc(x,y,10, Math.atan2(v.y,v.x)-0.8, Math.atan2(v.y,v.x)+0.2); ctx.strokeStyle='hsla('+((config.hue)%360)+',100%,70%,0.22)'; ctx.lineWidth=1; ctx.stroke(); });
      }
      // Sprint drains a bit
      boid._e -= 0.0007;
    } else {
      // Gentle meander
      const jitter = Vector.random2D().mult(0.4);
      desired = Vector.add(boid.vel.clone().normalize().mult(maxSpd*0.6), jitter).limit(maxSpd*0.7);
      boid._e += 0.0009; // graze
    }
  }

  // 4) Capture (pred close to prey)
  if (role==='pred' && target && nearestD < Math.max(10, boid.size + 6)) {
    // Energy transfer and visuals
    boid._e = Math.min(2.0, boid._e + 0.6);
    if (typeof api!=='undefined'&&api) {
      api.destroyBoid(target);
      // Dazzling starburst + ripple (no glow)
      const cx = (boid.pos.x + target.pos.x)/2, cy = (boid.pos.y + target.pos.y)/2; const hue=((config.hue+20)%360);
      api.addDrawable((ctx)=>{
        ctx.save(); ctx.translate(cx,cy);
        // Starburst
        ctx.strokeStyle='hsla('+hue+',100%,70%,0.35)';
        for(let i=0;i<12;i++){ const a=i*(Math.PI*2/12); const L=12+(i%3)*6; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(a)*L, Math.sin(a)*L); ctx.lineWidth=(i%3===0?2:1); ctx.stroke(); }
        // Ripple rings
        for(let r=10;r<=30;r+=10){ ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.strokeStyle='hsla('+((hue+260)%360)+',100%,60,'+(0.22-r*0.004)+')'; ctx.lineWidth=1; ctx.stroke(); }
        ctx.restore();
      });
      api.depositTrail(cx, cy, 2.0);
      api.shake(7, 180);
      // Small chance to bud a new predator
      if ((gameState.boids||[]).length < (config.maxBoids||1200) && Math.random()<0.25) {
        const dir = Vector.random2D().mult(1.5);
        api.spawnBoid(cx, cy, { role:'pred', hue:((config.hue+180)%360), vel:{x:dir.x,y:dir.y}, size: boid.size*0.95 });
      }
    }
  }

  // 5) Predator death on starvation (dust motes)
  if (role==='pred' && boid._e <= 0) {
    if (typeof api!=='undefined'&&api) {
      const x=boid.pos.x, y=boid.pos.y, hue=((config.hue+180)%360);
      api.addDrawable((ctx)=>{ for(let i=0;i<8;i++){ const a=Math.random()*Math.PI*2; const L=4+Math.random()*10; ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+Math.cos(a)*L, y+Math.sin(a)*L); ctx.strokeStyle='hsla('+hue+',100%,60%,0.18)'; ctx.lineWidth=1; ctx.stroke(); }});
      api.shake(4, 120);
      api.destroyBoid(boid);
    }
    return new Vector();
  }

  // 6) Prey reproduction when energized and not overcrowded
  if (role==='prey' && boid._e >= 1.2 && Math.random()<0.04) {
    // Local density check: count prey neighbors within small radius
    let closePrey = 0; for (const o of neighbors) { if ((o._role||'prey')==='prey' && Vector.dist(boid.pos,o.pos)<28) closePrey++; }
    if (closePrey < 6 && (gameState.boids||[]).length < (config.maxBoids||1200)) {
      const childVel = Vector.random2D().mult(boid.maxSpeed*0.3);
      const nx = boid.pos.x + childVel.x*2, ny = boid.pos.y + childVel.y*2;
      if (typeof api!=='undefined'&&api) {
        api.spawnBoid(nx, ny, { role:'prey', hue: ((config.hue+ (Math.random()*30-15))%360), vel:{x:childVel.x,y:childVel.y}, size: Math.max(3, boid.size*0.9) });
        // Birth visuals: twin rings + petals
        api.addDrawable((ctx)=>{
          ctx.strokeStyle='hsla('+((config.hue)%360)+',100%,70%,0.25)';
          for(let i=1;i<=2;i++){ ctx.beginPath(); ctx.arc(nx, ny, 6*i, 0, Math.PI*2); ctx.lineWidth=1; ctx.stroke(); }
          ctx.strokeStyle='hsla('+((config.hue+40)%360)+',100%,70%,0.22)';
          for(let i=0;i<5;i++){ const a=i*(2*Math.PI/5); ctx.beginPath(); ctx.arc(nx+Math.cos(a)*5, ny+Math.sin(a)*5, 3.6, a-0.7, a+0.7); ctx.stroke(); }
        });
        api.depositTrail(nx, ny, 1.2);
      }
      // Energy split between parent/child
      boid._e *= 0.6;
    }
  }

  // 7) A bit of trail for both roles
  if (typeof api!=='undefined'&&api&&api.depositTrail) {
    api.depositTrail(boid.pos.x, boid.pos.y, role==='pred' ? 0.6 : 0.3);
  }

  // 8) Compute steering force
  const steer = Vector.sub(desired, boid.vel).limit(boid.maxForce * (role==='pred' ? 1.0 : 0.9));
  // Subtle role tint
  boid.hue = role==='pred' ? ((config.hue+180)%360) : (config.hue%360);
  return steer;
})();` },

          { id: 'cs-bfs-frontier', name: 'CS — BFS Frontier Expansion', code: `/**
  BFS Frontier Expansion (Stylized)
  Expand a frontier from a source; steer outward in waves.
  Visuals: Concentric expanding rings and outward tick marks.
  @returns {Vector}
*/
const src=new Vector(gameState.width*0.15, gameState.height*0.15);
const to=Vector.sub(boid.pos, src); const d=to.mag();
const wave = Math.sin((performance.now()/400) + d/40);
const outward = to.normalize().mult(boid.maxSpeed*(0.6+0.3*Math.max(0,wave)));
if (typeof api!=='undefined'&&api&&api.addDrawable){ const x=src.x,y=src.y; const r=((performance.now()/12)%200); api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.strokeStyle='hsla(' + (((config.hue+40)%360)) + ',100%,70%,0.16)'; ctx.lineWidth=1; ctx.stroke(); }); }
return Vector.sub(outward, boid.vel).limit(boid.maxForce*0.9);` },

          { id: 'cs-pagerank-drift', name: 'CS — PageRank Drift', code: `/**
  PageRank Drift (Toy Graph)
  Drift among 4 anchors with transition probabilities; steer toward current anchor.
  Visuals: Graph nodes/edges with thickness hinting relative rank.
  @returns {Vector}
*/
if (!boid._prNode) boid._prNode = Math.floor(Math.random()*4);
const nodes=[
  new Vector(gameState.width*0.2, gameState.height*0.3),
  new Vector(gameState.width*0.5, gameState.height*0.2),
  new Vector(gameState.width*0.8, gameState.height*0.35),
  new Vector(gameState.width*0.6, gameState.height*0.75)
];
const T=[[0.05,0.6,0.25,0.1],[0.2,0.1,0.6,0.1],[0.15,0.15,0.1,0.6],[0.5,0.1,0.2,0.2]];
// occasional jump
if (Math.random()<0.02){ const r=Math.random(); let a=0, j=0; for(;j<4;j++){ a+=T[boid._prNode][j]; if (r<=a) break; } boid._prNode=j; }
const target=nodes[boid._prNode];
const desired=Vector.sub(target,boid.pos).normalize().mult(boid.maxSpeed*0.8);
if (typeof api!=='undefined'&&api&&api.addDrawable){ api.addDrawable((ctx)=>{ // draw graph
  const pr=[0.25,0.25,0.25,0.25]; // simple equal for visual
  ctx.lineWidth=1; for(let i=0;i<4;i++){ for(let j=0;j<4;j++){ if (T[i][j]>0.1){ ctx.beginPath(); ctx.moveTo(nodes[i].x,nodes[i].y); ctx.lineTo(nodes[j].x,nodes[j].y); ctx.strokeStyle='hsla(' + (((config.hue+200)%360)) + ',100%,70%,' + (0.08+0.12*T[i][j]) + ')'; ctx.stroke(); } } }
  for(let i=0;i<4;i++){ ctx.beginPath(); ctx.arc(nodes[i].x,nodes[i].y, 6+pr[i]*6,0,Math.PI*2); ctx.strokeStyle='hsla(' + (((config.hue+200)%360)) + ',100%,70%,0.22)'; ctx.stroke(); }
}); }
return Vector.sub(desired, boid.vel).limit(boid.maxForce*0.8);` },

          { id: 'physics-inverse-square-gravity', name: 'Physics — Inverse‑Square Gravity', code: `/**
  Inverse‑Square Gravity
  Single attractor at center; force ~ 1/r^2 toward the center with soft clamp near the core.
  Visuals: Faint concentric rings at the center.
  @returns {Vector}
*/
const Gc = new Vector(gameState.width/2, gameState.height/2);
const dG = Vector.sub(Gc, boid.pos); const r2 = Math.max(100, dG.x*dG.x + dG.y*dG.y);
const Fg = dG.normalize().mult(boid.maxSpeed * Math.min(1.2, 9000 / r2));
const desired = Fg;
if (typeof api!=='undefined'&&api&&api.addDrawable){ api.addDrawable((ctx)=>{ for(let i=1;i<=3;i++){ ctx.beginPath(); ctx.arc(Gc.x,Gc.y,i*40,0,Math.PI*2); ctx.strokeStyle='hsla(' + (((config.hue+120)%360)) + ',100%,70%,' + (0.12 - i*0.02) + ')'; ctx.lineWidth=1; ctx.stroke(); } }); }
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'physics-coulomb-gas', name: 'Physics — Coulomb Gas', code: `/**
  Coulomb Gas (Mutual Repulsion)
  Neighbors repel with 1/r potential; damped by distance. Produces gas-like spreading.
  Visuals: Short away arrows for close neighbors (occasional for clarity).
  @returns {Vector}
*/
let F = new Vector(); const R = config.perceptionRadius;
for (const o of neighbors){ const d = Vector.sub(boid.pos, o.pos); const r2 = d.x*d.x + d.y*d.y; if (r2>1 && r2 < R*R){ F.add(d.clone().div(Math.sqrt(r2)).div(Math.max(10, r2))); } }
let desired = F.normalize().mult(boid.maxSpeed*0.8);
if (typeof api!=='undefined'&&api&&api.addDrawable && Math.random()<0.08){ const x=boid.pos.x,y=boid.pos.y; api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+F.x*300, y+F.y*300); ctx.strokeStyle='hsla(' + (((config.hue+300)%360)) + ',100%,70%,0.18)'; ctx.lineWidth=1; ctx.stroke(); }); }
return Vector.sub(desired, boid.vel).limit(boid.maxForce*0.9);` },

          { id: 'physics-harmonic-grid', name: 'Physics — Harmonic Oscillator Grid', code: `/**
  Harmonic Oscillator Grid
  Each boid is pulled toward the nearest grid anchor with spring-like restoring force and damping.
  Visuals: Grid anchor dots and a line to the local anchor.
  @returns {Vector}
*/
const step=120; const ax=Math.round(boid.pos.x/step)*step; const ay=Math.round(boid.pos.y/step)*step; const anchor=new Vector(ax,ay);
const k=0.02, c=0.12; const x=Vector.sub(anchor, boid.pos); // displacement
const spring = x.mult(k*step); const damp = boid.vel.clone().mult(-c);
const desired = spring.add(damp).limit(boid.maxSpeed);
if (typeof api!=='undefined'&&api&&api.addDrawable){ api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.arc(anchor.x,anchor.y,3,0,Math.PI*2); ctx.fillStyle='hsla(' + (((config.hue+160)%360)) + ',100%,70%,0.9)'; ctx.fill(); ctx.beginPath(); ctx.moveTo(boid.pos.x,boid.pos.y); ctx.lineTo(anchor.x,anchor.y); ctx.strokeStyle='hsla(' + (((config.hue+160)%360)) + ',100%,70%,0.18)'; ctx.stroke(); }); }
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'physics-lorenz-drift', name: 'Physics — Lorenz Drift', code: `/**
  Lorenz Drift (Projected)
  Sample a Lorenz system derivative based on mapped canvas coords; steer along its direction.
  Visuals: Small orientation tick in derivative direction.
  @returns {Vector}
*/
const sx=10, sy=10; // scale
let xL = (boid.pos.x - gameState.width/2)/sx; let yL=(boid.pos.y - gameState.height/2)/sy; let zL = Math.sin(performance.now()/1500);
const sigma=10, rho=28, beta=8/3;
const dx = sigma*(yL - xL);
const dy = xL*(rho - zL) - yL;
// project to 2D
const dir = new Vector(dx, dy).normalize();
const desired = dir.mult(boid.maxSpeed*0.85);
if (typeof api!=='undefined'&&api&&api.addDrawable){ const x=boid.pos.x,y=boid.pos.y; api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+dir.x*12,y+dir.y*12); ctx.strokeStyle='hsla(' + (((config.hue+220)%360)) + ',100%,70%,0.2)'; ctx.stroke(); }); }
return Vector.sub(desired, boid.vel).limit(boid.maxForce*0.9);` },

          { id: 'physics-wave-interference', name: 'Physics — Wave Interference', code: `/**
  Wave Interference
  Two radial waves interfere; steer along gradient of the combined phase field.
  Visuals: Interference bands rendered sparsely for context.
  @returns {Vector}
*/
const c1=new Vector(gameState.width*0.3, gameState.height*0.5); const c2=new Vector(gameState.width*0.7, gameState.height*0.5);
const k=0.04, w=performance.now()/600;
function phase(c){ const r=Vector.dist(boid.pos,c); return Math.sin(k*r - w); }
const f = phase(c1) + phase(c2);
// approximate gradient via finite differences
const eps=2; const px = (Math.sin(k*Vector.dist(new Vector(boid.pos.x+eps,boid.pos.y),c1)-w)+Math.sin(k*Vector.dist(new Vector(boid.pos.x+eps,boid.pos.y),c2)-w)) - (Math.sin(k*Vector.dist(new Vector(boid.pos.x-eps,boid.pos.y),c1)-w)+Math.sin(k*Vector.dist(new Vector(boid.pos.x-eps,boid.pos.y),c2)-w));
const py = (Math.sin(k*Vector.dist(new Vector(boid.pos.x,boid.pos.y+eps),c1)-w)+Math.sin(k*Vector.dist(new Vector(boid.pos.x,boid.pos.y+eps),c2)-w)) - (Math.sin(k*Vector.dist(new Vector(boid.pos.x,boid.pos.y-eps),c1)-w)+Math.sin(k*Vector.dist(new Vector(boid.pos.x,boid.pos.y-eps),c2)-w));
const grad = new Vector(px, py).normalize();
const desired = grad.mult(boid.maxSpeed*0.8);
if (typeof api!=='undefined'&&api&&api.addDrawable && Math.random()<0.06){ api.addDrawable((ctx)=>{ ctx.strokeStyle='hsla(' + (((config.hue+190)%360)) + ',100%,70%,0.08)'; for(let x=0;x<gameState.width;x+=28){ ctx.beginPath(); for(let y=0;y<gameState.height;y+=8){ const r1=Math.sin(k*Math.hypot(x-c1.x,y-c1.y)-w), r2=Math.sin(k*Math.hypot(x-c2.x,y-c2.y)-w); const val=r1+r2; const yy=y+val*3; if (y===0) ctx.moveTo(x,yy); else ctx.lineTo(x,yy); } ctx.stroke(); } }); }
return Vector.sub(desired, boid.vel).limit(boid.maxForce*0.85);` },

          { id: 'physics-gyroscopic-precession', name: 'Physics — Gyroscopic Precession', code: `/**
  Gyroscopic Precession
  Velocity precesses (rotates) about a central torque; produces graceful arcs.
  Visuals: Ring marker at center; short orientation arc at boid.
  @returns {Vector}
*/
const C=new Vector(gameState.width/2, gameState.height/2); const r=Vector.sub(boid.pos,C);
const omega=0.04; // precession rate
const v=boid.vel.clone(); const rot=new Vector(-v.y, v.x).mult(omega);
const desired = v.add(rot).normalize().mult(boid.maxSpeed*0.9);
if (typeof api!=='undefined'&&api&&api.addDrawable){ api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.arc(C.x,C.y,10,0,Math.PI*2); ctx.strokeStyle='hsla(' + (((config.hue+40)%360)) + ',100%,70%,0.18)'; ctx.stroke(); const ang=Math.atan2(desired.y, desired.x); ctx.beginPath(); ctx.arc(boid.pos.x, boid.pos.y, 8, ang-0.4, ang+0.4); ctx.strokeStyle='hsla(' + (((config.hue+40)%360)) + ',100%,70%,0.22)'; ctx.stroke(); }); }
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'ai-genetic-drift', name: 'AI — Genetic Drift', code: `/**
  Genetic Drift (GA-Inspired)
  Occasional mutation of heading; selection bias toward faster neighbors.
  Visuals: Mutation spark and velocity trail.
  @returns {Vector}
*/
let dir = boid.vel.clone().normalize();
// mutation
if (Math.random()<0.02){ const a=(Math.random()-0.5)*0.8; const c=Math.cos(a), s=Math.sin(a); const nx=dir.x*c - dir.y*s, ny=dir.x*s + dir.y*c; dir.x=nx; dir.y=ny; if (typeof api!=='undefined'&&api&&api.addDrawable){ const x=boid.pos.x,y=boid.pos.y; api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.arc(x,y,5,0,Math.PI*2); ctx.strokeStyle='hsla(' + (((config.hue+10)%360)) + ',100%,70%,0.22)'; ctx.stroke(); }); } }
// selection toward fast neighbors
let best=null, bestSpd=-1; for (const o of neighbors){ const sp=o.vel.mag(); if (sp>bestSpd){ bestSpd=sp; best=o; } }
if (best){ const dv=best.vel.clone().normalize(); dir=dir.mult(0.7).add(dv.mult(0.3)).normalize(); }
const desired = dir.mult(boid.maxSpeed*0.85);
if (typeof api!=='undefined'&&api&&api.addDrawable){ const x=boid.pos.x,y=boid.pos.y; const back=boid.vel.clone().normalize().mult(-8); api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+back.x,y+back.y); ctx.strokeStyle='hsla(' + (boid.hue) + ',100%,70%,0.16)'; ctx.stroke(); }); }
return Vector.sub(desired, boid.vel).limit(boid.maxForce*0.8);` },

          { id: 'ml-dbscan-density', name: 'ML — DBSCAN Density Core', code: `/**
  DBSCAN Density Core
  If enough neighbors within eps, treat as core: pull toward local centroid; else wander.
  Visuals: Circle ring when core; centroid line.
  @returns {Vector}
*/
const eps = config.perceptionRadius*0.7; const minPts=6;
let cnt=0, c=new Vector();
for (const o of neighbors){ const d=Vector.dist(boid.pos,o.pos); if(d>0&&d<eps){ cnt++; c.add(o.pos); } }
if (cnt>=minPts){ c.div(cnt); const desired=Vector.sub(c,boid.pos).normalize().mult(boid.maxSpeed*0.7); if (typeof api!=='undefined'&&api&&api.addDrawable){ const x=boid.pos.x,y=boid.pos.y; api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.arc(x,y, eps*0.25,0,Math.PI*2); ctx.strokeStyle='hsla(' + (((config.hue+300)%360)) + ',100%,70%,0.16)'; ctx.stroke(); ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(c.x,c.y); ctx.strokeStyle='hsla(' + (((config.hue+300)%360)) + ',100%,70%,0.16)'; ctx.stroke(); }); } return Vector.sub(desired,boid.vel).limit(boid.maxForce*0.7);} else { return Vector.random2D().mult(boid.maxSpeed*0.3); }` },

          { id: 'ai-a-star-field', name: 'AI — A* Heuristic Field', code: `/**
  A* Heuristic Field (Stylized)
  Approximate A* via combining goal heuristic and sinusoidal obstacle costs.
  Visuals: Obstacle bands and direction arrow.
  @returns {Vector}
*/
const goal=new Vector(gameState.width*0.85, gameState.height*0.85);
const toG=Vector.sub(goal,boid.pos); const d=toG.mag(); const h=toG.clone().div(Math.max(1,d));
// synthetic obstacle cost gradient
const cx=Math.sin(boid.pos.y*0.02)*0.6, cy=Math.cos(boid.pos.x*0.02)*0.6;
const cost = new Vector(cx, cy);
const dirA = new Vector(h.x - cost.x, h.y - cost.y).normalize();
const desired = dirA.mult(boid.maxSpeed*0.85);
if (typeof api!=='undefined'&&api&&api.addDrawable){ api.addDrawable((ctx)=>{ // draw a few obstacle bands
  ctx.strokeStyle='hsla(' + (((config.hue+280)%360)) + ',100%,70%,0.08)';
  for (let y=40;y<gameState.height;y+=80){ ctx.beginPath(); for(let x=0;x<gameState.width;x+=20){ ctx.moveTo(x,y+10*Math.sin(x*0.02)); ctx.lineTo(x+10,y+10*Math.sin((x+10)*0.02)); } ctx.stroke(); }
}); }
return Vector.sub(desired,boid.vel).limit(boid.maxForce*0.9);` },

          { id: 'cs-bloom-filter-avoid', name: 'CS — Bloom Filter Avoidance', code: `/**
  Bloom Filter Avoidance (Toy)
  Hash grid cells; cells "set" in a Bloom filter are avoided by steering away.
  Visuals: Highlight hashed avoided cells.
  @returns {Vector}
*/
const cell = pheromones.cell || 16;
const col = Math.floor(boid.pos.x / cell);
const row = Math.floor(boid.pos.y / cell);

function h1(i, j) { return (i * 73856093 ^ j * 19349663) & 255; }
function h2(i, j) { return (i * 83492791 ^ j * 2971215073) & 255; }
function isSet(i, j) { return ((h1(i, j) & 1) && (h2(i, j) & 1)); }

let avoid = new Vector();
for (let dy = -1; dy <= 1; dy++) {
  for (let dx = -1; dx <= 1; dx++) {
    const ci = col + dx, rj = row + dy;
    if (isSet(ci, rj)) {
      const cx = ci * cell + cell / 2;
      const cy = rj * cell + cell / 2;
      const away = new Vector(boid.pos.x - cx, boid.pos.y - cy);
      const m = Math.max(1, away.mag());
      avoid.add(away.div(m));
    }
  }
}
const desired = avoid.mag() > 1e-6
  ? avoid.normalize().mult(boid.maxSpeed * 0.7)
  : new Vector();
if (typeof api !== 'undefined' && api && api.addDrawable) {
  api.addDrawable((ctx) => {
    ctx.fillStyle = 'hsla(' + (((config.hue + 320) % 360)) + ',100%,60%,0.06)';
    for (let y = 0; y < pheromones.rows; y++) {
      for (let x = 0; x < pheromones.cols; x++) {
        if (isSet(x, y)) ctx.fillRect(x * cell, y * cell, cell, cell);
      }
    }
  });
}
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.7);` },

          { id: 'ml-svm-margin', name: 'ML — SVM Margin Maximizer', code: `/**
  SVM Margin Maximizer (Toy)
  Two class centers define a separating hyperplane; steer along margin direction.
  Visuals: Decision boundary and margin bands.
  @returns {Vector}
*/
const a=new Vector(gameState.width*0.35, gameState.height*0.35), b=new Vector(gameState.width*0.65, gameState.height*0.65);
const wv=new Vector(b.x-a.x,b.y-a.y).normalize(); const n=new Vector(wv.y,-wv.x);
const mid=new Vector((a.x+b.x)/2,(a.y+b.y)/2);
const to=Vector.sub(boid.pos, mid); const side=Math.sign(to.x*n.x + to.y*n.y)||1;
const desired = n.mult(side*boid.maxSpeed*0.8);
if (typeof api!=='undefined'&&api&&api.addDrawable){ api.addDrawable((ctx)=>{ // boundary and margins
  const L=1000; ctx.beginPath(); ctx.moveTo(mid.x - n.y*L, mid.y + n.x*L); ctx.lineTo(mid.x + n.y*L, mid.y - n.x*L); ctx.strokeStyle='hsla(' + (((config.hue+150)%360)) + ',100%,70%,0.18)'; ctx.stroke();
  ctx.setLineDash([6,6]); ctx.beginPath(); ctx.moveTo(mid.x - n.y*L + wv.x*20, mid.y + n.x*L + wv.y*20); ctx.lineTo(mid.x + n.y*L + wv.x*20, mid.y - n.x*L + wv.y*20); ctx.stroke(); ctx.setLineDash([]);
}); }
return Vector.sub(desired, boid.vel).limit(boid.maxForce*0.85);` },

          { id: 'ml-pca-velocity', name: 'ML — PCA Velocity Consensus', code: `/**
  PCA Velocity Consensus
  PCA on neighbor velocities; align to first principal direction.
  Visuals: Velocity covariance axis at boid.
  @returns {Vector}
*/
const vs=[]; for(const o of neighbors){ vs.push([o.vel.x, o.vel.y]); }
if (vs.length<2) return new Vector();
let mx=0,my=0; for(const v of vs){ mx+=v[0]; my+=v[1]; } mx/=vs.length; my/=vs.length;
let vxx=0,vxy=0,vyy=0; for(const v of vs){ const x=v[0]-mx, y=v[1]-my; vxx+=x*x; vxy+=x*y; vyy+=y*y; }
const tr=vxx+vyy; const det=vxx*vyy - vxy*vxy; const t=Math.sqrt(Math.max(0,tr*tr/4 - det));
const l1=tr/2 + t; let ex=1, ey=0; if (Math.abs(vxy)>1e-6 || Math.abs(vxx-l1)>1e-6){ ex=vxy; ey=l1-vxx; }
const em=Math.hypot(ex,ey)||1; ex/=em; ey/=em; const pd=new Vector(ex,ey);
const desired=pd.mult(boid.maxSpeed*0.9);
if (typeof api!=='undefined'&&api&&api.addDrawable){ const x=boid.pos.x,y=boid.pos.y; api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.moveTo(x-ex*12, y-ey*12); ctx.lineTo(x+ex*12, y+ey*12); ctx.strokeStyle='hsla(' + (((config.hue+200)%360)) + ',100%,70%,0.22)'; ctx.stroke(); }); }
return Vector.sub(desired,boid.vel).limit(boid.maxForce);` },

          { id: 'ml-kmeans-colorize', name: 'ML — K-Means Colorize (Online)', code: `/**
  K-Means Colorize (Online)
  Maintains K moving centroids (online update). Each boid is assigned to the nearest
  centroid; the boid's hue is set by its cluster, and the centroid drifts toward the
  boid (streaming K-means). Optionally adds a slight cohesion toward the centroid.

  Visuals:
  - Centroid markers (colored by cluster hue)
  - Faint line from boid to its centroid (occasional, to avoid clutter)
  @returns {Vector}
*/
// Initialize shared state
if (!gameState._kmeans) {
  const K = 5;
  const centers = [];
  for (let i=0;i<K;i++) centers.push(new Vector(Math.random()*gameState.width, Math.random()*gameState.height));
  const hues = []; const base=(config.hue||200); for (let i=0;i<K;i++) hues.push((base + Math.round(i*360/K)) % 360);
  gameState._kmeans = { K, centers, hues, alpha: 0.05 };
}
const km = gameState._kmeans;
// Assign to nearest centroid
let cid = 0; let bestD2 = Infinity;
for (let i=0;i<km.K;i++) { const c = km.centers[i]; const dx = c.x - boid.pos.x, dy = c.y - boid.pos.y; const d2 = dx*dx + dy*dy; if (d2 < bestD2) { bestD2 = d2; cid = i; } }
// Online centroid update (move a little toward the boid)
const c = km.centers[cid]; c.x = c.x * (1 - km.alpha) + boid.pos.x * km.alpha; c.y = c.y * (1 - km.alpha) + boid.pos.y * km.alpha;
// Colorize boid by cluster hue
boid.hue = km.hues[cid];
// Mild cohesion toward centroid
const desired = Vector.sub(c, boid.pos).normalize().mult(boid.maxSpeed * 0.35);
// Visuals
if (typeof api !== 'undefined' && api && api.addDrawable) {
  if (Math.random() < 0.12) { const x=boid.pos.x,y=boid.pos.y; const cx=c.x, cy=c.y; const hue = km.hues[cid]; api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(cx,cy); ctx.strokeStyle='hsla(' + (hue) + ',100%,70%,0.14)'; ctx.lineWidth=1; ctx.stroke(); }); }
  if (Math.random() < 0.05) { const hue = km.hues[cid]; const cx=c.x, cy=c.y; api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.arc(cx,cy,6,0,Math.PI*2); ctx.strokeStyle='hsla(' + (hue) + ',100%,70%,0.22)'; ctx.lineWidth=1; ctx.stroke(); }); }
}
return Vector.sub(desired, boid.vel).limit(boid.maxForce*0.6);` },

          { id: 'ai-transformer-attention', name: 'AI — Transformer Self-Attention', code: `/**
  Transformer Self-Attention (Single-Head)
  Compute attention weights over neighbors based on velocity similarity (cosine).
  Steering follows a weighted combination of neighbor velocities.

  Visuals:
  - Draw lines to the top-3 attended neighbors; opacity encodes attention weight.
  - A small arc indicates the boid's current heading.
  @returns {Vector}
*/
const R = config.perceptionRadius;
const v = boid.vel.clone(); const vmag = Math.max(1e-6, v.mag());
const scored = [];
for (const o of neighbors) {
  const d = Vector.dist(boid.pos, o.pos); if (d === 0 || d > R) continue;
  const sim = (o.vel.x * v.x + o.vel.y * v.y) / (Math.max(1e-6, o.vel.mag()) * vmag); // cosine
  const score = sim * 2.0 - (d / R); // prefer similar and closer
  scored.push({ o, score });
}
if (!scored.length) return new Vector();
// Softmax with temperature
const temp = 0.8; const maxS = Math.max(...scored.map(s => s.score));
let Z = 0; for (const s of scored) { s.w = Math.exp((s.score - maxS) / temp); Z += s.w; }
for (const s of scored) s.w /= Z;
// Weighted combination of neighbor velocities
let target = new Vector(); for (const s of scored) {
  const dir = s.o.vel.clone().normalize(); target.add(dir.mult(s.w));
}
target.normalize().mult(boid.maxSpeed);
// Visualize top-3 attention edges
if (typeof api !== 'undefined' && api && api.addDrawable) {
  const top = scored.slice().sort((a,b)=>b.w-a.w).slice(0,3);
  const x=boid.pos.x,y=boid.pos.y;
  api.addDrawable((ctx)=>{
    for (const s of top) {
      ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(s.o.pos.x, s.o.pos.y);
      ctx.strokeStyle = 'hsla(' + (boid.hue) + ',100%,70%,' + (0.1 + 0.35*s.w).toFixed(3) + ')';
      ctx.lineWidth = 1; ctx.stroke();
    }
    // heading arc
    const ang = Math.atan2(boid.vel.y, boid.vel.x);
    ctx.beginPath(); ctx.arc(x,y,8,ang-0.5,ang+0.5);
    ctx.strokeStyle = 'hsla(' + (((config.hue+40)%360)) + ',100%,70%,0.22)'; ctx.lineWidth=1; ctx.stroke();
  });
}
return Vector.sub(target, boid.vel).limit(boid.maxForce);` },

          { id: 'ml-kmeans-centroids', name: 'ML — K-Means Centroids', code: `/**
  K-Means Centroids (Static Centers)
  Assign each boid to the nearest centroid and steer toward it.
  Centroids are placed deterministically on the canvas.

  Visuals:
  - Draw centroid markers and a faint line from boid to its nearest centroid.
  @returns {Vector}
*/
const C = [
  new Vector(gameState.width*0.25, gameState.height*0.35),
  new Vector(gameState.width*0.75, gameState.height*0.35),
  new Vector(gameState.width*0.5, gameState.height*0.7)
];
let bestC = null, bestD = Infinity;
for (const c of C) { const d = Vector.dist(boid.pos, c); if (d < bestD) { bestD = d; bestC = c; } }
if (!bestC) return new Vector();
const desired = Vector.sub(bestC, boid.pos).normalize().mult(boid.maxSpeed * 0.9);
if (typeof api !== 'undefined' && api && api.addDrawable) {
  const x=boid.pos.x,y=boid.pos.y;
  api.addDrawable((ctx)=>{
    // Centroids
    for (const c of C) { ctx.beginPath(); ctx.arc(c.x,c.y,6,0,Math.PI*2); ctx.strokeStyle='hsla(' + (((config.hue+100)%360)) + ',100%,70%,0.22)'; ctx.lineWidth=1.5; ctx.stroke(); }
    // Line to assigned centroid
    ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(bestC.x,bestC.y);
    ctx.strokeStyle = 'hsla(' + (boid.hue) + ',100%,70%,0.16)'; ctx.lineWidth=1; ctx.stroke();
  });
}
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.9);` },

          { id: 'ml-gaussian-mixture', name: 'ML — Gaussian Mixture Attraction', code: `/**
  Gaussian Mixture Attraction
  Two Gaussian "likelihood lobes" pull boids toward high-probability regions.
  Steering follows the gradient of the log-likelihood.

  Visuals:
  - Concentric contour rings around each Gaussian center.
  @returns {Vector}
*/
const c1 = new Vector(gameState.width*0.35, gameState.height*0.45);
const c2 = new Vector(gameState.width*0.65, gameState.height*0.55);
const s1 = 120, s2 = 90; // standard deviations
function gradGaussian(c, s) {
  const d = Vector.sub(c, boid.pos); const r2 = Math.max(1, d.x*d.x + d.y*d.y);
  const w = Math.exp(-r2 / (2*s*s));
  return d.mult(w / (s*s));
}
let g = gradGaussian(c1, s1).add(gradGaussian(c2, s2));
const desired = g.normalize().mult(boid.maxSpeed * 0.8);
if (typeof api !== 'undefined' && api && api.addDrawable) {
  api.addDrawable((ctx)=>{
    const centers = [[c1,s1], [c2,s2]];
    for (const [c, s] of centers) {
      for (let i=1;i<=3;i++) {
        ctx.beginPath(); ctx.arc(c.x,c.y,(s/3)*i,0,Math.PI*2);
        ctx.strokeStyle='hsla(' + (((config.hue+220)%360)) + ',100%,70%,' + (0.12 - i*0.02) + ')';
        ctx.lineWidth=1; ctx.stroke();
      }
    }
  });
}
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.7);` },

          { id: 'cs-swarm-dijkstra', name: 'CS — Swarm Dijkstra Heuristic', code: `/**
  Swarm Dijkstra Heuristic (Greedy)
  Move toward a goal while avoiding busy (high-pheromone) regions.
  Heuristic: steer along negative gradient of (distance-to-goal + lambda * pheromone).

  Visuals:
  - Goal marker, path arrow toward heuristic direction.
  @returns {Vector}
*/
const goal = new Vector(gameState.width*0.85, gameState.height*0.15);
// distance gradient
const dg = Vector.sub(goal, boid.pos);
const dist = Math.max(1, dg.mag());
const gdir = dg.clone().div(dist); // unit toward goal
// pheromone gradient (sample 4-neighborhood)
let phx = 0, phy = 0;
if (typeof api !== 'undefined' && api && api.depositTrail) {
  const s = 6;
  const pR = (x,y)=>{ const col=Math.floor(Math.max(0,Math.min(pheromones.cols-1, x/pheromones.cell))); const row=Math.floor(Math.max(0,Math.min(pheromones.rows-1, y/pheromones.cell))); return pheromones.grid[row*pheromones.cols+col]||0; };
  const pL = pR(boid.pos.x - s, boid.pos.y), pRr = pR(boid.pos.x + s, boid.pos.y);
  const pU = pR(boid.pos.x, boid.pos.y - s), pD = pR(boid.pos.x, boid.pos.y + s);
  phx = pL - pRr; phy = pU - pD; // negative gradient (more pheromone -> higher cost)
}
const lambda = 0.8;
const hdir = new Vector(gdir.x + lambda*phx, gdir.y + lambda*phy).normalize();
const desired = hdir.mult(boid.maxSpeed * 0.9);
if (typeof api !== 'undefined' && api && api.addDrawable) {
  const x=boid.pos.x,y=boid.pos.y;
  api.addDrawable((ctx)=>{
    // goal
    ctx.beginPath(); ctx.arc(goal.x, goal.y, 7, 0, Math.PI*2);
    ctx.strokeStyle='hsla(' + (((config.hue+140)%360)) + ',100%,70%,0.22)'; ctx.lineWidth=2; ctx.stroke();
    // arrow for heuristic
    ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x + hdir.x*20, y + hdir.y*20);
    ctx.strokeStyle='hsla(' + (boid.hue) + ',100%,70%,0.22)'; ctx.lineWidth=1.5; ctx.stroke();
  });
}
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.9);` },

          { id: 'ai-epsilon-greedy', name: 'AI — Epsilon-Greedy Explorer', code: `/**
  Epsilon-Greedy Explorer
  With probability eps, explore randomly; otherwise climb the pheromone gradient ("exploit").
  
  Visuals:
  - Blue jitter when exploring, red arrow when exploiting.
  @returns {Vector}
*/
const eps = 0.08;
let desired = new Vector();
let exploring = Math.random() < eps;
if (exploring) {
  desired = Vector.random2D().mult(boid.maxSpeed * 0.7);
} else {
  // follow pheromone gradient
  const s = 6;
  const pR = (x,y)=>{ const col=Math.floor(Math.max(0,Math.min(pheromones.cols-1, x/pheromones.cell))); const row=Math.floor(Math.max(0,Math.min(pheromones.rows-1, y/pheromones.cell))); return pheromones.grid[row*pheromones.cols+col]||0; };
  const L = pR(boid.pos.x - s, boid.pos.y), Rv = pR(boid.pos.x + s, boid.pos.y);
  const U = pR(boid.pos.x, boid.pos.y - s), D = pR(boid.pos.x, boid.pos.y + s);
  const grad = new Vector(Rv - L, D - U).normalize();
  desired = grad.mult(boid.maxSpeed * 0.9);
}
if (typeof api !== 'undefined' && api && api.depositTrail) {
  api.depositTrail(boid.pos.x, boid.pos.y, 0.8);
}
if (typeof api !== 'undefined' && api && api.addDrawable) {
  const x=boid.pos.x,y=boid.pos.y;
  api.addDrawable((ctx)=>{
    ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x + desired.x*8, y + desired.y*8);
    ctx.strokeStyle = exploring ? 'hsla(' + (((config.hue+220)%360)) + ',100%,70%,0.25)' : 'hsla(' + (((config.hue+20)%360)) + ',100%,70%,0.25)';
    ctx.lineWidth=1.5; ctx.stroke();
  });
}
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },
        ];

        // --- INITIALIZATION ---
        
        function init() {
            setupCanvas();
            const urlParams = getURLParams();
            config = {
                hue: 200, boidCount: 200, maxSpeed: 3, maxForce: 0.2,
                perceptionRadius: 50, visualizeQuadtree: true, debug: false,
                visualizeQuadtreeVisits: false,
                visualizeQuadtreeHot: false,
                cohesionWeight: 1.0, separationWeight: 1.5, alignmentWeight: 1.0, novelWeight: 1.2,
                visualDensity: 1.0,
                boidShape: 'triangle', boidSize: 10, boidSizeVariance: 2,
                header: "boid lab v1.2", subheader: "click and drag to interact",
                codePaneDock: 'left', // bottom | left | max
                codePaneLeftWidth: null,
                splitLeftRule: 'cohesion',
                splitRightRule: 'separation',
                // Safety cap for dynamic birth mechanics
                maxBoids: 1500,
                // Rules tab UI
                rulesShowDescriptions: true,
                // Preset controls — persisted via URL
                presetIncludeCore: true,
                presetCount: 4,
                presetTheme: 'any',
                presetBundle: 'none',
                perceptionBlend: true,
                perceptionBlendRate: 0.08,
                // Kuramoto Aurora defaults
                kuramotoK: 0.06,
                kuramotoOmegaBase: 0.02,
                kuramotoOmegaJitter: 0.01,
                // Predator–Prey defaults
                predatorFrac: 0.12,
                predatorBoost: 1.25,
                preyPanic: 1.15,
                rulesSelection: [],
                configTab: 'settings',
                ...urlParams
            };
            // Default rulesSelection to core rules if none provided via URL
            if (!Array.isArray(config.rulesSelection) || config.rulesSelection.length === 0) {
                config.rulesSelection = ['cohesion-core','alignment-core','separation-core','novel-core'];
                try { if (!Array.isArray(urlParams.rulesSelection)) { if (config.debug) updateAllURLParams(); else updateURL('rulesSelection', config.rulesSelection); } } catch(e){}
            }
            logConfig('Initial config:', config);
            userFunctions.push(
                { name: 'cohesion', weight: config.cohesionWeight, updateBoid: null },
                { name: 'separation', weight: config.separationWeight, updateBoid: null },
                { name: 'alignment', weight: config.alignmentWeight, updateBoid: null },
                { name: 'novel', weight: config.novelWeight, updateBoid: null }
            );
            setupUI();
            setupCodePane();
            // If requested via URL, apply rulesSelection first; else load bundles or random presets at startup
            if (typeof urlParams !== 'undefined' && urlParams) {
                if (Array.isArray(urlParams.rulesSelection) && urlParams.rulesSelection.length > 0) {
                    try { applyPresetSelection(urlParams.rulesSelection, !!config.presetIncludeCore); } catch (e) { console.error('Failed to apply rulesSelection from URL:', e); }
                } else {
                    // Bundle has precedence if provided
                    if (typeof urlParams.presetBundle === 'string' && urlParams.presetBundle !== 'none') {
                        loadPresetBundle(urlParams.presetBundle, !!config.presetIncludeCore);
                    } else {
                        const rp = urlParams.randomPresets;
                        if (rp !== undefined && rp !== false && rp !== 'false') {
                            let n = 4;
                            if (typeof rp === 'number') {
                                n = Math.max(1, Math.min(rulePresets.length, rp));
                            } else if (typeof urlParams.presetCount === 'number') {
                                n = Math.max(1, Math.min(rulePresets.length, urlParams.presetCount));
                            }
                            resetRulesWithPresets(n, !!config.presetIncludeCore, config.presetTheme || 'any');
                        }
                    }
                }
            }
            applyDockMode(config.codePaneDock);
            createBoids();
            window.addEventListener('resize', debounce(setupCanvas, 250));
            canvas.addEventListener('mousemove', e => {
                const px = mouse.pos.x, py = mouse.pos.y;
                mouse.prev.x = px; mouse.prev.y = py;
                mouse.pos.x = e.clientX; mouse.pos.y = e.clientY;
                // Simple smoothing on mouse velocity
                mouse.vel.x = (mouse.pos.x - px) * 0.6 + mouse.vel.x * 0.4;
                mouse.vel.y = (mouse.pos.y - py) * 0.6 + mouse.vel.y * 0.4;
            });
            canvas.addEventListener('mousedown', e => { mouse.down = true; });
            canvas.addEventListener('mouseup', e => { mouse.down = false; });
            canvas.addEventListener('touchstart', e => { mouse.down = true; updateTouchPos(e); }, {passive: false});
            canvas.addEventListener('touchend', e => { mouse.down = false; });
            canvas.addEventListener('touchmove', e => { e.preventDefault();
                const oldx = mouse.pos.x, oldy = mouse.pos.y;
                updateTouchPos(e);
                mouse.prev.x = oldx; mouse.prev.y = oldy;
                mouse.vel.x = (mouse.pos.x - oldx) * 0.6 + mouse.vel.x * 0.4;
                mouse.vel.y = (mouse.pos.y - oldy) * 0.6 + mouse.vel.y * 0.4;
            }, {passive: false});
            lastTime = performance.now();
            animate();
        }

        function updateTouchPos(e) {
            if (e.touches && e.touches.length > 0) {
                mouse.pos.x = e.touches[0].clientX;
                mouse.pos.y = e.touches[0].clientY;
            }
        }

        function setupCanvas() {
            gameState.width = canvas.width = window.innerWidth;
            gameState.height = canvas.height = window.innerHeight;
            // Pheromone grid sizing
            pheromones.cols = Math.max(1, Math.ceil(gameState.width / pheromones.cell));
            pheromones.rows = Math.max(1, Math.ceil(gameState.height / pheromones.cell));
            pheromones.grid = new Float32Array(pheromones.cols * pheromones.rows);
            // Quadtree heat grid sizing
            qtHeat.cols = Math.max(1, Math.ceil(gameState.width / qtHeat.cell));
            qtHeat.rows = Math.max(1, Math.ceil(gameState.height / qtHeat.cell));
            qtHeat.grid = new Float32Array(qtHeat.cols * qtHeat.rows);
            if (gameState.boids.length > 0) createBoids();
        }

        // --- UI SETUP ---
        function setupUI() {
            document.documentElement.style.setProperty('--hue', config.hue);
            document.querySelectorAll('.overlay-toggle').forEach(button => {
                button.addEventListener('click', () => {
                    const id = button.dataset.overlay;
                    const targetOverlay = id ? document.getElementById(id) : null;
                    if (!targetOverlay) return;
                    const isVisible = targetOverlay.classList.contains('visible');
                    document.querySelectorAll('.overlay').forEach(o => o.classList.remove('visible'));
                    if (!isVisible) targetOverlay.classList.add('visible');
                });
            });
            // Reset button
            const resetBtn = document.getElementById('reset-button');
            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
                    hardReset();
                });
            }
            document.querySelectorAll('.overlay').forEach(overlay => {
                const closeBtn = document.createElement('button');
                closeBtn.className = 'close-button';
                closeBtn.innerHTML = '&times;';
                closeBtn.onclick = () => overlay.classList.remove('visible');
                overlay.prepend(closeBtn);
            });
            const codePane = document.getElementById('code-pane');
            document.querySelector('.code-pane-toggle').addEventListener('click', (e) => {
                // Ignore clicks on dock control buttons inside the header
                if (e.target && e.target.classList.contains('dock-btn')) return;
                codePane.classList.toggle('visible');
                updateCodeOverlayButton();
                refreshEditors();
            });
            // Dock controls + split toggle
            document.querySelectorAll('.dock-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const action = e.currentTarget.getAttribute('data-action');
                    if (action === 'toggle-split') {
                        config.splitEnabled = !config.splitEnabled;
                        updateSplitModeUI();
                        if (!config.debug) updateURL('splitEnabled', !!config.splitEnabled);
                        return;
                    }
                    const mode = e.currentTarget.getAttribute('data-dock');
                    if (!mode) return;
                    config.codePaneDock = mode === 'max' ? 'max' : (mode === 'left' ? 'left' : 'bottom');
                    applyDockMode(config.codePaneDock);
                    if (config.debug) updateAllURLParams(); else updateURL('codePaneDock', config.codePaneDock);
                });
            });
            updateCodeOverlayButton();
            setupConfigUI();
            setupStatsUI();
            setupHelpUI();
            setupInfoUI();
        }

        function applyDockMode(mode) {
            const pane = document.getElementById('code-pane');
            pane.classList.remove('dock-bottom', 'dock-left', 'maximized');
            document.querySelectorAll('.dock-btn').forEach(b => b.classList.remove('active'));
            if (mode === 'left') {
                pane.classList.add('dock-left');
                document.querySelector('.dock-btn[data-dock="left"]').classList.add('active');
                if (config.codePaneLeftWidth && Number.isFinite(+config.codePaneLeftWidth)) {
                    pane.style.width = parseInt(config.codePaneLeftWidth, 10) + 'px';
                } else {
                    pane.style.width = '';
                }
                document.body.classList.remove('code-pane-maximized');
                updateSplitModeUI();
                setupLeftResizer();
            } else if (mode === 'max' || mode === 'maximized') {
                pane.classList.add('maximized', 'visible');
                document.querySelector('.dock-btn[data-dock="max"]').classList.add('active');
                document.body.classList.add('code-pane-maximized');
                updateSplitModeUI();
                teardownLeftResizer();
            } else {
                pane.classList.add('dock-bottom');
                document.querySelector('.dock-btn[data-dock="bottom"]').classList.add('active');
                document.body.classList.remove('code-pane-maximized');
                updateSplitModeUI();
                teardownLeftResizer();
            }
            updateCodeOverlayButton();
            // Keep collapsed state meaningful for bottom/left
            refreshEditors();
        }

        function setupLeftResizer() {
            const pane = document.getElementById('code-pane');
            const handle = pane.querySelector('.left-resizer');
            if (!handle) return;
            if (setupLeftResizer._bound) return; // bind once
            let dragging = false;
            let startX = 0;
            let startW = 0;
            // Tooltip element
            let tip = pane.querySelector('.left-resize-tooltip');
            if (!tip) {
                tip = document.createElement('div');
                tip.className = 'left-resize-tooltip';
                tip.textContent = '';
                pane.appendChild(tip);
            }
            const onMouseMove = (e) => {
                if (!dragging) return;
                const dx = e.clientX - startX;
                const newW = Math.max(320, Math.min(window.innerWidth * 0.9, startW + dx));
                pane.style.width = newW + 'px';
                config.codePaneLeftWidth = Math.round(newW);
                if (config.debug) updateAllURLParams(); else updateURL('codePaneLeftWidth', config.codePaneLeftWidth);
                refreshEditors();
                // Update tooltip
                tip.textContent = config.codePaneLeftWidth + ' px';
                tip.classList.add('visible');
            };
            const onMouseUp = () => {
                dragging = false;
                window.removeEventListener('mousemove', onMouseMove);
                window.removeEventListener('mouseup', onMouseUp);
                // Hide tooltip shortly after
                setTimeout(() => tip.classList.remove('visible'), 120);
            };
            handle.addEventListener('mousedown', (e) => {
                if (!pane.classList.contains('dock-left')) return;
                dragging = true;
                startX = e.clientX;
                startW = pane.getBoundingClientRect().width;
                window.addEventListener('mousemove', onMouseMove);
                window.addEventListener('mouseup', onMouseUp);
                e.preventDefault();
                // Show initial tooltip
                tip.textContent = Math.round(startW) + ' px';
                tip.classList.add('visible');
            });
            setupLeftResizer._bound = true;
        }
        function teardownLeftResizer() {
            setupLeftResizer._bound = false;
        }

        function updateSplitModeUI() {
            const pane = document.getElementById('code-pane');
            const splitBtn = document.querySelector('.dock-btn[data-action="toggle-split"]');
            const maximized = pane.classList.contains('maximized');
            const enabled = !!config.splitEnabled && maximized;
            pane.classList.toggle('split-on', enabled);
            if (splitBtn) splitBtn.classList.toggle('active', enabled);
            if (setupCodePane._split) {
                if (enabled) {
                    setupCodePane._split.showSplitUI(true);
                    setupCodePane._split.updateSplitMounts();
                } else {
                    setupCodePane._split.showSplitUI(false);
                    setupCodePane._split.unmountAll();
                }
            }
            refreshEditors();
        }

        function updateCodeOverlayButton() {
            const container = document.querySelector('.overlay-toggle-container');
            const pane = document.getElementById('code-pane');
            if (!container || !pane) return;
            const existing = document.getElementById('overlay-code-button');
            const isMax = document.body.classList.contains('code-pane-maximized');
            const needs = pane.classList.contains('dock-left') && !pane.classList.contains('visible') && !isMax;
            if (needs) {
                if (!existing) {
                    const btn = document.createElement('button');
                    btn.id = 'overlay-code-button';
                    btn.className = 'overlay-toggle';
                    btn.textContent = 'Code';
                    btn.title = 'Show code pane';
                    // Start in entering state for fade/slide in
                    btn.classList.add('entering');
                    btn.addEventListener('click', () => {
                        pane.classList.add('visible');
                        updateCodeOverlayButton();
                        refreshEditors();
                    });
                    container.prepend(btn);
                    // Trigger transition on next frame
                    requestAnimationFrame(() => requestAnimationFrame(() => btn.classList.remove('entering')));
                }
            } else if (existing) {
                // If overlays are visible, animate out. If maximized (container hidden), remove immediately.
                if (!document.body.classList.contains('code-pane-maximized')) {
                    if (!existing.dataset.removing) {
                        existing.dataset.removing = '1';
                        existing.classList.add('leaving');
                        const cleanup = () => {
                            existing.removeEventListener('transitionend', cleanup);
                            if (existing && existing.parentNode) existing.parentNode.removeChild(existing);
                        };
                        existing.addEventListener('transitionend', cleanup);
                        // Fallback removal in case transitionend doesn't fire
                        setTimeout(() => cleanup(), 300);
                    }
                } else {
                    existing.remove();
                }
            }
        }

        function refreshEditors() {
            Object.values(editors).forEach(editor => editor.refresh());
        }

        // Throttled UI indicator for rule fallback activity
        let _ruleStatusUITs = 0;
        function updateRuleStatusUI(force = false) {
            const now = performance.now();
            if (!force && now - _ruleStatusUITs < 200) return;
            _ruleStatusUITs = now;
            userFunctions.forEach(fn => {
                const active = !!(fn._fallbackUntil && now < fn._fallbackUntil);
                const tab = document.querySelector(`.tab-button[data-tab="${fn.name}"]`);
                if (tab) {
                    tab.classList.toggle('fallback-active', active);
                    if (active) {
                        tab.dataset.tip = `Fallback active for ${fn.name}`;
                    } else {
                        delete tab.dataset.tip;
                    }
                }
            });
        }

        function setupConfigUI() {
            const container = document.getElementById('config-overlay');
            container.innerHTML = '<h2>Configuration</h2>';
            // Simple tab bar for Settings and Rules
            const tabbar = document.createElement('div');
            tabbar.className = 'config-tab-bar';
            const btnSettings = document.createElement('button'); btnSettings.textContent = 'Settings'; btnSettings.className = 'config-tab active';
            const btnRules = document.createElement('button'); btnRules.textContent = 'Rules'; btnRules.className = 'config-tab';
            tabbar.appendChild(btnSettings); tabbar.appendChild(btnRules);
            container.appendChild(tabbar);
            // Wrappers for each tab
            const settingsWrap = document.createElement('div'); settingsWrap.id = 'config-settings-tab';
            const rulesWrap = document.createElement('div'); rulesWrap.id = 'config-rules-tab'; rulesWrap.style.display = 'none';
            container.appendChild(settingsWrap);
            container.appendChild(rulesWrap);
            const appendTarget = settingsWrap;
            // Tab switching
            const showTab = (which) => {
                const rulesOn = which === 'rules';
                settingsWrap.style.display = rulesOn ? 'none' : 'block';
                rulesWrap.style.display = rulesOn ? 'block' : 'none';
                btnSettings.classList.toggle('active', !rulesOn);
                btnRules.classList.toggle('active', rulesOn);
                config.configTab = rulesOn ? 'rules' : 'settings';
                if (config.debug) updateAllURLParams(); else updateURL('configTab', config.configTab);
            };
            btnSettings.addEventListener('click', () => showTab('settings'));
            btnRules.addEventListener('click', () => showTab('rules'));
            // Initialize tab from config
            if ((config.configTab||'settings') === 'rules') showTab('rules');
            const closeBtn = document.createElement('button');
            closeBtn.className = 'close-button';
            closeBtn.innerHTML = '&times;';
            closeBtn.onclick = () => container.classList.remove('visible');
            container.prepend(closeBtn);
            
            const createSlider = (id, label, min, max, step, value) => {
                const item = document.createElement('div');
                item.className = 'config-item';
                const valueSpan = document.createElement('span');
                valueSpan.textContent = ` ${Number(value).toFixed(2)}`;
                item.innerHTML = `<label for="${id}">${label}</label>`;
                const input = document.createElement('input');
                input.className = 'form-input';
                input.type = 'range'; input.id = id; input.min = min; input.max = max; input.step = step; input.value = value;
                input.addEventListener('input', e => {
                    const newValue = parseFloat(e.target.value);
                    config[id] = newValue;
                    valueSpan.textContent = ` ${newValue.toFixed(2)}`;
                    if (id.endsWith('Weight')) {
                        const fn = userFunctions.find(f => f.name === id.replace('Weight', ''));
                        if(fn) fn.weight = newValue;
                    }
                    if (config.debug) updateAllURLParams();
                });
                input.addEventListener('change', e => {
                    if (!config.debug) updateURL(id, parseFloat(e.target.value));
                    if (id === 'boidSize' || id === 'boidSizeVariance' || id === 'boidCount') {
                        createBoids();
                    }
                });
                item.appendChild(input);
                item.querySelector('label').appendChild(valueSpan);
                appendTarget.appendChild(item);
            };

            const createSelect = (id, label, options, value) => {
                const item = document.createElement('div');
                item.className = 'config-item';
                item.innerHTML = `<label for="${id}">${label}</label>`;
                const select = document.createElement('select');
                select.className = 'form-input';
                select.id = id;
                options.forEach(opt => {
                    const option = document.createElement('option');
                    option.value = opt;
                    option.textContent = opt.charAt(0).toUpperCase() + opt.slice(1);
                    if (opt === value) option.selected = true;
                    select.appendChild(option);
                });
                select.addEventListener('change', e => {
                    config[id] = e.target.value;
                    if (config.debug) updateAllURLParams(); else updateURL(id, e.target.value);
                });
                item.appendChild(select);
                appendTarget.appendChild(item);
            };

            // Toggle helper (needs to be defined before first use)
            const createToggle = (id, label, value) => {
                const item = document.createElement('div');
                item.innerHTML = `<label class="config-item"><input type="checkbox" id="${id}" ${value ? 'checked' : ''}> ${label}</label>`;
                item.querySelector('input').addEventListener('change', e => {
                    config[id] = e.target.checked;
                    logConfig(`${id} changed to ${config[id]}`);
                    if (config.debug) updateAllURLParams(); else updateURL(id, config[id]);
                });
                appendTarget.appendChild(item);
            };

            // Text input helper
            const createText = (id, label, value, placeholder = '') => {
                const item = document.createElement('div');
                item.className = 'config-item';
                item.innerHTML = `<label for="${id}">${label}</label>`;
                const input = document.createElement('input');
                input.className = 'form-input';
                input.type = 'text'; input.id = id; input.value = value || '';
                if (placeholder) input.placeholder = placeholder;
                input.addEventListener('input', e => {
                    config[id] = e.target.value;
                    if (config.debug) updateAllURLParams();
                });
                input.addEventListener('change', e => {
                    if (!config.debug) updateURL(id, e.target.value);
                });
                item.appendChild(input);
                appendTarget.appendChild(item);
            };

            createSlider('boidCount', 'Boid Count', 10, 1000, 10, config.boidCount);
            createSlider('boidSize', 'Boid Size', 2, 20, 1, config.boidSize);
            createSlider('boidSizeVariance', 'Size Variance', 0, 10, 0.5, config.boidSizeVariance);
            createSelect('boidShape', 'Boid Shape', ['triangle', 'circle', 'oval', 'ring'], config.boidShape);
            createSlider('maxSpeed', 'Max Speed', 0.5, 10, 0.1, config.maxSpeed);
            createSlider('maxForce', 'Max Force', 0.01, 1, 0.01, config.maxForce);
            createSlider('perceptionRadius', 'Perception', 10, 200, 1, config.perceptionRadius);
            createSlider('visualDensity', 'Visual Density', 0, 2, 0.05, config.visualDensity);
            // Labels
            createText('header', 'Header', (typeof config.header === 'string' ? config.header : ''), 'boid lab v1.2');
            createText('subheader', 'Subheader', (typeof config.subheader === 'string' ? config.subheader : ''), 'click and drag to interact');
            // Perception hue blend controls
            createToggle('perceptionBlend', 'Perception Hue Blend', config.perceptionBlend);
            createSlider('perceptionBlendRate', 'Perception Blend Rate', 0, 0.4, 0.01, config.perceptionBlendRate);
            // Quadtree visualization toggles
            createToggle('visualizeQuadtree', 'Show Quadtree Bounds', config.visualizeQuadtree);
            createToggle('visualizeQuadtreeVisits', 'Quadtree Query Visits (frame)', !!config.visualizeQuadtreeVisits);
            createToggle('visualizeQuadtreeHot', 'Quadtree Hot Regions (decayed)', !!config.visualizeQuadtreeHot);
            // Novel rule configuration sections (shown when selected)
            const novelWrap = document.createElement('div'); novelWrap.id='novel-config-sections'; appendTarget.appendChild(novelWrap);
            // Helper to toggle visibility based on active editor tab
            window.updateNovelConfigVisibility = function updateNovelConfigVisibility(){
                try {
                    const active = document.querySelector('.tab-button.active');
                    const activeName = active && active.dataset.tab;
                    const present = new Set((userFunctions||[]).map(u => u.name));
                    // Attempt to resolve the active preset by sanitized name
                    let activePreset = null;
                    try {
                        const sname = typeof sanitizeRuleName === 'function' ? activeName : activeName;
                        activePreset = (rulePresets||[]).find(p => {
                            const sn = (typeof sanitizeRuleName === 'function') ? sanitizeRuleName(p.name||'') : (p.name||'').toLowerCase();
                            return sn === sname;
                        }) || null;
                    } catch(e) { /* noop */ }
                    document.querySelectorAll('#novel-config-sections [data-novel]').forEach(sec => {
                        const key = sec.dataset.novel;
                        // Show if: active tab exists, rule is present, and panel key matches either
                        // the active tab name, or its preset id, or the sanitized preset name.
                        const matchId = activePreset && activePreset.id;
                        const matchName = activeName;
                        const matchSan = activePreset ? (typeof sanitizeRuleName === 'function' ? sanitizeRuleName(activePreset.name||'') : (activePreset.name||'').toLowerCase()) : null;
                        const shouldShow = !!(activeName && present.has(activeName) && (key === matchName || (matchId && key === matchId) || (matchSan && key === matchSan)));
                        sec.style.display = shouldShow ? '' : 'none';
                    });
                } catch(e){}
            };
            // Kuramoto Aurora config
            (function(){
                const sec = document.createElement('div'); sec.className='config-item'; sec.dataset.novel='novel-kuramoto-aurora'; sec.style.display='none';
                sec.innerHTML = '<h3>Novel — Kuramoto Aurora</h3>';
                novelWrap.appendChild(sec);
                // Inject sliders into this section
                const mount = (id,label,min,max,step,val)=>{ const item=document.createElement('div'); item.className='config-item'; item.innerHTML='<label for="'+id+'">'+label+'</label>'; const input=document.createElement('input'); input.type='range'; input.min=min; input.max=max; input.step=step; input.value=val; input.id=id; const vs=document.createElement('span'); vs.textContent=' '+Number(val).toFixed(3); input.addEventListener('input',(e)=>{ const v=parseFloat(e.target.value); config[id]=v; vs.textContent=' '+v.toFixed(3); if (config.debug) updateAllURLParams(); }); input.addEventListener('change',(e)=>{ if(!config.debug) updateURL(id, parseFloat(e.target.value));}); item.appendChild(input); item.querySelector('label').appendChild(vs); sec.appendChild(item); };
                mount('kuramotoK','Kuramoto K (Coupling)',0,0.2,0.005,config.kuramotoK);
                mount('kuramotoOmegaBase','Kuramoto ω Base',-0.1,0.1,0.001,config.kuramotoOmegaBase);
                mount('kuramotoOmegaJitter','Kuramoto ω Jitter',0,0.1,0.001,config.kuramotoOmegaJitter);
                // Randomize ω button
                const rand = document.createElement('button'); rand.className='bar-btn'; rand.textContent='Randomize ω'; rand.title='Randomize Kuramoto frequencies for all boids';
                rand.addEventListener('click', () => {
                    try {
                        const wBase = (typeof config.kuramotoOmegaBase === 'number') ? config.kuramotoOmegaBase : 0.02;
                        const wJit = (typeof config.kuramotoOmegaJitter === 'number') ? config.kuramotoOmegaJitter : 0.01;
                        (gameState.boids||[]).forEach(b => {
                            b._omega = (wBase + (Math.random()-0.5)*wJit) * (Math.random()<0.5?-1:1);
                        });
                        console.log('[Kuramoto] ω randomized for', (gameState.boids||[]).length, 'boids');
                    } catch(e) { console.warn('Kuramoto ω randomize failed:', e); }
                });
                sec.appendChild(rand);
            })();
            // Reaction-Diffusion config
            (function(){
                const sec = document.createElement('div'); sec.className='config-item'; sec.dataset.novel='novel-reaction-diffusion'; sec.style.display='none';
                sec.innerHTML = '<h3>Novel — Reaction‑Diffusion</h3>';
                novelWrap.appendChild(sec);
                const mount = (id,label,min,max,step,val)=>{ const item=document.createElement('div'); item.className='config-item'; item.innerHTML='<label for="'+id+'">'+label+'</label>'; const input=document.createElement('input'); input.type='range'; input.min=min; input.max=max; input.step=step; input.value=val; input.id=id; const vs=document.createElement('span'); vs.textContent=' '+Number(val).toFixed(3); input.addEventListener('input',(e)=>{ const v=parseFloat(e.target.value); config[id]=v; vs.textContent=' '+v.toFixed(3); if (config.debug) updateAllURLParams(); }); input.addEventListener('change',(e)=>{ if(!config.debug) updateURL(id, parseFloat(e.target.value));}); item.appendChild(input); item.querySelector('label').appendChild(vs); sec.appendChild(item); };
                // Defaults if not present
                if (typeof config.rdFeed!=='number') config.rdFeed=0.037;
                if (typeof config.rdKill!=='number') config.rdKill=0.06;
                if (typeof config.rdDiffusion!=='number') config.rdDiffusion=0.95;
                if (typeof config.rdDeposit!=='number') config.rdDeposit=0.55;
                mount('rdFeed','RD Feed (f)',0.0,0.1,0.001,config.rdFeed);
                mount('rdKill','RD Kill (k)',0.0,0.1,0.001,config.rdKill);
                mount('rdDiffusion','RD Diffusion',0.5,1.5,0.01,config.rdDiffusion);
                mount('rdDeposit','RD Deposit',0.0,1.0,0.01,config.rdDeposit);
            })();
            // Predator–Prey config
            (function(){
                const sec = document.createElement('div'); sec.className='config-item'; sec.dataset.novel='novel-predator-prey'; sec.style.display='none';
                sec.innerHTML = '<h3>Novel — Predator–Prey</h3>';
                novelWrap.appendChild(sec);
                const mount = (id,label,min,max,step,val)=>{ const item=document.createElement('div'); item.className='config-item'; item.innerHTML='<label for="'+id+'">'+label+'</label>'; const input=document.createElement('input'); input.type='range'; input.min=min; input.max=max; input.step=step; input.value=val; input.id=id; const vs=document.createElement('span'); vs.textContent=' '+Number(val).toFixed(3); input.addEventListener('input',(e)=>{ const v=parseFloat(e.target.value); config[id]=v; vs.textContent=' '+v.toFixed(3); if (config.debug) updateAllURLParams(); }); input.addEventListener('change',(e)=>{ if(!config.debug) updateURL(id, parseFloat(e.target.value));}); item.appendChild(input); item.querySelector('label').appendChild(vs); sec.appendChild(item); };
                mount('predatorFrac','Predator Fraction',0.0,0.5,0.01,config.predatorFrac);
                mount('predatorBoost','Predator Speed Boost',0.5,2.0,0.01,config.predatorBoost);
                mount('preyPanic','Prey Panic Speed',0.5,2.0,0.01,config.preyPanic);
            })();
            // Ensure initial visibility matches the active rule tab
            if (typeof updateNovelConfigVisibility === 'function') updateNovelConfigVisibility();
            // Kuramoto (Aurora Swarm) controls
            (function(){
                const hdr = document.createElement('div');
                hdr.className = 'config-item';
                hdr.innerHTML = '<h3>Kuramoto Aurora</h3>';
                appendTarget.appendChild(hdr);
            })();
            createSlider('kuramotoK', 'Kuramoto K (Coupling)', 0, 0.2, 0.005, config.kuramotoK);
            createSlider('kuramotoOmegaBase', 'Kuramoto ω Base', -0.1, 0.1, 0.001, config.kuramotoOmegaBase);
            createSlider('kuramotoOmegaJitter', 'Kuramoto ω Jitter', 0, 0.1, 0.001, config.kuramotoOmegaJitter);
            
            userFunctions.forEach(fn => {
                 const labelName = fn.displayName ? fn.displayName : (fn.name.charAt(0).toUpperCase() + fn.name.slice(1));
                 createSlider(`${fn.name}Weight`, `${labelName} Weight`, 0, 5, 0.1, config[`${fn.name}Weight`]);
            });

            // Random Presets section
            const randomBox = document.createElement('div'); randomBox.className='config-item';
            randomBox.innerHTML = `
                <h3>Random Presets</h3>
                <div class="config-note">Randomly selects N presets by the chosen theme and replaces the current rules. Use this for variety.</div>
                <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
                    <label>Count
                        <input type="number" id="preset-count" min="1" max="${Math.max(4, rulePresets.length)}" value="${(config.presetCount ?? 4)}"
                            style="width:72px;background:#333;color:#fff;border:1px solid #555;border-radius:4px;padding:4px 6px;">
                    </label>
                    <label>Theme
                        <select id="preset-theme" style="background:#333;color:#fff;border:1px solid #555;border-radius:4px;padding:4px 6px;">
                            <option value="any">Any (random)</option>
                            <option value="flash">Flash Pack</option>
                            <option value="mouse">Mouse</option>
                            <option value="click">Click</option>
                            <option value="drag">Drag</option>
                            <option value="physics">Physics</option>
                            <option value="flow">Flow</option>
                            <option value="orbit">Orbit</option>
                            <option value="edge">Edge</option>
                            <option value="trail">Trail</option>
                            <option value="color">Color</option>
                            <option value="group">Group</option>
                            <option value="speed">Speed</option>
                            <option value="templates">Templates</option>
                        </select>
                    </label>
                    <label><input type="checkbox" id="preset-include-core" ${config.presetIncludeCore ? 'checked' : ''}> Include core rules</label>
                    <button id="preset-reset-btn" style="background: var(--primary-color); color: #fff; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-family: var(--font-mono);">Reset with Presets</button>
                </div>
            `;
            appendTarget.appendChild(randomBox);
            // Bundle section
            const bundleBox = document.createElement('div'); bundleBox.className='config-item';
            bundleBox.innerHTML = `
                <h3>Preset Bundles</h3>
                <div class="config-note">Loads a curated set of specific presets (order preserved). Use this for repeatable demos.</div>
                <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
                    <label>Bundle
                        <select id="preset-bundle" style="background:#333;color:#fff;border:1px solid #555;border-radius:4px;padding:4px 6px;">
                            <option value="none">None</option>
                            <option value="ai-ml-pack">AI/ML Pack</option>
                            <option value="physics-pack">Physics Pack</option>
                            <option value="nature-pack">Nature Pack</option>
                            <option value="clustering-pack">Clustering Pack</option>
                            <option value="optimization-pack">Optimization Pack</option>
                            <option value="graphs-pack">Graphs Pack</option>
                            <option value="dimensionality-pack">Dimensionality Pack</option>
                            <option value="navigation-pack">Navigation Pack</option>
                            <option value="generative-pack">Generative Pack</option>
                            <option value="flash-showcase">Flash Showcase</option>
                            <option value="interaction-pack">Interaction Pack</option>
                            <option value="flow-pack">Flow Pack</option>
                            <option value="trail-pack">Trails Pack</option>
                            <option value="core-plus-flash">Core + Flash</option>
                        </select>
                    </label>
                    <label><input type="checkbox" id="bundle-include-core" ${config.presetIncludeCore ? 'checked' : ''}> Include core rules</label>
                    <button id="preset-bundle-btn" style="background: transparent; color: #fff; border: 1px solid #555; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-family: var(--font-mono);">Load Bundle</button>
                </div>
            `;
            appendTarget.appendChild(bundleBox);
            // Random listeners
            const presetBtn = randomBox.querySelector('#preset-reset-btn');
            presetBtn.addEventListener('click', () => {
                const countEl = randomBox.querySelector('#preset-count');
                const includeCoreEl = randomBox.querySelector('#preset-include-core');
                const themeEl = randomBox.querySelector('#preset-theme');
                const n = Math.max(1, Math.min(rulePresets.length, parseInt(countEl.value || '1', 10)));
                const includeCore = !!includeCoreEl.checked;
                const themeKey = (themeEl && themeEl.value) || 'any';
                config.presetCount = n;
                if (config.debug) updateAllURLParams(); else updateURL('presetCount', config.presetCount);
                resetRulesWithPresets(n, includeCore, themeKey);
            });
            // Bundle listeners
            const bundleBtn = bundleBox.querySelector('#preset-bundle-btn');
            if (bundleBtn) {
                bundleBtn.addEventListener('click', () => {
                    const bundleEl = bundleBox.querySelector('#preset-bundle');
                    const includeCoreEl = bundleBox.querySelector('#bundle-include-core');
                    const bundle = (bundleEl && bundleEl.value) || 'none';
                    if (bundle && bundle !== 'none') {
                        loadPresetBundle(bundle, !!includeCoreEl.checked);
                    }
                });
            }
            // Persist include-core (sync both checkboxes)
            const includeCoreEl1 = randomBox.querySelector('#preset-include-core');
            const includeCoreEl2 = bundleBox.querySelector('#bundle-include-core');
            function syncIncludeCore(val){ if (includeCoreEl1) includeCoreEl1.checked = val; if (includeCoreEl2) includeCoreEl2.checked = val; }
            if (includeCoreEl1) includeCoreEl1.addEventListener('change', e => { config.presetIncludeCore = !!e.target.checked; syncIncludeCore(config.presetIncludeCore); if (config.debug) updateAllURLParams(); else updateURL('presetIncludeCore', config.presetIncludeCore); });
            if (includeCoreEl2) includeCoreEl2.addEventListener('change', e => { config.presetIncludeCore = !!e.target.checked; syncIncludeCore(config.presetIncludeCore); if (config.debug) updateAllURLParams(); else updateURL('presetIncludeCore', config.presetIncludeCore); });
            // Persist preset count to URL
            const countEl = randomBox.querySelector('#preset-count');
            if (countEl) {
                countEl.value = String(config.presetCount ?? 4);
                countEl.addEventListener('change', e => {
                    const val = parseInt(e.target.value || '4', 10);
                    const n = Math.max(1, Math.min(rulePresets.length, isNaN(val) ? 4 : val));
                    config.presetCount = n;
                    if (config.debug) updateAllURLParams(); else updateURL('presetCount', config.presetCount);
                });
            }
            // Set and persist theme to URL
            const themeEl = randomBox.querySelector('#preset-theme');
            if (themeEl) {
                themeEl.value = (config.presetTheme || 'any');
                themeEl.addEventListener('change', e => {
                    config.presetTheme = e.target.value || 'any';
                    if (config.debug) updateAllURLParams(); else updateURL('presetTheme', config.presetTheme);
                });
            }
            // Set and persist bundle to URL
            const bundleEl = bundleBox.querySelector('#preset-bundle');
            if (bundleEl) {
                bundleEl.value = (config.presetBundle || 'none');
                bundleEl.addEventListener('change', e => {
                    config.presetBundle = e.target.value || 'none';
                    if (config.debug) updateAllURLParams(); else updateURL('presetBundle', config.presetBundle);
                });
            }
            
            createToggle('visualizeQuadtree', 'Show Quadtree', config.visualizeQuadtree);
            createToggle('debug', 'Debug Mode', config.debug);

            const colorItem = document.createElement('div');
            colorItem.className = 'config-item';
            colorItem.innerHTML = `<label for="hue">Theme Hue</label><input type="color" id="hue-picker" value="${hslToHex(config.hue, 100, 50)}">`;
            colorItem.querySelector('#hue-picker').addEventListener('input', e => {
                const hsl = hexToHsl(e.target.value);
                config.hue = hsl[0];
                document.documentElement.style.setProperty('--hue', config.hue);
                if (config.debug) updateAllURLParams(); else updateURL('hue', config.hue);
            });
            appendTarget.appendChild(colorItem);
            // --- Rules tab content ---
            // Grouped checklist of all presets, with apply controls
            rulesWrap.innerHTML = '';
            const rulesHeader = document.createElement('h3'); rulesHeader.textContent = 'Select Rules'; rulesWrap.appendChild(rulesHeader);
            // Search/filter input
            const searchRow = document.createElement('div'); searchRow.style.display='flex'; searchRow.style.gap='8px'; searchRow.style.marginBottom='6px';
            searchRow.innerHTML = `<input id="rules-search" class="form-input" type="text" placeholder="Search rules…" style="flex:1;">`;
            rulesWrap.appendChild(searchRow);
            const actions = document.createElement('div'); actions.style.display='flex'; actions.style.flexDirection='column'; actions.style.gap='6px';
            actions.innerHTML = `
                <div class="rules-actions-top" style="display:flex;align-items:center;gap:8px;">
                    <label><input type="checkbox" id="rules-show-desc" ${config.rulesShowDescriptions ? 'checked' : ''}> Show descriptions</label>
                </div>
                <div class="rules-actions-row">
                    <button id="rules-select-all" class="bar-btn">Select All</button>
                    <button id="rules-clear-all" class="bar-btn">Clear</button>
                    <button id="rules-apply" class="primary-btn">Apply Selection</button>
                </div>
            `;
            rulesWrap.appendChild(actions);
            const listHost = document.createElement('div'); listHost.style.display = 'grid'; listHost.style.gridTemplateColumns = 'repeat(auto-fit, minmax(240px, 1fr))'; listHost.style.gap='6px 12px'; rulesWrap.appendChild(listHost);
            // Initialize rulesSelection from current rules if empty
            if (!Array.isArray(config.rulesSelection) || config.rulesSelection.length === 0) {
                try {
                    const activeNames = new Set(userFunctions.map(u => u.name));
                    const inferred = rulePresets
                        .filter(p => activeNames.has((typeof sanitizeRuleName === 'function') ? sanitizeRuleName(p.name || '') : (p.name||'').toLowerCase()))
                        .map(p => p.id);
                    if (inferred.length) {
                        config.rulesSelection = inferred;
                        if (config.debug) updateAllURLParams(); else updateURL('rulesSelection', config.rulesSelection);
                    }
                } catch (e) { /* noop */ }
            }
            const groups = categorizePresets();
            // Helper to extract a short description from a preset code block
            function getPresetDescription(p){
                try {
                    const src = String(p.code || '');
                    const m = src.match(/\/\*\*([\s\S]*?)\*\//);
                    if (m) {
                        const raw = m[1].split('\n').map(s => s.replace(/^[\s\*]+/,'').trim());
                        // Drop empty, @-tags, generic headings, and underline-only lines
                        const headingRe = /^(concept|visuals|mechanics|parameters|returns|notes|behavior|config|steering|fields|model|pipeline|overview|summary)\s*:?$/i;
                        const underlineRe = /^[\-—–_\s]+$/;
                        const lines = raw.filter(line => line && !line.startsWith('@') && !/^Rule\s+API\b/i.test(line) && !headingRe.test(line) && !underlineRe.test(line));
                        if (lines.length > 1) return lines[1].replace(/\s+/g,' ').trim();
                        if (lines.length > 0) return lines[0].replace(/\s+/g,' ').trim();
                    }
                } catch(e) {}
                return '';
            }

            Object.keys(groups).forEach(group => {
                const box = document.createElement('div'); box.style.border='1px solid rgba(255,255,255,0.12)'; box.style.borderRadius='6px'; box.style.padding='6px 8px'; box.dataset.group='rules-box';
                // Group header with per-group actions
                const header = document.createElement('div'); header.style.display='flex'; header.style.alignItems='center'; header.style.gap='8px'; header.style.marginBottom='4px';
                const title = document.createElement('span'); title.textContent = group; title.style.color='var(--secondary-color)'; title.style.fontFamily='var(--font-mono)'; header.appendChild(title);
                const ctrls = document.createElement('div'); ctrls.style.display='flex'; ctrls.style.gap='6px'; ctrls.style.marginLeft='auto';
                const btnAll = document.createElement('button'); btnAll.className='bar-btn'; btnAll.textContent='All'; btnAll.title='Select all in group'; ctrls.appendChild(btnAll);
                const btnNone = document.createElement('button'); btnNone.className='bar-btn'; btnNone.textContent='None'; btnNone.title='Clear group'; ctrls.appendChild(btnNone);
                header.appendChild(ctrls);
                box.appendChild(header);
                // Items container with vertical spacing
                const items = document.createElement('div'); items.style.display='flex'; items.style.flexDirection='column'; items.style.rowGap='6px';
                groups[group].forEach(p => {
                    const id = `rules-${p.id}`;
                    const item = document.createElement('div'); item.dataset.preset='1'; item.style.display='flex'; item.style.flexDirection='column'; item.style.rowGap='2px'; item.style.padding='4px 0';
                    // Top row: checkbox + name
                    const label = document.createElement('label'); label.style.display='flex'; label.style.alignItems='center'; label.style.gap='6px'; label.style.fontSize='12px'; label.style.cursor='pointer'; label.dataset.name=(p.name||'').toLowerCase();
                    const cb = document.createElement('input'); cb.type='checkbox'; cb.value=p.id; cb.dataset.preset='1'; cb.id=id;
                    if (Array.isArray(config.rulesSelection) && config.rulesSelection.includes(p.id)) cb.checked = true;
                    cb.addEventListener('change', () => saveRulesSelection());
                    label.appendChild(cb);
                    const span = document.createElement('span'); span.textContent = p.name; label.appendChild(span);
                    item.appendChild(label);
                    // Description row
                    const descText = getPresetDescription(p);
                    const desc = document.createElement('div'); desc.className = 'rule-desc'; desc.textContent = descText; desc.style.color = '#bbb'; desc.style.fontSize='11px'; desc.style.marginLeft='22px'; desc.style.display = config.rulesShowDescriptions && descText ? '' : 'none';
                    desc.dataset.desc = (descText||'').toLowerCase();
                    item.appendChild(desc);

                    // Inline Novel configuration: always show under Novel rules
                    const isNovel = /^novel-/.test(p.id) || /^Novel\b/i.test(p.name||'');
                    if (isNovel) {
                        const cfg = document.createElement('div');
                        cfg.className = 'rule-inline-config';
                        cfg.style.marginLeft = '22px';
                        cfg.style.display = 'flex';
                        cfg.style.flexDirection = 'column';
                        cfg.style.gap = '2px';

                        // Small helper to add a slider line (label, range, live value)
                        const mount = (key, labelText, min, max, step, val) => {
                            const line = document.createElement('div');
                            line.className = 'config-item';
                            line.style.display = 'flex';
                            line.style.alignItems = 'center';
                            line.style.gap = '6px';
                            // Label
                            const lab = document.createElement('label');
                            lab.setAttribute('for', key);
                            lab.textContent = labelText;
                            lab.style.fontSize = '11px';
                            lab.style.minWidth = '150px';
                            // Input
                            const input = document.createElement('input');
                            input.type = 'range';
                            input.min = String(min);
                            input.max = String(max);
                            input.step = String(step);
                            input.value = String(val);
                            input.id = key;
                            input.style.flex = '1';
                            // Value span
                            const vs = document.createElement('span');
                            vs.textContent = ' ' + Number(val).toFixed(3);
                            vs.style.fontSize = '11px';
                            input.addEventListener('input', (e) => {
                                const v = parseFloat(e.target.value);
                                config[key] = v;
                                vs.textContent = ' ' + v.toFixed(3);
                                if (config.debug) updateAllURLParams();
                            });
                            input.addEventListener('change', (e) => {
                                if (!config.debug) updateURL(key, parseFloat(e.target.value));
                            });
                            line.appendChild(lab);
                            line.appendChild(input);
                            line.appendChild(vs);
                            cfg.appendChild(line);
                        };

                        // Per-rule config mounts
                        if (p.id === 'novel-kuramoto-aurora') {
                            const hdr = document.createElement('div'); hdr.textContent = 'Kuramoto Aurora'; hdr.style.color='#bbb'; hdr.style.fontSize='11px'; cfg.appendChild(hdr);
                            mount('kuramotoK', 'K (Coupling)', 0, 0.2, 0.005, (typeof config.kuramotoK==='number'?config.kuramotoK:0.05));
                            mount('kuramotoOmegaBase', 'ω Base', -0.1, 0.1, 0.001, (typeof config.kuramotoOmegaBase==='number'?config.kuramotoOmegaBase:0.02));
                            mount('kuramotoOmegaJitter', 'ω Jitter', 0, 0.1, 0.001, (typeof config.kuramotoOmegaJitter==='number'?config.kuramotoOmegaJitter:0.01));
                            const rand = document.createElement('button'); rand.className='bar-btn'; rand.textContent='Randomize ω'; rand.style.alignSelf='flex-start'; rand.addEventListener('click', () => {
                                try {
                                    const wBase = (typeof config.kuramotoOmegaBase === 'number') ? config.kuramotoOmegaBase : 0.02;
                                    const wJit = (typeof config.kuramotoOmegaJitter === 'number') ? config.kuramotoOmegaJitter : 0.01;
                                    (gameState.boids||[]).forEach(b => { b._omega = (wBase + (Math.random()-0.5)*wJit) * (Math.random()<0.5?-1:1); });
                                } catch(e) { /* noop */ }
                            });
                            cfg.appendChild(rand);
                        } else if (p.id === 'novel-reaction-diffusion') {
                            const hdr = document.createElement('div'); hdr.textContent = 'Reaction–Diffusion'; hdr.style.color='#bbb'; hdr.style.fontSize='11px'; cfg.appendChild(hdr);
                            if (typeof config.rdFeed!=='number') config.rdFeed=0.037;
                            if (typeof config.rdKill!=='number') config.rdKill=0.06;
                            if (typeof config.rdDiffusion!=='number') config.rdDiffusion=0.95;
                            if (typeof config.rdDeposit!=='number') config.rdDeposit=0.55;
                            mount('rdFeed','Feed (f)',0.0,0.1,0.001,config.rdFeed);
                            mount('rdKill','Kill (k)',0.0,0.1,0.001,config.rdKill);
                            mount('rdDiffusion','Diffusion',0.5,1.5,0.01,config.rdDiffusion);
                            mount('rdDeposit','Deposit',0.0,1.0,0.01,config.rdDeposit);
                        } else if (p.id === 'novel-predator-prey') {
                            const hdr = document.createElement('div'); hdr.textContent = 'Predator–Prey'; hdr.style.color='#bbb'; hdr.style.fontSize='11px'; cfg.appendChild(hdr);
                            mount('predatorFrac','Predator Fraction',0.0,0.5,0.01,(typeof config.predatorFrac==='number'?config.predatorFrac:0.15));
                            mount('predatorBoost','Speed Boost',0.5,2.0,0.01,(typeof config.predatorBoost==='number'?config.predatorBoost:1.3));
                            mount('preyPanic','Prey Panic',0.5,2.0,0.01,(typeof config.preyPanic==='number'?config.preyPanic:1.1));
                        }
                        item.appendChild(cfg);
                    }
                    items.appendChild(item);
                });
                box.appendChild(items);
                // Per-group listeners
                btnAll.addEventListener('click', () => { items.querySelectorAll('input[type="checkbox"][data-preset]').forEach(cb => { if (cb.offsetParent !== null) cb.checked = true; }); saveRulesSelection(); });
                btnNone.addEventListener('click', () => { items.querySelectorAll('input[type="checkbox"][data-preset]').forEach(cb => { if (cb.offsetParent !== null) cb.checked = false; }); saveRulesSelection(); });
                listHost.appendChild(box);
            });
            // Search filtering
            const searchInput = rulesWrap.querySelector('#rules-search');
            const filterRules = (q) => {
                const qq = (q||'').toLowerCase();
                const boxes = Array.from(listHost.querySelectorAll('[data-group="rules-box"]'));
                boxes.forEach(box => {
                    let visibleCount = 0;
                    box.querySelectorAll('div[data-preset] > label').forEach(label => {
                        const nm = label.dataset.name || '';
                        const desc = label.nextSibling && label.nextSibling.classList && label.nextSibling.classList.contains('rule-desc') ? (label.nextSibling.dataset.desc||'') : '';
                        const show = !qq || nm.includes(qq) || desc.includes(qq);
                        const item = label.parentElement;
                        item.style.display = show ? '' : 'none';
                        if (show) visibleCount++;
                    });
                    box.style.display = visibleCount ? '' : 'none';
                });
            };
            const debounceFilter = debounce(() => filterRules(searchInput.value), 120);
            searchInput.addEventListener('input', debounceFilter);
            // Show/hide descriptions
            const showDescCb = rulesWrap.querySelector('#rules-show-desc');
            if (showDescCb) {
                showDescCb.addEventListener('change', (e) => {
                    config.rulesShowDescriptions = !!e.target.checked;
                    rulesWrap.querySelectorAll('.rule-desc').forEach(el => {
                        el.style.display = (config.rulesShowDescriptions && (el.textContent||'').trim()) ? '' : 'none';
                    });
                    if (config.debug) updateAllURLParams(); else updateURL('rulesShowDescriptions', config.rulesShowDescriptions);
                });
            }
            // Rules tab actions
            rulesWrap.querySelector('#rules-select-all').addEventListener('click', () => {
                rulesWrap.querySelectorAll('input[type="checkbox"][data-preset]').forEach(cb => cb.checked = true);
                saveRulesSelection();
            });
            rulesWrap.querySelector('#rules-clear-all').addEventListener('click', () => {
                rulesWrap.querySelectorAll('input[type="checkbox"][data-preset]').forEach(cb => cb.checked = false);
                saveRulesSelection();
            });
            rulesWrap.querySelector('#rules-apply').addEventListener('click', () => {
                const ids = Array.from(rulesWrap.querySelectorAll('input[type="checkbox"][data-preset]:checked')).map(el => el.value);
                applyPresetSelection(ids, !!config.presetIncludeCore);
            });
            function saveRulesSelection() {
                const ids = Array.from(rulesWrap.querySelectorAll('input[type="checkbox"][data-preset]:checked')).map(el => el.value);
                config.rulesSelection = ids;
                if (config.debug) updateAllURLParams(); else updateURL('rulesSelection', config.rulesSelection);
            }
        }
        
        function setupStatsUI() {
            const container = document.getElementById('stats-overlay');
            container.innerHTML = `
                <button class="close-button">&times;</button>
                <h2>Statistics</h2>
                <p>Particle Count: <span id="particle-count">0</span></p>
                <p>FPS: <span id="fps-counter">0</span></p>
                <div><canvas id="fps-chart" height="80"></canvas></div>
                <p>Update Time: <span id="update-time">0.00</span> ms</p>
                <p>(Mean: <span id="update-time-mean">0.00</span>, StdDev: <span id="update-time-stddev">0.00</span>)</p>
                <div><canvas id="update-time-chart" height="80"></canvas></div>
                <p>Drawables/Frame: <span id="drawables-count">0</span></p>
                <div><canvas id="drawables-chart" height="80"></canvas></div>
                <h3>Quadtree</h3>
                <p>Nodes: <span id="qt-nodes">0</span> (Leaves: <span id="qt-leaves">0</span>)</p>
                <p>Max Depth: <span id="qt-depth">0</span> | Avg Leaf Fill: <span id="qt-avgfill">0.0</span></p>
                <p>Queries/Frame: <span id="qt-queries">0</span> | Avg Nodes/Query: <span id="qt-avgnodes">0.0</span> (Max: <span id="qt-maxnodes">0</span>)</p>
                <p>Checks: intersects <span id="qt-intersects">0</span>, points <span id="qt-pointtests">0</span></p>
                <div><canvas id="qt-avgnodes-chart" height="80"></canvas></div>
                <h3>Flock Coherence</h3>
                <div class="chart-container"><canvas id="polar-spiral-chart"></canvas></div>
                <h3>Mean Direction</h3>
                <div class="chart-container">
                    <canvas id="mean-polar-chart"></canvas>
                    <div class="chart-toggle">
                        <label><input type="checkbox" id="show-stdev-bands" checked>Show StdDev Bands</label>
                    </div>
                </div>
            `;
            container.querySelector('.close-button').onclick = () => container.classList.remove('visible');
            
            charts.fpsChart = new Chart(document.getElementById('fps-chart').getContext('2d'), {
                type: 'line',
                data: { labels: Array(50).fill(''), datasets: [{ label: 'FPS', data: Array(50).fill(0), borderColor: `hsl(${config.hue}, 100%, 50%)`, borderWidth: 1, pointRadius: 0, tension: 0.4 }] },
                options: { scales: { y: { beginAtZero: true, max: 70 } } }
            });

            charts.updateTimeChart = new Chart(document.getElementById('update-time-chart').getContext('2d'), {
                type: 'line',
                data: { labels: Array(50).fill(''), datasets: [{ label: 'Update Time (ms)', data: Array(50).fill(0), borderColor: `hsl(${(config.hue + 120) % 360}, 100%, 50%)`, borderWidth: 1, pointRadius: 0, tension: 0.4 }] },
                options: { scales: { y: { beginAtZero: true } } }
            });

            charts.drawablesChart = new Chart(document.getElementById('drawables-chart').getContext('2d'), {
                type: 'line',
                data: { labels: Array(50).fill(''), datasets: [{ label: 'Drawables / Frame', data: Array(50).fill(0), borderColor: `hsl(${(config.hue + 240) % 360}, 100%, 50%)`, borderWidth: 1, pointRadius: 0, tension: 0.4 }] },
                options: { scales: { y: { beginAtZero: true } } }
            });

            charts.qtAvgNodesChart = new Chart(document.getElementById('qt-avgnodes-chart').getContext('2d'), {
                type: 'line',
                data: { labels: Array(50).fill(''), datasets: [{ label: 'Avg Nodes per Query', data: Array(50).fill(0), borderColor: `hsl(${(config.hue + 30) % 360}, 100%, 60%)`, borderWidth: 1, pointRadius: 0, tension: 0.4 }] },
                options: { scales: { y: { beginAtZero: true } } }
            });

            charts.polarCtx = document.getElementById('polar-spiral-chart').getContext('2d');
            charts.meanPolarCtx = document.getElementById('mean-polar-chart').getContext('2d');
            charts.showStdDevBands = document.getElementById('show-stdev-bands');
        }
        
        function setupHelpUI() {
            const container = document.getElementById('help-overlay');
            const urlBase = window.location.pathname;
            container.innerHTML = `
                <button class="close-button">&times;</button>
                <h2>Boids Simulation</h2>
                <p>This is an interactive simulation of flocking behavior, inspired by Craig Reynolds' Boids algorithm.</p>

                <h3>Editors</h3>
                <p>The code pane hosts live-editable rule functions. Changes hot-reload with a brief success/error flash on the active tab.</p>
                <ul>
                    <li><b>Docking</b>: <code>Code</code> toggles visibility. Use the icons to dock <code>bottom</code>, <code>left</code>, or <code>maximize</code>.</li>
                    <li><b>Left dock</b>: Drag the thin right-edge handle to resize; width persists. A temporary <code>Code</code> button appears near overlays when hidden.</li>
                    <li><b>Split view</b>: In maximized mode, toggle the two‑pane view and choose which rules appear left/right via the dropdowns.</li>
                    <li><b>Tabs</b>: Each rule has a tab. Runtime errors briefly enable a small red dot (fallback) on the tab; the rule outputs zero force until it stabilizes.</li>
                    <li><b>Editor toolbar</b>: Preset dropdown + <code>Fill</code> (replace editor with preset), <code>Rename</code>, <code>Delete</code>, <code>New</code> (from selected preset).</li>
                    <li><b>Autocomplete</b>: Press <code>Ctrl-Space</code> for hints including in‑scope names (Vector, boid, gameState, mouse, config, api, …).</li>
                </ul>

                <h3>Rules</h3>
                <ul>
                    <li><b>Signature</b>: <code>function rule(boid, gameState, neighbors, config, mouse, Vector, api) ⇒ Vector</code>. Return a steering vector each frame.</li>
                    <li><b>Weights</b>: Rule contributions are scaled by sliders in <code>Config → Settings</code> (e.g., <code>cohesionWeight</code>). New rules add their own weight.</li>
                    <li><b>Order</b>: Rules execute in the order of tabs. Rename keeps IDs unique; deleting a rule removes its weight slider.</li>
                    <li><b>Presets & bundles</b>: Use <code>Config → Rules</code> to search/filter groups and apply themed selections or bundles. Optional “Include core rules”.</li>
                    <li><b>Visuals</b>: Rules may call <code>api.addDrawable(fn)</code> to draw lightweight effects, and <code>api.depositTrail(x,y)</code> for heatmap trails.</li>
                </ul>

                <h3>URL Parameters</h3>
                <p>Most settings persist via the URL. Values are JSON‑parsed, so booleans and numbers work as expected.</p>
                <ul>
                    <li><code>header</code>: string — page title shown on canvas (omit or set empty to hide)</li>
                    <li><code>subheader</code>: string — subtitle shown on canvas (omit or set empty to hide)</li>
                    <li><code>hue</code>: number (theme hue)</li>
                    <li><code>boidCount</code>, <code>boidSize</code>, <code>boidSizeVariance</code>, <code>boidShape</code> (triangle|circle|oval|ring)</li>
                    <li><code>maxSpeed</code>, <code>maxForce</code>, <code>perceptionRadius</code>, <code>visualDensity</code></li>
                    <li><code>cohesionWeight</code>, <code>separationWeight</code>, <code>alignmentWeight</code>, <code>novelWeight</code></li>
                    <li><code>visualizeQuadtree</code>: boolean, <code>debug</code>: boolean</li>
                    <li><code>codePaneDock</code>: bottom|left|max, <code>codePaneLeftWidth</code>: number</li>
                    <li><code>splitLeftRule</code>, <code>splitRightRule</code>: rule IDs</li>
                    <li><code>presetIncludeCore</code>: boolean — include core rules in batch</li>
                    <li><code>presetCount</code>: number — default count for batch presets</li>
                    <li><code>presetTheme</code>: string — one of <code>any</code>, <code>flash</code>, <code>mouse</code>, <code>click</code>, <code>drag</code>, <code>physics</code>, <code>flow</code>, <code>orbit</code>, <code>edge</code>, <code>trail</code>, <code>color</code>, <code>group</code>, <code>speed</code>, <code>templates</code></li>
                    <li><code>presetBundle</code>: string — one of <code>none</code>, <code>ai-ml-pack</code>, <code>physics-pack</code>, <code>nature-pack</code>, <code>clustering-pack</code>, <code>optimization-pack</code>, <code>graphs-pack</code>, <code>dimensionality-pack</code>, <code>navigation-pack</code>, <code>generative-pack</code>, <code>flash-showcase</code>, <code>interaction-pack</code>, <code>flow-pack</code>, <code>trail-pack</code>, <code>core-plus-flash</code></li>
                    <li><code>randomPresets</code>: boolean|number — when true/number, loads random presets on start; number picks that many</li>
                </ul>
                <h4>Examples</h4>
                <ul>
                    <li><code>${urlBase}?header=My%20Boids&subheader=Have%20fun%20with%20rules</code></li>
                    <li><code>${urlBase}?presetIncludeCore=false&amp;presetTheme=flash&amp;randomPresets=true</code></li>
                    <li><code>${urlBase}?presetIncludeCore=true&amp;presetCount=6&amp;presetTheme=mouse&amp;randomPresets=6</code></li>
                    <li><code>${urlBase}?presetIncludeCore=true&amp;presetBundle=ai-ml-pack</code></li>
                    <li><code>${urlBase}?presetIncludeCore=false&amp;presetBundle=physics-pack</code></li>
                    <li><code>${urlBase}?presetIncludeCore=true&amp;presetBundle=nature-pack</code></li>
                    <li><code>${urlBase}?presetIncludeCore=false&amp;presetBundle=clustering-pack</code></li>
                    <li><code>${urlBase}?presetBundle=optimization-pack</code></li>
                    <li><code>${urlBase}?debug=true&amp;hue=320&amp;boidCount=300</code></li>
                </ul>

                <h3>Change Log</h3>
                <p>
                    v1.7 - Added visual success/error indicators for live code reloading.<br>
                    v1.6 - Added boid shape/size configs and monospace font styling.<br>
                    v1.5 - Added beautiful mean direction polar chart with togglable stdev bands.<br>
                    v1.4 - Added close buttons and expanded statistics panel.<br>
                    v1.3 - Fixed critical scope error for dynamic code.<br>
                    v1.2 - Added dynamic polar spiral graph for flock coherence.<br>
                    v1.1 - Fixed critical errors related to dynamic function creation.<br>
                    v1.0 - Initial implementation.
                </p>`;
            container.querySelector('.close-button').onclick = () => container.classList.remove('visible');
        }

        function setupInfoUI() {
            const container = document.getElementById('info-overlay');
            if (!container) return;
            container.innerHTML = '' +
              '<button class="close-button">&times;</button>' +
              '<h2>Technical Info</h2>' +

              '<h3>Rule Function</h3>' +
              '<pre style="white-space:pre-wrap;font-size:12px;line-height:1.4">' +
              'function rule(boid, gameState, neighbors, config, mouse, Vector, api, pheromones) {\n' +
              '  // Return a Vector steering force.\n' +
              '  // Optionally draw visuals via api.addDrawable() or deposit trails via api.depositTrail().\n' +
              '  return new Vector(0,0);\n' +
              '}' +
              '</pre>' +
              '<ul>' +
              '<li><b>In scope</b>: <code>boid</code>, <code>neighbors</code>, <code>gameState</code>, <code>config</code>, <code>mouse</code>, <code>Vector</code>, <code>api</code>, <code>pheromones</code>.</li>' +
              '<li><b>Return</b>: Always a <code>Vector</code>; non‑Vector results are ignored.</li>' +
              '</ul>' +

              '<h3>APIs</h3>' +
              '<ul>' +
              '<li><code>api.addDrawable((ctx, gs) =&gt; {...})</code>: Enqueue a lightweight draw step after boids render.</li>' +
              '<li><code>api.depositTrail(x, y, amount=1)</code>: Add to a decaying pheromone grid for heatmap/trails.</li>' +
              '<li><code>api.spawnBoid(x, y, opts)</code>: Request creation of a boid at <code>(x,y)</code>. <code>opts</code> may include <code>{hue, size, role, vel:{x,y}}</code>.</li>' +
              '<li><code>api.destroyBoid(boid)</code>: Request removal of a specific boid (safe; applied after the update step).</li>' +
              '<li><code>api.shake(amplitude, durationMs)</code>: Trigger a tasteful screen shake (world translation) with decaying amplitude.</li>' +
              '</ul>' +

              '<h3>Simulation Pipeline</h3>' +
              '<ol>' +
              '<li><b>Update</b>: rebuild quadtree → decay pheromones → for each boid, accumulate rule forces.</li>' +
              '<li><b>Draw</b>: background → pheromone heatmap → optional quadtree → boids → drawables → HUD.</li>' +
              '</ol>' +

              '<h3>Model & Data</h3>' +
              '<ul>' +
              '<li><b>Boid</b>: position/velocity/acceleration with <code>maxSpeed</code>, <code>maxForce</code>, <code>hue</code>, and <code>size</code>.</li>' +
              '<li><b>Neighbors</b>: quadtree query within <code>perceptionRadius</code>; wraparound edges by default.</li>' +
              '<li><b>Pheromones</b>: grid of floats with decay; cell size tuned for performance (<code>depositTrail</code> writes cells).</li>' +
              '<li><b>Drawables</b>: frame‑scoped list; rendered after boids. <code>visualDensity</code> controls thinning/duplication.</li>' +
              '</ul>' +

              '<h3>Stats & Diagnostics</h3>' +
              '<ul>' +
              '<li><b>FPS</b>: recent frames/sec; target 60.</li>' +
              '<li><b>Update Time</b>: per‑frame update cost (ms) with mean/stddev.</li>' +
              '<li><b>Drawables/Frame</b>: number of custom draw calls enqueued.</li>' +
              '<li><b>Flock Coherence</b>: spiral plot of neighbor alignment/spacing.</li>' +
              '<li><b>Mean Direction</b>: average heading ± stdev bands (toggleable).</li>' +
              '</ul>' +

              '<h3>Error Handling</h3>' +
              '<p>When a rule throws during runtime, it temporarily falls back to zero output and marks its tab with a small red dot. Successful reloads flash the tab briefly.</p>' +

              '<h3>Performance Tips</h3>' +
              '<ul>' +
              '<li>Prefer simple, bounded drawables; avoid O(n²) work inside <code>addDrawable</code> callbacks.</li>' +
              '<li>Use <code>visualDensity</code> to scale effect intensity for slower machines.</li>' +
              '<li>Keep rule math side‑effect free; accumulate into a steering vector and return.</li>' +
              '</ul>' +

              '<h3>Coordinates</h3>' +
              '<p>Origin at top‑left; +x right, +y down. Boids wrap around edges.</p>' +

              '<h3>Rule Docs & JSDoc</h3>' +
              '<p>Rules use a JSDoc header to provide a title and description used throughout the UI.</p>' +
              '<pre style="white-space:pre-wrap;font-size:12px;line-height:1.4">' +
              '/**\n' +
              '  Title of the Rule\n' +
              '  One-line description of behavior (shown in Rules tab)\n' +
              '  \n' +
              '  Rule API\n' +
              '  @function rule\n' +
              '  @param {Boid} boid\n' +
              '  @param {GameState} gameState\n' +
              '  @param {Boid[]} neighbors\n' +
              '  @param {Object} config\n' +
              '  @param {Mouse} mouse\n' +
              '  @param {typeof Vector} Vector\n' +
              '  @param {{depositTrail:(x:number,y:number,a?:number)=>void, addDrawable:(fn:Function)=>void, spawnBoid:(x:number,y:number,opts?:object)=>void, destroyBoid:(b:Boid)=>void, shake:(amp:number,dur:number)=>void}} api\n' +
              '  @returns {Vector}\n' +
              '*/\n' +
              '//function rule(boid, gameState, neighbors, config, mouse, Vector, api) {\n' +
              '  // Note:  You are implementing only the body of this function.\n' +
              '  //        The function signature is provided here for reference.\n' +
              '  // Return a Vector steering force; keep pure (no side effects).\n' +
              '  return new Vector();\n' +
              '//}\n' +
              '</pre>' +
              '<ul>' +
              '<li><b>Description rule</b>: the Rules tab shows the second meaningful JSDoc line. Use line 1 for the title, line 2 for a concise summary.</li>' +
              '<li><b>Purity</b>: avoid mutating global state; compute a steering vector and return it.</li>' +
              '<li><b>Visuals</b>: use <code>api.addDrawable()</code> for lightweight draws and <code>api.depositTrail()</code> for trails; keep per-frame work small.</li>' +
              '<li><b>Performance</b>: prefer O(k) neighbor loops; avoid heavy work inside drawables; honor <code>visualDensity</code>.</li>' +
              '</ul>';
            container.querySelector('.close-button').onclick = () => container.classList.remove('visible');
        }

        function setupCodePane() {
            const tabs = document.querySelectorAll('.tab-button');
            const contents = document.querySelectorAll('.tab-content');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    contents.forEach(c => c.classList.remove('active'));
                    tab.classList.add('active');
                    document.getElementById(tab.dataset.tab).classList.add('active');
                    editors[tab.dataset.tab].refresh();
                    // Update novel config panels visibility on tab change
                    if (typeof updateNovelConfigVisibility === 'function') updateNovelConfigVisibility();
                });
            });

            // Provide lightweight autocompletion with in-scope symbols and common vectors
            function ruleHint(editor) {
                const cur = editor.getCursor();
                const token = editor.getTokenAt(cur);
                const start = token.start;
                const end = cur.ch;
                const word = token.string.trim();
                const from = CodeMirror.Pos(cur.line, start);
                const to = CodeMirror.Pos(cur.line, end);
                const line = editor.getLine(cur.line);
                const before = line.slice(0, cur.ch);
                const isConfigCtx = /(^|\W)config\.$/.test(before);
                const configKeys = Object.keys(config || {}).map(k => `config.${k}`);
                const base = [
                    'boid', 'boid.pos', 'boid.vel', 'boid.acc', 'boid.maxSpeed', 'boid.maxForce', 'boid.size', 'boid.hue',
                    'gameState', 'gameState.width', 'gameState.height', 'gameState.boids', 'neighbors',
                    'config',
                    'mouse', 'mouse.pos.x', 'mouse.pos.y', 'mouse.down',
                    'Vector', 'Vector.sub', 'Vector.dist', 'Vector.random2D',
                    'api', 'api.depositTrail', 'api.addDrawable', 'api.spawnBoid', 'api.destroyBoid', 'api.shake',
                    'pheromones', 'pheromones.grid', 'pheromones.cols', 'pheromones.rows', 'pheromones.cell',
                    'add()', 'sub()', 'mult()', 'div()', 'mag()', 'normalize()', 'limit()', 'heading()', 'clone()',
                    'return new Vector(0, 0)', 'const v = new Vector(0, 0)'
                ];
                const pool = isConfigCtx ? configKeys : base.concat(configKeys);
                // Deduplicate and filter by current token
                const seen = new Set();
                const list = pool.filter(s => {
                    const key = s.toLowerCase();
                    if (seen.has(key)) return false;
                    seen.add(key);
                    return !word || key.startsWith(word.toLowerCase());
                });
                return { list, from, to };
            }

            const originalParents = {};

            for (const fn of userFunctions) {
                const content = document.getElementById(fn.name);
                // Build per-editor toolbar
                const bar = buildEditorBar(fn.name);
                content.prepend(bar);
                const textarea = content.querySelector('textarea');
                textarea.value = defaultFunctionsCode[fn.name];
                editors[fn.name] = CodeMirror.fromTextArea(textarea, {
                    mode: 'javascript', theme: 'dracula', lineNumbers: true,
                    lint: true, gutters: ["CodeMirror-lint-markers"],
                    extraKeys: { 'Ctrl-Space': 'autocomplete' },
                    hintOptions: { hint: ruleHint, completeSingle: false }
                });
                // Store original parent (code-pane) for returning when exiting split
                originalParents[fn.name] = document.getElementById(fn.name).parentElement;

                // Live-compile user rule code into a function with a narrow, explicit scope.
                // Scope parameters available inside the editor code:
                //   boid (Boid), gameState ({boids, quadtree, width, height}), neighbors (Boid[]),
                //   config (object), mouse ({pos, down}), Vector (math helper)
                const updateFunction = debounce((editor) => {
                    const tabButton = document.querySelector(`.tab-button[data-tab="${fn.name}"]`);
                    try {
                        const code = editor.getValue();
                        const params = ['boid', 'gameState', 'neighbors', 'config', 'mouse', 'Vector', 'api', 'pheromones'];
                        const dynamicFunc = new Function(...params, code);
                        const prev = fn.updateBoid;

                        // Dry-run with a tiny mock to validate (no side effects expected)
                        const mockBoid = new Boid(0, 0);
                        const mockState = { boids: [mockBoid], quadtree: null, width: 10, height: 10 };
                        const mockNeighbors = [];
                        let ok = true;
                        try {
                            const res = dynamicFunc(mockBoid, mockState, mockNeighbors, config, mouse, Vector, RuleAPI, pheromones);
                            // Must be Vector or falsy; non-Vector returns are tolerated as no-op
                            if (res && !(res instanceof Vector)) ok = false;
                        } catch (e) {
                            ok = false;
                        }
                        if (!ok) throw new Error('Rule dry-run failed');

                        // Adopt the new function, wrapped with runtime safety
                        fn.updateBoid = (boid, gameState, neighbors) => {
                            try {
                                const out = dynamicFunc(boid, gameState, neighbors, config, mouse, Vector, RuleAPI, pheromones);
                                return out instanceof Vector ? out : new Vector();
                            } catch (e) {
                                const now = performance.now();
                                if (!fn._lastRuntimeErrorTs || (now - fn._lastRuntimeErrorTs) > 1000) {
                                    console.error(`Runtime error in rule '${fn.name}':`, e);
                                    fn._lastRuntimeErrorTs = now;
                                }
                                // Mark fallback active for a short window and update UI (throttled)
                                fn._fallbackUntil = now + 2000;
                                updateRuleStatusUI();
                                return new Vector();
                            }
                        };

                        console.log(`Rule '${fn.name}' reloaded successfully.`);
                        logConfig(`Rule '${fn.name}' reloaded successfully.`);
                        if (tabButton) {
                           tabButton.classList.add('reloaded-success');
                           setTimeout(() => tabButton.classList.remove('reloaded-success'), 600);
                        }
                    } catch (e) {
                        console.error(`Error reloading rule '${fn.name}':`, e);
                        // Keep previous good function if any; else use no-op
                        fn.updateBoid = typeof fn.updateBoid === 'function' ? fn.updateBoid : () => new Vector();
                        // Also mark fallback indicator briefly to signal error state
                        fn._fallbackUntil = performance.now() + 2000;
                        updateRuleStatusUI();
                        if (tabButton) {
                           tabButton.classList.add('reloaded-error');
                           setTimeout(() => tabButton.classList.remove('reloaded-error'), 600);
                        }
                    }
                }, 500);
                editors[fn.name].on('change', updateFunction);
                // Show autocomplete as you type for convenience
                editors[fn.name].on('inputRead', (cm, change) => {
                    if (!change.text) return;
                    const ch = change.text.join('');
                    if (/^[\w\.$]$/.test(ch)) {
                        cm.showHint({ hint: ruleHint, completeSingle: false });
                    }
                });
                updateFunction(editors[fn.name]); // Initial compilation
            }

            // Split view setup
            const leftSel = document.getElementById('split-left');
            const rightSel = document.getElementById('split-right');
            const splitView = document.getElementById('split-view');
            const splitSash = splitView ? splitView.querySelector('.split-sash') : null;
            const slots = {
                left: document.querySelector('.split-pane[data-slot="left"]'),
                right: document.querySelector('.split-pane[data-slot="right"]'),
            };
            const mounted = {}; // rule -> slot name

            function populateSelects() {
                [leftSel, rightSel].forEach(sel => { sel.innerHTML = ''; });
                userFunctions.forEach(fn => {
                    const optL = document.createElement('option'); optL.value = fn.name; optL.textContent = fn.name;
                    const optR = document.createElement('option'); optR.value = fn.name; optR.textContent = fn.name;
                    leftSel.appendChild(optL); rightSel.appendChild(optR);
                });
            }
            function updateSelectStates() {
                // Ensure distinct selections
                if (leftSel.value === rightSel.value) {
                    const other = userFunctions.find(u => u.name !== leftSel.value);
                    if (other) rightSel.value = other.name;
                }
                // Disable chosen rule in the opposite select
                Array.from(leftSel.options).forEach(o => { o.disabled = (o.value === rightSel.value); });
                Array.from(rightSel.options).forEach(o => { o.disabled = (o.value === leftSel.value); });
            }
            function unmountRule(rule) {
                if (!mounted[rule]) return;
                const content = document.getElementById(rule);
                const parent = originalParents[rule] || document.getElementById('code-pane');
                if (content && parent) { parent.appendChild(content); editors[rule].refresh(); }
                delete mounted[rule];
            }
            function mountRule(rule, slotName) {
                if (!rule || !slots[slotName]) return;
                // If this rule is mounted elsewhere, unmount first
                unmountRule(rule);
                const content = document.getElementById(rule);
                if (content) { slots[slotName].appendChild(content); mounted[rule] = slotName; editors[rule].refresh(); }
            }
            function updateSplitMounts() {
                // Ensure rules are distinct
                updateSelectStates();
                const L = leftSel.value;
                const R = rightSel.value;
                // Unmount any rule not chosen
                Object.keys(mounted).forEach(rule => {
                    if (rule !== L && rule !== R) unmountRule(rule);
                });
                // If a chosen rule is mounted in the wrong place, move it
                if (mounted[L] !== 'left') mountRule(L, 'left');
                if (mounted[R] !== 'right') mountRule(R, 'right');
                applySplitRatio();
                // Ensure both panes are visible (fallback to a different rule if same)
                if (L === R) {
                    const other = userFunctions.find(u => u.name !== L);
                    if (other) { rightSel.value = other.name; mountRule(other.name, 'right'); }
                }
            }
            function showSplitUI(show) {
                const sc = document.getElementById('split-controls');
                const sv = document.getElementById('split-view');
                if (sc) sc.style.display = 'none'; // managed in tabs row now
                if (sv) sv.style.display = show ? 'flex' : 'none';
            }
            function applySplitRatio() {
                if (!slots.left || !slots.right) return;
                const pct = (typeof config.splitLeftPercent === 'number') ? config.splitLeftPercent : 50;
                slots.left.style.flex = `0 0 ${pct}%`;
                slots.right.style.flex = `1 1 auto`;
            }
            // Sash drag to set ratio
            if (splitSash && splitView) {
                let dragging = false;
                const onMove = (evt) => {
                    if (!dragging) return;
                    const x = evt.touches ? evt.touches[0].clientX : evt.clientX;
                    const rect = splitView.getBoundingClientRect();
                    let pct = ((x - rect.left) / rect.width) * 100;
                    pct = Math.max(20, Math.min(80, pct));
                    config.splitLeftPercent = pct;
                    applySplitRatio();
                };
                const onUp = () => {
                    if (!dragging) return;
                    dragging = false;
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                    document.removeEventListener('touchmove', onMove);
                    document.removeEventListener('touchend', onUp);
                    if (!config.debug) updateURL('splitLeftPercent', Math.round(config.splitLeftPercent));
                    refreshEditors();
                };
                splitSash.addEventListener('mousedown', () => {
                    dragging = true;
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onUp);
                });
                splitSash.addEventListener('touchstart', () => {
                    dragging = true;
                    document.addEventListener('touchmove', onMove, { passive: false });
                    document.addEventListener('touchend', onUp);
                }, { passive: true });
            }
            // Expose hooks for dock mode changes
            setupCodePane._split = {
                populateSelects, updateSplitMounts, showSplitUI,
                get leftSel() { return leftSel; },
                get rightSel() { return rightSel; },
                unmountAll: () => { Object.keys(mounted).forEach(unmountRule); }
            };
            populateSelects();
            leftSel.value = config.splitLeftRule || 'cohesion';
            rightSel.value = (config.splitRightRule && config.splitRightRule !== leftSel.value)
                ? config.splitRightRule : (userFunctions.find(u => u.name !== leftSel.value) || userFunctions[0]).name;
            updateSelectStates();
            leftSel.addEventListener('change', () => {
                config.splitLeftRule = leftSel.value;
                if (!config.debug) updateURL('splitLeftRule', config.splitLeftRule);
                updateSplitMounts();
            });
            rightSel.addEventListener('change', () => {
                config.splitRightRule = rightSel.value;
                if (!config.debug) updateURL('splitRightRule', config.splitRightRule);
                updateSplitMounts();
            });
            // Per-editor toolbars manage presets and actions
            // Reflect initial split toggle state when first applied to maximized
            updateSplitModeUI();
            // Global new rule button moved to per-editor bars; expose helper if needed
        }

        function buildEditorBar(ruleName) {
            const bar = document.createElement('div'); bar.className = 'editor-bar';
            // Preset select (grouped by category)
            const label = document.createElement('span'); label.style.color = '#ddd'; label.style.fontSize = '12px'; label.textContent = 'Preset:';
            bar.appendChild(label);
            const sel = document.createElement('select'); sel.title = 'Presets (grouped by category)';
            const groups = categorizePresets();
            const order = ['Core', 'Novel', 'Nature', 'AI / ML / CS', 'Physics', 'Math', 'Visual', 'Templates', 'Other'];
            order.forEach(label => {
                if (!groups[label] || groups[label].length === 0) return;
                const og = document.createElement('optgroup'); og.label = label;
                groups[label].forEach((p, idx) => {
                    const o = document.createElement('option'); o.value = p.id; o.textContent = p.name; if (!sel.firstChild && idx === 0) o.selected = true; og.appendChild(o);
                });
                sel.appendChild(og);
            });
            bar.appendChild(sel);
            // Selected preset name is visible in the dropdown; no extra label
            // Fill button
            const fill = document.createElement('button'); fill.className='bar-btn'; fill.title='Fill with preset'; fill.textContent='Fill';
            fill.addEventListener('click', () => {
                const currentName = bar.closest('.tab-content')?.id;
                const p = rulePresets.find(x => x.id === sel.value) || rulePresets[0];
                if (!currentName || !p) return;
                const ed = editors[currentName]; if (ed) ed.setValue(p.code);
                // Always rename to the preset name for clarity (ensure unique)
                if (currentName !== sanitizeRuleName(p.name)) {
                    renameRule(currentName, p.name);
                }
            });
            bar.appendChild(fill);
            // Rename button
            const ren = document.createElement('button'); ren.className='bar-btn'; ren.title='Rename rule'; ren.textContent='Rename';
            ren.addEventListener('click', () => {
                const currentName = bar.closest('.tab-content')?.id;
                if (!currentName) return;
                const newName = prompt(`Rename rule '${currentName}' to:`, currentName);
                if (newName && newName !== currentName) renameRule(currentName, newName);
            });
            bar.appendChild(ren);
            // Delete button
            const del = document.createElement('button'); del.className='bar-btn'; del.title='Delete rule'; del.textContent='Delete';
            del.addEventListener('click', () => {
                const currentName = bar.closest('.tab-content')?.id;
                if (!currentName) return;
                if (userFunctions.length <= 1) { alert('At least one rule is required.'); return; }
                if (!confirm(`Delete rule '${currentName}'? This cannot be undone.`)) return;
                deleteRule(currentName);
            });
            bar.appendChild(del);
            // New rule button (local convenience)
            const add = document.createElement('button'); add.className='bar-btn'; add.title='New rule from selected preset'; add.textContent='New';
            add.addEventListener('click', () => {
                const p = rulePresets.find(x => x.id === sel.value);
                if (p) {
                    addRuleWithPreset(p);
                } else {
                    addRule();
                }
            });
            bar.appendChild(add);
            return bar;
        }

        function categorizePresets() {
            const groups = { 'Core': [], 'Novel': [], 'AI / ML / CS': [], 'Physics': [], 'Math': [], 'Nature': [], 'Visual': [], 'Templates': [], 'Other': [] };
            for (const p of rulePresets) {
                const name = p.name || '';
                if (/\(Core\)/i.test(name) || /-core$/.test(p.id)) groups['Core'].push(p);
                else if (/^Novel\b/i.test(name)) groups['Novel'].push(p);
                else if (/^Physics\b/i.test(name)) groups['Physics'].push(p);
                else if (/^(?:AI|ML|CS)(?:\b|\s?[—-])/i.test(name)) groups['AI / ML / CS'].push(p);
                else if (/^Math\b/i.test(name)) groups['Math'].push(p);
                else if (/^Nature\b/i.test(name)) groups['Nature'].push(p);
                else if (/^Visual\b/i.test(name)) groups['Visual'].push(p);
                else if (/^Template\b|^Drawable Template\b/i.test(name)) groups['Templates'].push(p);
                else groups['Other'].push(p);
            }
            // Sort presets by name within each group for easier scanning
            Object.keys(groups).forEach(g => groups[g].sort((a,b) => (a.name||'').localeCompare(b.name||'')));
            return groups;
        }

        function sanitizeRuleName(name) {
            let s = String(name).trim();
            s = s.replace(/\s+/g, '-').replace(/[^A-Za-z0-9_-]/g, '').toLowerCase();
            if (!s) s = 'rule';
            let base = s, i = 2;
            while (userFunctions.find(u => u.name === s)) { s = base + '-' + i++; }
            return s;
        }

        function defaultRuleTemplate() {
            // Rotate through presets for variety
            if (typeof config._nextPresetIdx !== 'number') config._nextPresetIdx = 0;
            const preset = rulePresets[config._nextPresetIdx % rulePresets.length];
            config._nextPresetIdx++;
            return preset ? preset.code : `return new Vector();`;
        }

        function addRule(nameRaw, codeOverride, displayLabel) {
            // Choose a preset for the new rule and use its name as the rule name
            if (typeof config._nextPresetIdx !== 'number') config._nextPresetIdx = 0;
            const preset = rulePresets[config._nextPresetIdx % rulePresets.length];
            config._nextPresetIdx++;
            const baseName = sanitizeRuleName(preset?.name || 'custom');
            let name = baseName;
            let i = 2; while (userFunctions.find(u => u.name === name)) { name = `${baseName}-${i++}`; }
            if (userFunctions.find(u => u.name === name)) { alert('Rule already exists.'); return; }
            // Create tab and content
            const tabsBar = document.querySelector('.code-tabs');
            const tabBtn = document.createElement('button');
            tabBtn.className = 'tab-button'; tabBtn.dataset.tab = name; tabBtn.textContent = displayLabel || (name.charAt(0).toUpperCase() + name.slice(1));
            tabsBar.insertBefore(tabBtn, tabsBar.querySelector('.dock-controls'));
            const content = document.createElement('div'); content.id = name; content.className = 'tab-content';
            // Per-editor toolbar
            const bar = buildEditorBar(name); content.appendChild(bar);
            const ta = document.createElement('textarea'); content.appendChild(ta);
            const codePaneEl = document.getElementById('code-pane');
            codePaneEl.appendChild(content);
            // Editor
            const ed = CodeMirror.fromTextArea(ta, { mode:'javascript', theme:'dracula', lineNumbers:true, lint:true, gutters:["CodeMirror-lint-markers"], extraKeys:{'Ctrl-Space':'autocomplete'}, hintOptions:{hint: editor => ruleHint(editor), completeSingle:false} });
            editors[name] = ed;
            // Compile function
            const fnObj = { name, displayName: (displayLabel || (preset?.name) || name), weight: 1.0, updateBoid: null };
            userFunctions.push(fnObj);
            // Hook tab behavior
            tabBtn.addEventListener('click', () => {
                document.querySelectorAll('.tab-button').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                tabBtn.classList.add('active'); content.classList.add('active'); ed.refresh();
            });
            // Set initial code
            if (codeOverride && typeof codeOverride === 'string') {
                ed.setValue(codeOverride);
            } else if (preset && preset.code) {
                ed.setValue(preset.code);
            } else {
                ed.setValue('return new Vector();');
            }
            const updateFunction = debounce((editor) => {
                const tabButton = tabBtn;
                try {
                    const code = editor.getValue();
                    const params = ['boid','gameState','neighbors','config','mouse','Vector','api','pheromones'];
                    const dynamicFunc = new Function(...params, code);
                    // dry-run
                    const mockBoid = new Boid(0,0); const mockState = { boids:[mockBoid], quadtree:null, width:10, height:10 };
                    let ok = true; try { const res = dynamicFunc(mockBoid, mockState, [], config, mouse, Vector, RuleAPI, pheromones); if (res && !(res instanceof Vector)) ok = false; } catch(e){console.log(e); ok=false; }
                    if (!ok) throw new Error('Rule dry-run failed');
                    fnObj.updateBoid = (boid, gameState, neighbors) => { try { const out = dynamicFunc(boid, gameState, neighbors, config, mouse, Vector, RuleAPI, pheromones); return out instanceof Vector ? out : new Vector(); } catch (e) { fnObj._fallbackUntil = performance.now()+2000; updateRuleStatusUI(); return new Vector(); } };
                    tabButton.classList.add('reloaded-success'); setTimeout(()=>tabButton.classList.remove('reloaded-success'),600);
                } catch (e) {
                    console.error(`Error reloading rule '${name}':`, e);
                    fnObj.updateBoid = () => new Vector();
                    tabButton.classList.add('reloaded-error'); setTimeout(()=>tabButton.classList.remove('reloaded-error'),600);
                    fnObj._fallbackUntil = performance.now()+2000; updateRuleStatusUI();
                }
            }, 500);
            ed.on('change', updateFunction);
            ed.on('inputRead', (cm, change) => { if (!change.text) return; const ch = change.text.join(''); if (/^[\w\.$]$/.test(ch)) cm.showHint({ hint: ruleHint, completeSingle:false });});
            updateFunction(ed);
            // Rebuild config UI and split pickers
            config[`${name}Weight`] = 1.0;
            setupConfigUI();
            if (setupCodePane._split) { setupCodePane._split.populateSelects(); setupCodePane._split.updateSplitMounts(); }
            // Activate newly created tab and ensure code pane is visible
            document.querySelectorAll('.tab-button').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            tabBtn.classList.add('active');
            content.classList.add('active');
            ed.refresh();
            const pane = document.getElementById('code-pane');
            if (!pane.classList.contains('visible')) pane.classList.add('visible');
        }

        function getCurrentRuleTarget() {
            const pane = document.getElementById('code-pane');
            const maximized = pane.classList.contains('maximized');
            if (maximized && config.splitEnabled) {
                // Default to left selection
                const leftSel = document.getElementById('split-left');
                return leftSel && leftSel.value || null;
            }
            const active = document.querySelector('.tab-button.active');
            return active ? active.dataset.tab : null;
        }

        function renameRule(oldNameRaw, newNameRaw) {
            const oldName = oldNameRaw; const newName = sanitizeRuleName(newNameRaw);
            if (!editors[oldName]) { alert('Rule not found.'); return; }
            if (editors[newName]) { alert('A rule with that name already exists.'); return; }
            // Update userFunctions entry
            const fnObj = userFunctions.find(u => u.name === oldName);
            if (!fnObj) return;
            fnObj.name = newName;
            fnObj.displayName = newNameRaw;
            // Move editor mapping
            editors[newName] = editors[oldName]; delete editors[oldName];
            // Update tab button and content IDs
            const tabBtn = document.querySelector(`.tab-button[data-tab="${oldName}"]`);
            const content = document.getElementById(oldName);
            if (tabBtn) { tabBtn.dataset.tab = newName; tabBtn.textContent = (newNameRaw || newName).toString(); }
            if (content) { content.id = newName; }
            // Update config weight key
            const oldKey = `${oldName}Weight`; const newKey = `${newName}Weight`;
            config[newKey] = (oldKey in config) ? config[oldKey] : 1.0; delete config[oldKey];
            setupConfigUI();
            // Update split selections
            const leftSel = document.getElementById('split-left');
            const rightSel = document.getElementById('split-right');
            if (leftSel && leftSel.value === oldName) leftSel.value = newName;
            if (rightSel && rightSel.value === oldName) rightSel.value = newName;
            if (setupCodePane._split) { setupCodePane._split.populateSelects(); setupCodePane._split.updateSplitMounts(); }
        }

        function addRuleWithPreset(preset) {
            if (!preset) return;
            addRule(preset.name, preset.code, preset.name);
        }

        function resetRulesWithPresets(n, includeCore, themeKey = 'any') {
            const coreIds = new Set(['cohesion-core','alignment-core','separation-core','novel-core']);
            const corePresets = rulePresets.filter(p => coreIds.has(p.id));
            const nonCorePresets = rulePresets.filter(p => !coreIds.has(p.id));
            // Themed filters
            const presetThemes = {
                any: (p) => true,
                flash: (p) => p.name && p.name.startsWith('Flash — '),
                mouse: (p) => /mouse|click/i.test(p.id) || /mouse|click/i.test(p.name || ''),
                drag:  (p) => /drag/i.test(p.id) || /drag/i.test(p.name || ''),
                click: (p) => /click/i.test(p.id) || /click/i.test(p.name || ''),
                templates: (p) => /^template-/.test(p.id),
                flow: (p) => /flow|vortex|orbit|lane/i.test(p.id) || /Flow|Vortex|Orbit|Lane/i.test(p.name || ''),
                physics: (p) => /^Physics\b/i.test(p.name || '') || /physics/i.test(p.id || ''),
                edge: (p) => /edge|boundary|wall|runner/i.test(p.id) || /Edge/i.test(p.name || ''),
                trail: (p) => /trail|pheromone|mesh/i.test(p.id) || /Trail/i.test(p.name || ''),
                orbit: (p) => /orbit|vortex|centroid/i.test(p.id) || /Orbit|Vortex|Centroid/i.test(p.name || ''),
                color: (p) => /hue|color|polarize/i.test(p.id) || /Color|Hue/i.test(p.name || ''),
                group: (p) => /group|faction/i.test(p.id) || /Group|Factions/i.test(p.name || ''),
                speed: (p) => /speed|comet|boost/i.test(p.id) || /Speed|Comet/i.test(p.name || '')
            };
            const filterFn = presetThemes[themeKey] || presetThemes.any;
            const themed = nonCorePresets.filter(filterFn);
            // Shuffle helper
            const shuffle = (arr) => { const a = arr.slice(); for (let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; };
            // Build final selection: [core (optional)] + N random non-core
            const selected = [];
            if (includeCore) selected.push(...corePresets);
            const pool = themed.length ? themed : nonCorePresets;
            const picks = shuffle(pool).slice(0, Math.max(0, Math.min(n, pool.length)));
            selected.push(...picks);
            if (selected.length === 0) return;
            // Replace current rules with selected list (first replaces first rule; others added; rest deleted)
            if (userFunctions.length === 0) {
                addRuleWithPreset(selected[0]);
            } else {
                // Replace first
                const first = userFunctions[0].name;
                const ed = editors[first];
                if (ed) ed.setValue(selected[0].code);
                if (first !== sanitizeRuleName(selected[0].name)) renameRule(first, selected[0].name);
                // Delete all others for a clean slate
                const others = userFunctions.slice(1).map(u => u.name);
                others.forEach(nm => deleteRule(nm));
            }
            // Add remaining selections in order
            for (let i = 1; i < selected.length; i++) addRuleWithPreset(selected[i]);
            // Rebuild UI bits
            if (setupCodePane._split) { setupCodePane._split.populateSelects(); setupCodePane._split.updateSplitMounts(); }
            setupConfigUI();
        }

        function loadPresetBundle(bundleKey, includeCore) {
            const coreIds = new Set(['cohesion-core','alignment-core','separation-core','novel-core']);
            const corePresets = rulePresets.filter(p => coreIds.has(p.id));
            const presetById = Object.fromEntries(rulePresets.map(p => [p.id, p]));
            const bundles = {
                'flash-showcase': ['spark-burst','glow-orb','comet-flares','shockwave-rings','twinkle-trails'],
                'interaction-pack': ['mouse-vortex','mouse-attract','click-explosion','drag-wind-gust','drag-line-tractor'],
                'flow-pack': ['sine-flow-field','twin-vortices','orbital-centroid','lane-weave'],
                'trail-pack': ['template-trail-heatmap','trail-mesh','comet-flares','template-drawable-streak'],
                'core-plus-flash': ['cohesion-core','alignment-core','separation-core','glow-orb'],
                'ai-ml-pack': [
                    'ai-transformer-attention',
                    'ml-kmeans-centroids',
                    'ml-gaussian-mixture',
                    'ai-epsilon-greedy',
                    'ai-pca-principal-flow',
                    'ai-perceptron-boundary'
                ],
                'nature-pack': [
                    'nature-murmuration-spiral',
                    'nature-thermal-soaring',
                    'nature-river-meander',
                    'nature-phyllotaxis-orbit',
                    'nature-pollen-drift',
                    'nature-karman-vortex-street'
                ],
                // Smaller thematic bundles
                'clustering-pack': [
                    'ml-kmeans-centroids',
                    'ml-gaussian-mixture',
                    'ml-dbscan-density',
                    'ml-pca-velocity'
                ],
                'optimization-pack': [
                    'ai-epsilon-greedy',
                    'ai-q-learning-trace',
                    'ai-a-star-field',
                    'ai-ant-colony-intensify',
                    'ml-svm-margin'
                ],
                'graphs-pack': [
                    'cs-bfs-frontier',
                    'cs-pagerank-drift',
                    'cs-consistent-hash-ring',
                    'cs-nearest-triangulation',
                    'cs-swarm-dijkstra'
                ],
                'dimensionality-pack': [
                    'ai-pca-principal-flow',
                    'ml-pca-velocity',
                    'ml-tsne-local-structure',
                    'ai-perceptron-boundary',
                    'ml-rbf-svm-field'
                ],
                'navigation-pack': [
                    'ai-a-star-field',
                    'ai-rrt-explorer',
                    'cs-swarm-dijkstra',
                    'ml-belief-propagation'
                ],
                'generative-pack': [
                    'ai-gan-discriminator-edge',
                    'ai-hopfield-attractor'
                ]
            };
            const ids = bundles[bundleKey] || [];
            const selected = [];
            if (includeCore) selected.push(...corePresets);
            for (const id of ids) {
                const p = presetById[id];
                if (p) selected.push(p);
            }
            if (selected.length === 0) return;
            if (userFunctions.length === 0) {
                addRuleWithPreset(selected[0]);
            } else {
                const first = userFunctions[0].name;
                const ed = editors[first]; if (ed) ed.setValue(selected[0].code);
                if (first !== sanitizeRuleName(selected[0].name)) renameRule(first, selected[0].name);
                const others = userFunctions.slice(1).map(u => u.name);
                others.forEach(nm => deleteRule(nm));
            }
            for (let i = 1; i < selected.length; i++) addRuleWithPreset(selected[i]);
            if (setupCodePane._split) { setupCodePane._split.populateSelects(); setupCodePane._split.updateSplitMounts(); }
            setupConfigUI();
            // Refresh novel config panel visibility after rules change
            if (typeof updateNovelConfigVisibility === 'function') updateNovelConfigVisibility();
        }

        function applyPresetSelection(ids, includeCore) {
            if (!Array.isArray(ids)) return;
            const coreIds = new Set(['cohesion-core','alignment-core','separation-core','novel-core']);
            const corePresets = rulePresets.filter(p => coreIds.has(p.id));
            const presetById = Object.fromEntries(rulePresets.map(p => [p.id, p]));
            // Build a de-duplicated list preserving order: core (optional) then explicit ids
            const selected = [];
            const seen = new Set();
            const pushUnique = (p) => { if (p && !seen.has(p.id)) { seen.add(p.id); selected.push(p); } };
            if (includeCore) corePresets.forEach(pushUnique);
            ids.forEach(id => pushUnique(presetById[id]));
            if (selected.length === 0) return;
            if (userFunctions.length === 0) {
                addRuleWithPreset(selected[0]);
            } else {
                const first = userFunctions[0].name;
                const ed = editors[first]; if (ed) ed.setValue(selected[0].code);
                if (first !== sanitizeRuleName(selected[0].name)) renameRule(first, selected[0].name);
                const others = userFunctions.slice(1).map(u => u.name);
                others.forEach(nm => deleteRule(nm));
            }
            for (let i = 1; i < selected.length; i++) addRuleWithPreset(selected[i]);
            if (setupCodePane._split) { setupCodePane._split.populateSelects(); setupCodePane._split.updateSplitMounts(); }
            setupConfigUI();
        }

        function deleteRule(name) {
            if (!editors[name]) return;
            // Remove from userFunctions
            const idx = userFunctions.findIndex(u => u.name === name);
            if (idx >= 0) userFunctions.splice(idx,1);
            // Remove editor DOM
            const wrapper = editors[name].getWrapperElement();
            if (wrapper && wrapper.parentNode) wrapper.parentNode.removeChild(wrapper);
            delete editors[name];
            // Remove tab and content
            const tabBtn = document.querySelector(`.tab-button[data-tab="${name}"]`);
            const content = document.getElementById(name);
            if (tabBtn && tabBtn.parentNode) tabBtn.parentNode.removeChild(tabBtn);
            if (content && content.parentNode) content.parentNode.removeChild(content);
            // Update active tab
            const firstTab = document.querySelector('.tab-button');
            const firstContentId = firstTab ? firstTab.dataset.tab : null;
            if (firstTab) firstTab.classList.add('active');
            if (firstContentId) {
                const firstContent = document.getElementById(firstContentId);
                if (firstContent) firstContent.classList.add('active');
            }
            // Remove weight config and rebuild UI
            delete config[`${name}Weight`];
            setupConfigUI();
            // Update split
            const leftSel = document.getElementById('split-left');
            const rightSel = document.getElementById('split-right');
            if (leftSel && leftSel.value === name) {
                const other = userFunctions[0] && userFunctions[0].name; if (other) leftSel.value = other;
            }
            if (rightSel && rightSel.value === name) {
                const other = userFunctions.find(u => u.name !== (leftSel && leftSel.value)) || userFunctions[0];
                if (other) rightSel.value = other.name;
            }
            if (setupCodePane._split) { setupCodePane._split.populateSelects(); setupCodePane._split.updateSplitMounts(); }
        }
        
        // --- SIMULATION LOGIC ---

        function createBoids() {
            gameState.boids = [];
            for (let i = 0; i < config.boidCount; i++) {
                gameState.boids.push(new Boid(Math.random() * gameState.width, Math.random() * gameState.height));
            }
            logConfig(`Created ${config.boidCount} boids.`);
        }

        function hardReset() {
            // Reset boids and stats without changing code or config
            createBoids();
            fpsHistory.length = 0;
            updateTimeHistory.length = 0;
            drawablesHistory.length = 0;
            angleHistory.length = 0;
            lastTime = performance.now();
            // Clear charts if present
            if (charts.fpsChart) { charts.fpsChart.data.datasets[0].data = []; charts.fpsChart.update('none'); }
            if (charts.updateTimeChart) { charts.updateTimeChart.data.datasets[0].data = []; charts.updateTimeChart.update('none'); }
            if (charts.drawablesChart) { charts.drawablesChart.data.datasets[0].data = []; charts.drawablesChart.update('none'); }
            if (charts.polarCtx) {
                const c = charts.polarCtx.canvas; charts.polarCtx.clearRect(0,0,c.width,c.height);
            }
            if (charts.meanPolarCtx) {
                const c = charts.meanPolarCtx.canvas; charts.meanPolarCtx.clearRect(0,0,c.width,c.height);
            }
            logConfig('Simulation hard reset.');
        }

        // --- MAIN LOOP ---

        function animate(timestamp) {
            const deltaTime = (timestamp - lastTime) || 0;
            lastTime = timestamp;
            fps = 1000 / deltaTime;
            const t0 = performance.now();
            // Clear per-frame drawables before update so rules can register new ones
            drawables.length = 0;
            update();
            const updateTime = performance.now() - t0;
            draw();
            updateStats(updateTime);
            requestAnimationFrame(animate);
        }

        function update() {
            const boundary = new Rectangle(gameState.width / 2, gameState.height / 2, gameState.width / 2, gameState.height / 2);
            gameState.quadtree = new QuadTree(boundary, 4);
            // Reset quadtree stats per frame
            quadStats.nodeCount = 0; quadStats.leafCount = 0; quadStats.maxDepth = 0; quadStats.avgLeafFill = 0;
            quadStats.queryCount = 0; quadStats.nodesVisitedTotal = 0; quadStats.nodesVisitedAccum = 0; quadStats.nodesVisitedMax = 0;
            quadStats.intersectsChecks = 0; quadStats.pointTests = 0;
            for (let boid of gameState.boids) gameState.quadtree.insert(boid);
            // Summarize the quadtree structure
            (function summarize(node, depth, acc){
                if (!node) return;
                acc.nodeCount++;
                if (depth > acc.maxDepth) acc.maxDepth = depth;
                acc.visitMax = Math.max(acc.visitMax||0, node.visitHits||0);
                if (!node.divided) { acc.leafCount++; acc.leafFillSum = (acc.leafFillSum||0) + node.boids.length; }
                else {
                    summarize(node.northwest, depth+1, acc);
                    summarize(node.northeast, depth+1, acc);
                    summarize(node.southwest, depth+1, acc);
                    summarize(node.southeast, depth+1, acc);
                }
            })(gameState.quadtree, 1, quadStats);
            if (quadStats.leafCount > 0) quadStats.avgLeafFill = (quadStats.leafFillSum||0) / quadStats.leafCount; else quadStats.avgLeafFill = 0;
            // Pheromone decay
            if (pheromones.grid) {
                const g = pheromones.grid; const d = pheromones.decay;
                for (let i = 0; i < g.length; i++) g[i] *= d;
            }
            // Quadtree heat decay
            if (qtHeat.grid) {
                const g = qtHeat.grid; const d = qtHeat.decay;
                for (let i = 0; i < g.length; i++) g[i] *= d;
            }
            // Protect simulation step from rule runtime errors
            for (let boid of gameState.boids) {
                try {
                    boid.update(gameState);
                } catch (e) {
                    if (!update._lastErrorTs || (performance.now() - update._lastErrorTs) > 1000) {
                        console.error('Update step error (continuing):', e);
                        update._lastErrorTs = performance.now();
                    }
                }
            }

            // Apply deferred deletions (by identity)
            if (_pendingKills.size) {
                gameState.boids = gameState.boids.filter(b => !(_pendingKills.has(b)));
                _pendingKills.clear();
            }
            // Apply deferred spawns (respect maxBoids)
            if (_pendingSpawns.length) {
                const cap = Math.max(0, Number(config.maxBoids) || 0) || Infinity;
                while (_pendingSpawns.length && gameState.boids.length < cap) {
                    const req = _pendingSpawns.shift();
                    const nb = new Boid(req.x, req.y);
                    const o = req.opts || {};
                    if (typeof o.hue === 'number') nb.hue = ((o.hue % 360) + 360) % 360;
                    if (typeof o.size === 'number') nb.size = Math.max(1, o.size);
                    if (o.vel && typeof o.vel.x === 'number' && typeof o.vel.y === 'number') {
                        nb.vel.x = o.vel.x; nb.vel.y = o.vel.y;
                    }
                    if (o.role === 'pred' || o.role === 'prey') nb._role = o.role;
                    gameState.boids.push(nb);
                }
                // If queue still has spawns but we hit the cap, drop extras to prevent unbounded growth
                if (gameState.boids.length >= cap) _pendingSpawns.length = 0;
            }
        }

        function draw() {
            // Screen shake transform
            const now = performance.now();
            const dur = Math.max(0, _shake.endTime - now);
            if (dur > 0) {
                const t = dur / 300; // normalize against a nominal 300ms
                const amp = _shake.amplitude * t * t; // ease-out quad
                const ox = (Math.random() * 2 - 1) * amp;
                const oy = (Math.random() * 2 - 1) * amp;
                ctx.save();
                ctx.translate(ox, oy);
            }
            ctx.fillStyle = 'rgba(26, 26, 26, 0.25)';
            ctx.fillRect(0, 0, gameState.width, gameState.height);
            // Draw pheromone heatmap (lightweight grid rendering)
            if (pheromones.grid) {
                const cell = pheromones.cell; const g = pheromones.grid;
                for (let y = 0; y < pheromones.rows; y++) {
                    for (let x = 0; x < pheromones.cols; x++) {
                        const v = g[y * pheromones.cols + x];
                        if (v > 0.02) {
                            const a = Math.min(0.25, v * 0.08);
                            ctx.fillStyle = `hsla(${(config.hue + 60) % 360}, 100%, 60%, ${a.toFixed(3)})`;
                            ctx.fillRect(x * cell, y * cell, cell, cell);
                        }
                    }
                }
            }
            // Draw quadtree hot regions heatmap
            if (qtHeat.grid && config.visualizeQuadtreeHot) {
                const cell = qtHeat.cell; const g = qtHeat.grid;
                for (let y = 0; y < qtHeat.rows; y++) {
                    for (let x = 0; x < qtHeat.cols; x++) {
                        const v = g[y * qtHeat.cols + x];
                        if (v > 0.02) {
                            const a = Math.min(0.22, v * 0.06);
                            ctx.fillStyle = `hsla(${(config.hue + 300) % 360}, 100%, 60%, ${a.toFixed(3)})`;
                            ctx.fillRect(x * cell, y * cell, cell, cell);
                        }
                    }
                }
            }
            if (config.visualizeQuadtree) gameState.quadtree.draw(ctx);
            for (let boid of gameState.boids) boid.draw(ctx);
            // Custom rule drawables (if any)
            if (drawables.length) {
                for (const fn of drawables) {
                    try { fn(ctx, gameState); } catch (e) { console.log(e) }
                }
            }
            if (mouse.down) {
                 ctx.beginPath();
                 ctx.arc(mouse.pos.x, mouse.pos.y, 150, 0, Math.PI * 2);
                 const gradient = ctx.createRadialGradient(mouse.pos.x, mouse.pos.y, 10, mouse.pos.x, mouse.pos.y, 150);
                 gradient.addColorStop(0, `hsla(${config.hue}, 100%, 50%, 0.3)`);
                 gradient.addColorStop(1, `hsla(${config.hue}, 100%, 50%, 0)`);
                 ctx.fillStyle = gradient;
                 ctx.fill();
            }
            ctx.fillStyle = `hsl(${config.hue}, 100%, 50%)`;
            ctx.beginPath();
            ctx.arc(mouse.pos.x, mouse.pos.y, 5, 0, Math.PI * 2);
            ctx.fill();
            // Styled header/subheader panel (centered, rounded, with glow/outline)
            drawHeaderPanel(ctx, gameState.width / 2);

            // Debug: show number of drawables this frame (enable with ?debug=true)
            if (config.debug) {
                ctx.save();
                ctx.textAlign = 'left';
                ctx.fillStyle = '#ccc';
                ctx.font = '12px monospace';
                ctx.fillText(`drawables: ${drawables.length}`, 10, 18);
                ctx.restore();
            }
            // Restore post-shake
            if (dur > 0) {
                ctx.restore();
            }
        }

        // --- UI helpers ---
        function drawHeaderPanel(ctx, centerX) {
            const headerText = (typeof config.header === 'string') ? config.header.trim() : '';
            const subheaderText = (typeof config.subheader === 'string') ? config.subheader.trim() : '';
            if (!headerText && !subheaderText) return;
            const padX = 16, padY = 10, gap = 6, topY = 16, radius = 10;
            // Measure text
            ctx.textAlign = 'center';
            ctx.font = 'bold 36px sans-serif';
            const hMetrics = headerText ? ctx.measureText(headerText) : { width: 0, actualBoundingBoxAscent: 0, actualBoundingBoxDescent: 0 };
            const hAscent = hMetrics.actualBoundingBoxAscent || 28;
            const hDescent = hMetrics.actualBoundingBoxDescent || 8;
            const hLine = headerText ? (hAscent + hDescent) : 0;
            ctx.font = '24px sans-serif';
            const sMetrics = subheaderText ? ctx.measureText(subheaderText) : { width: 0, actualBoundingBoxAscent: 0, actualBoundingBoxDescent: 0 };
            const sAscent = sMetrics.actualBoundingBoxAscent || 18;
            const sDescent = sMetrics.actualBoundingBoxDescent || 6;
            const sLine = subheaderText ? (sAscent + sDescent) : 0;
            const maxWidth = Math.max(hMetrics.width || 0, sMetrics.width || 0);
            const panelW = Math.ceil(maxWidth + padX * 2);
            const panelH = Math.ceil(padY * 2 + hLine + (subheaderText ? (gap + sLine) : 0));
            const panelX = Math.round(centerX - panelW / 2);
            const panelY = topY;
            // Panel background and border
            ctx.save();
            roundRect(ctx, panelX, panelY, panelW, panelH, radius);
            ctx.fillStyle = 'rgba(0,0,0,0.35)';
            ctx.fill();
            ctx.lineWidth = 1;
            ctx.strokeStyle = `hsla(${config.hue}, 100%, 60%, 0.35)`;
            ctx.stroke();
            ctx.restore();
            // Text with subtle glow and dark outline
            const textColor = `hsla(${config.hue}, 100%, 85%, 0.95)`;
            // Header line baseline
            let y = panelY + padY + (headerText ? hAscent : 0);
            if (headerText) {
                ctx.save();
                ctx.font = 'bold 36px sans-serif';
                ctx.fillStyle = textColor;
                ctx.shadowColor = `hsla(${config.hue}, 100%, 55%, 0.45)`;
                ctx.shadowBlur = 10; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0;
                ctx.fillText(headerText, centerX, y);
                ctx.shadowBlur = 0;
                ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(0,0,0,0.45)';
                ctx.strokeText(headerText, centerX, y);
                ctx.restore();
            }
            if (subheaderText) {
                y = panelY + padY + hLine + gap + sAscent;
                ctx.save();
                ctx.font = '24px sans-serif';
                ctx.fillStyle = textColor;
                ctx.shadowColor = 'rgba(0,0,0,0.35)';
                ctx.shadowBlur = 6; ctx.shadowOffsetX = 0; ctx.shadowOffsetY = 0;
                ctx.fillText(subheaderText, centerX, y);
                ctx.shadowBlur = 0;
                ctx.lineWidth = 1.5; ctx.strokeStyle = 'rgba(0,0,0,0.4)';
                ctx.strokeText(subheaderText, centerX, y);
                ctx.restore();
            }
        }

        function roundRect(ctx, x, y, w, h, r) {
            const rr = Math.min(r || 0, w / 2, h / 2);
            ctx.beginPath();
            ctx.moveTo(x + rr, y);
            ctx.lineTo(x + w - rr, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + rr);
            ctx.lineTo(x + w, y + h - rr);
            ctx.quadraticCurveTo(x + w, y + h, x + w - rr, y + h);
            ctx.lineTo(x + rr, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - rr);
            ctx.lineTo(x, y + rr);
            ctx.quadraticCurveTo(x, y, x + rr, y);
            ctx.closePath();
        }

        function updateStats(updateTime) {
            if (isFinite(fps)) {
                document.getElementById('fps-counter').textContent = Math.round(fps);
                fpsHistory.push(fps);
                if (fpsHistory.length > 50) fpsHistory.shift();
                charts.fpsChart.data.datasets[0].data = fpsHistory;
                charts.fpsChart.update('none');
            }
            // Update rule fallback indicators (throttled)
            updateRuleStatusUI();
            document.getElementById('particle-count').textContent = Math.round(config.boidCount);
            if (isFinite(updateTime)) {
                document.getElementById('update-time').textContent = updateTime.toFixed(2);
                updateTimeHistory.push(updateTime);
                if (updateTimeHistory.length > 50) updateTimeHistory.shift();
                const mean = updateTimeHistory.reduce((a, b) => a + b, 0) / updateTimeHistory.length;
                const stdDev = Math.sqrt(updateTimeHistory.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b, 0) / updateTimeHistory.length);
                document.getElementById('update-time-mean').textContent = mean.toFixed(2);
                document.getElementById('update-time-stddev').textContent = stdDev.toFixed(2);
                charts.updateTimeChart.data.datasets[0].data = updateTimeHistory;
                charts.updateTimeChart.update('none');
            }
            // Drawables per frame
            const dCount = Array.isArray(drawables) ? drawables.length : 0;
            const dcEl = document.getElementById('drawables-count');
            if (dcEl) dcEl.textContent = String(dCount);
            drawablesHistory.push(dCount);
            if (drawablesHistory.length > 50) drawablesHistory.shift();
            if (charts.drawablesChart) {
                charts.drawablesChart.data.datasets[0].data = drawablesHistory;
                charts.drawablesChart.update('none');
            }
            if (gameState.boids.length > 0) {
                const sumVec = new Vector(0, 0);
                for (const boid of gameState.boids) sumVec.add(boid.vel.clone().normalize());
                const meanAngle = sumVec.heading();
                const R = sumVec.mag() / gameState.boids.length;
                const stdDev = R < 1 ? Math.sqrt(-2 * Math.log(R)) : 0;
                angleHistory.push({ meanAngle, stdDev });
                if (angleHistory.length > MAX_ANGLE_HISTORY) angleHistory.shift();
            }
            // Quadtree metrics (if UI present)
            const qn = document.getElementById('qt-nodes');
            if (qn) {
                qn.textContent = String(quadStats.nodeCount);
                const ql = document.getElementById('qt-leaves'); if (ql) ql.textContent = String(quadStats.leafCount);
                const qd = document.getElementById('qt-depth'); if (qd) qd.textContent = String(quadStats.maxDepth);
                const qf = document.getElementById('qt-avgfill'); if (qf) qf.textContent = (quadStats.avgLeafFill||0).toFixed(2);
                const qq = document.getElementById('qt-queries'); if (qq) qq.textContent = String(quadStats.queryCount);
                const avgNodes = quadStats.queryCount ? (quadStats.nodesVisitedAccum / quadStats.queryCount) : 0;
                const qa = document.getElementById('qt-avgnodes'); if (qa) qa.textContent = avgNodes.toFixed(2);
                const qm = document.getElementById('qt-maxnodes'); if (qm) qm.textContent = String(quadStats.nodesVisitedMax);
                const qi = document.getElementById('qt-intersects'); if (qi) qi.textContent = String(quadStats.intersectsChecks);
                const qp = document.getElementById('qt-pointtests'); if (qp) qp.textContent = String(quadStats.pointTests);
                // Chart
                qtAvgNodesHistory.push(avgNodes);
                if (qtAvgNodesHistory.length > 50) qtAvgNodesHistory.shift();
                if (charts.qtAvgNodesChart) {
                    charts.qtAvgNodesChart.data.datasets[0].data = qtAvgNodesHistory;
                    charts.qtAvgNodesChart.update('none');
                }
            }

            drawPolarSpiralChart();
            drawMeanPolarChart();
        }

        function drawPolarSpiralChart() {
            if (!charts.polarCtx || angleHistory.length < 2) return;
            const ctx = charts.polarCtx;
            const canvas = ctx.canvas;
            const { width, height } = canvas;
            const centerX = width / 2;
            const centerY = height / 2;
            const maxRadius = Math.min(centerX, centerY) * 0.9;
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 1; i <= 4; i++) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, (maxRadius / 4) * i, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.beginPath();
            for (let i = 0; i < angleHistory.length; i++) {
                const record = angleHistory[i];
                const radius = Math.min(record.stdDev / Math.sqrt(2), 1.0) * maxRadius;
                const x = centerX + radius * Math.cos(record.meanAngle);
                const y = centerY + radius * Math.sin(record.meanAngle);
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.strokeStyle = `hsl(${config.hue}, 100%, 50%)`;
            ctx.lineWidth = 2;
            ctx.stroke();
            const lastRecord = angleHistory[angleHistory.length - 1];
            const lastRadius = Math.min(lastRecord.stdDev / Math.sqrt(2), 1.0) * maxRadius;
            const lastX = centerX + lastRadius * Math.cos(lastRecord.meanAngle);
            const lastY = centerY + lastRadius * Math.sin(lastRecord.meanAngle);
            ctx.beginPath();
            ctx.arc(lastX, lastY, 4, 0, Math.PI * 2);
            ctx.fillStyle = 'white';
            ctx.fill();
        }

        function drawMeanPolarChart() {
            if (!charts.meanPolarCtx || angleHistory.length < 2) return;
            const ctx = charts.meanPolarCtx;
            const canvas = ctx.canvas;
            const { width, height } = canvas;
            const centerX = width / 2;
            const centerY = height / 2;
            const maxRadius = Math.min(centerX, centerY) * 0.9;

            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, width, height);
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 5, centerX, centerY, maxRadius);
            bgGradient.addColorStop(0, '#222');
            bgGradient.addColorStop(1, '#111');
            ctx.beginPath();
            ctx.arc(centerX, centerY, maxRadius, 0, Math.PI * 2);
            ctx.fillStyle = bgGradient;
            ctx.fill();

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 1; i <= 4; i++) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, (maxRadius / 4) * i, 0, Math.PI * 2);
                ctx.stroke();
            }
            for (let i = 0; i < 8; i++) {
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + maxRadius * Math.cos(i * Math.PI / 4), centerY + maxRadius * Math.sin(i * Math.PI / 4));
                ctx.stroke();
            }

            if (charts.showStdDevBands.checked) {
                ctx.beginPath();
                for (let i = 0; i < angleHistory.length; i++) {
                    const radius = (i / MAX_ANGLE_HISTORY) * maxRadius;
                    const x = centerX + radius * Math.cos(angleHistory[i].meanAngle + angleHistory[i].stdDev);
                    const y = centerY + radius * Math.sin(angleHistory[i].meanAngle + angleHistory[i].stdDev);
                    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                }
                for (let i = angleHistory.length - 1; i >= 0; i--) {
                    const radius = (i / MAX_ANGLE_HISTORY) * maxRadius;
                    const x = centerX + radius * Math.cos(angleHistory[i].meanAngle - angleHistory[i].stdDev);
                    const y = centerY + radius * Math.sin(angleHistory[i].meanAngle - angleHistory[i].stdDev);
                    ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fillStyle = `hsla(${config.hue}, 100%, 50%, 0.15)`;
                ctx.fill();
            }
            
            ctx.beginPath();
            for (let i = 0; i < angleHistory.length; i++) {
                const radius = (i / MAX_ANGLE_HISTORY) * maxRadius;
                const x = centerX + radius * Math.cos(angleHistory[i].meanAngle);
                const y = centerY + radius * Math.sin(angleHistory[i].meanAngle);
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            const lineGradient = ctx.createLinearGradient(centerX - maxRadius, centerY, centerX + maxRadius, centerY);
            lineGradient.addColorStop(0, `hsl(${config.hue}, 100%, 30%)`);
            lineGradient.addColorStop(0.5, `hsl(${config.hue}, 100%, 50%)`);
            lineGradient.addColorStop(1, `hsl(${config.hue}, 100%, 70%)`);
            ctx.strokeStyle = lineGradient;
            ctx.lineWidth = 2;
            ctx.stroke();

            const lastRecord = angleHistory[angleHistory.length - 1];
            const lastRadius = ((angleHistory.length - 1) / MAX_ANGLE_HISTORY) * maxRadius;
            const lastX = centerX + lastRadius * Math.cos(lastRecord.meanAngle);
            const lastY = centerY + lastRadius * Math.sin(lastRecord.meanAngle);
            ctx.beginPath();
            ctx.arc(lastX, lastY, 4, 0, Math.PI * 2);
            ctx.fillStyle = 'white';
            ctx.fill();

            const meanDeg = (lastRecord.meanAngle * 180 / Math.PI + 360) % 360;
            const stdDevDeg = lastRecord.stdDev * 180 / Math.PI;
            ctx.font = `12px ${getComputedStyle(document.documentElement).getPropertyValue('--font-mono')}`;
            ctx.fillStyle = '#ccc';
            ctx.textAlign = 'left';
            ctx.fillText(`Mean: ${meanDeg.toFixed(1)}°`, 10, 20);
            ctx.fillText(`StdDev: ${stdDevDeg.toFixed(1)}°`, 10, 35);
        }

        // --- COLOR HELPERS ---
        function hslToHex(h, s, l) {
            l /= 100; const a = s * Math.min(l, 1 - l) / 100;
            const f = n => { const k = (n + h / 30) % 12; const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1); return Math.round(255 * color).toString(16).padStart(2, '0'); };
            return `#${f(0)}${f(8)}${f(4)}`;
        }
        function hexToHsl(hex) {
            let r=0,g=0,b=0; if(hex.length==4){r=parseInt(hex[1]+hex[1],16);g=parseInt(hex[2]+hex[2],16);b=parseInt(hex[3]+hex[3],16);}else if(hex.length==7){r=parseInt(hex[1]+hex[2],16);g=parseInt(hex[3]+hex[4],16);b=parseInt(hex[5]+hex[6],16);}
            r/=255;g/=255;b/=255; let cmin=Math.min(r,g,b),cmax=Math.max(r,g,b),delta=cmax-cmin,h=0,s=0,l=0;
            if(delta==0)h=0;else if(cmax==r)h=((g-b)/delta)%6;else if(cmax==g)h=(b-r)/delta+2;else h=(r-g)/delta+4;
            h=Math.round(h*60); if(h<0)h+=360; l=(cmax+cmin)/2; s=delta==0?0:delta/(1-Math.abs(2*l-1)); s=+(s*100).toFixed(1);l=+(l*100).toFixed(1); return[h,s,l];
        }

        // --- START ---
        init();
    })();
    </script>
</body>
</html>
