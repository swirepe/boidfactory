<!DOCTYPE html>
<!--
  Boids Simulation – Single-file Lab (v1.2)
  
  Goals
  - Clean, readable structure with sectioned comments
  - Smartly documented example rules (cohesion/separation/alignment/novel)
  - Minimal external dependencies (CDN for editors/charts only)

  Structure
  - CSS: variables, layout, overlays, code pane, charts
  - HTML: full-screen canvas, overlays (config/stats/help), code pane tabs
  - JS: utilities → simulation core → UI → main loop → charts → helpers

  Notes
  - Example rule code is editable live; each rule must return a Vector.
  - The dynamic function scope provides: boid, gameState, neighbors, config, mouse, Vector.
  - Keep rule code side-effect free (only return a force vector) for clarity.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Boids Simulation</title>
    <style>
        :root {
            --hue: 200;
            --font-mono: 'SF Mono', 'Consolas', 'Courier New', monospace;
            --primary-color: hsl(var(--hue), 100%, 50%);
            --secondary-color: hsl(var(--hue), 50%, 70%);
            --background-color: #1a1a1a;
            --text-color: #f0f0f0;
            --overlay-bg-color: rgba(20, 20, 20, 0.9);
            --border-color: var(--primary-color);
        }
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--background-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas {
            display: block;
            cursor: none;
        }
        .overlay {
            position: fixed;
            top: 10px;
            background-color: var(--overlay-bg-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            max-height: calc(100vh - 80px);
            overflow-y: auto;
            transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.4s;
            transform: translateX(120%);
            opacity: 0;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
            z-index: 1002;
            font-family: var(--font-mono);
        }
        .overlay.visible {
            transform: translateX(0);
            opacity: 1;
        }
        .close-button {
            position: absolute;
            top: 5px;
            right: 10px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            padding: 5px;
            line-height: 1;
        }
        .close-button:hover {
            color: var(--primary-color);
        }
        .overlay-toggle-container {
            position: fixed;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1001;
        }
        /* Hide overlay buttons when code pane is maximized */
        body.code-pane-maximized .overlay-toggle-container { display: none; }
        /* Subtle enter/leave transitions for temporary Code overlay button */
        #overlay-code-button {
            opacity: 1;
            transform: translateY(0);
            transition: opacity 0.22s ease, transform 0.22s ease;
        }
        #overlay-code-button.entering,
        #overlay-code-button.leaving {
            opacity: 0;
            transform: translateY(-6px);
        }
        .overlay-toggle {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.2s, transform 0.2s;
            font-weight: bold;
            font-family: var(--font-mono);
        }
        .overlay-toggle:hover {
            background-color: hsl(var(--hue), 100%, 60%);
            transform: scale(1.05);
        }
        #config-overlay { right: 10px; width: 320px; }
        #stats-overlay { right: 10px; width: 320px; text-align: left; }
        #help-overlay { right: 10px; width: 450px; }

        /* Code Pane: supports docking to bottom, left, or maximized */
        #code-pane {
            position: fixed;
            background-color: var(--overlay-bg-color);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1), width 0.2s, height 0.2s;
        }
        /* Bottom dock (default) */
        #code-pane.dock-bottom { left: 0; bottom: 0; width: 100%; border-top: 2px solid var(--border-color); }
        #code-pane.dock-bottom:not(.visible) { transform: translateY(calc(100% - 40px)); }
        #code-pane.dock-bottom.visible { transform: translateY(0); height: 40vh; }
        /* Left dock */
        #code-pane.dock-left { top: 0; left: 0; height: 100vh; width: 40vw; min-width: 320px; border-right: 2px solid var(--border-color); }
        #code-pane.dock-left:not(.visible) { transform: translateX(-100%); }
        #code-pane.dock-left.visible { transform: translateX(0); }
        /* Maximized */
        #code-pane.maximized { top: 0; left: 0; width: 100vw; height: 100vh; border-top: 2px solid var(--border-color); transform: none !important; }
        #code-pane.maximized .code-pane-toggle { background-color: var(--primary-color); }
        .code-pane-toggle {
            background-color: var(--primary-color);
            color: white;
            border: none;
            width: 100%;
            padding: 10px;
            cursor: pointer;
            font-size: 16px;
            font-family: var(--font-mono);
            display: flex;
            align-items: center;
            gap: 8px;
            text-align: left;
        }
        .code-icon { width: 18px; height: 18px; opacity: 0.9; }
        .code-label { flex: 1; }
        /* Dock controls */
        .dock-controls { display: flex; gap: 6px; }
        .dock-btn {
            background: transparent;
            border: none;
            color: rgba(255,255,255,0.8);
            width: 32px;
            height: 32px;
            padding: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.15s ease, color 0.15s ease;
        }
        .dock-btn:hover { opacity: 1; }
        .dock-btn svg { width: 20px; height: 20px; display: block; }
        .dock-btn.active { color: var(--primary-color); opacity: 1; }
        .code-tabs { display: flex; align-items: center; gap: 6px; padding: 0 6px; flex-shrink: 0; }
        .code-tabs .dock-controls { margin-left: auto; }
        .tab-button {
            flex-grow: 1;
            padding: 10px;
            cursor: pointer;
            background-color: #333;
            border: none;
            color: white;
            border-bottom: 3px solid transparent;
            transition: background-color 0.2s;
            font-family: var(--font-mono);
        }
        .tab-button.active {
            background-color: var(--background-color);
            border-bottom-color: var(--primary-color);
        }
        /* Indicator when a rule is using fallback due to recent runtime errors */
        .tab-button.fallback-active { position: relative; }
        .tab-button.fallback-active::after {
            content: '';
            position: absolute;
            top: 6px;
            right: 8px;
            width: 8px;
            height: 8px;
            background: #ff4d4f; /* subtle red dot */
            border-radius: 50%;
            box-shadow: 0 0 0 2px rgba(0,0,0,0.3);
        }
        @keyframes flash-success {
            50% { background-color: hsl(var(--hue), 100%, 30%); }
        }
        @keyframes flash-error {
            50% { background-color: #801c1c; }
        }
        .tab-button.reloaded-success {
            animation: flash-success 0.6s ease-in-out;
        }
        .tab-button.reloaded-error {
            animation: flash-error 0.6s ease-in-out;
        }
        .tab-content {
            display: none;
            flex-grow: 1;
        }
        .tab-content.active {
            display: block;
        }
        /* Maximized split controls and panes */
        .split-controls { display: none !important; }
        .split-controls label { font-family: var(--font-mono); font-size: 12px; color: #ddd; }
        .split-controls select { background: #333; color: #fff; border: 1px solid #555; padding: 4px 6px; border-radius: 4px; }
        .split-view { display: none; }
        #code-pane.maximized.split-on .split-view { display: flex; gap: 8px; }
        .split-pane { flex: 1; min-width: 0; padding: 6px; box-sizing: border-box; }
        /* Hide tabs when in split mode, but keep row for dock icons */
        #code-pane.maximized.split-on .tab-button { display: none; }
        /* Show split toggle icon only in maximized mode */
        .dock-btn[data-action="toggle-split"] { display: none; }
        #code-pane.maximized .dock-btn[data-action="toggle-split"] { display: inline-flex; }
        /* Split pickers inside the tabs row */
        .split-picker { display: none; }
        #code-pane.maximized.split-on .code-tabs { display: flex; align-items: center; gap: 8px; padding: 0 6px; }
        #code-pane.maximized.split-on .split-picker { display: block; }
        #code-pane.maximized.split-on .dock-controls { margin-left: auto; }
        .rule-actions { display: inline-flex; gap: 6px; }
        .rule-btn { background: transparent; border: none; color: rgba(255,255,255,0.8); width: 28px; height: 28px; display: inline-flex; align-items: center; justify-content: center; cursor: pointer; opacity: 0.8; }
        .rule-btn:hover { opacity: 1; color: var(--primary-color); }
        .split-picker select { background: #333; color: #fff; border: 1px solid #555; padding: 4px 6px; border-radius: 4px; font-family: var(--font-mono); font-size: 12px; }
        .split-picker.split-left { justify-self: start; }
        .split-picker.split-right { justify-self: end; }
        /* Editor sizing by dock mode */
        .CodeMirror { border: none; }
        #code-pane.dock-bottom.visible .CodeMirror { height: calc(40vh - 92px) !important; }
        #code-pane.dock-left .CodeMirror { height: calc(100vh - 92px) !important; }
        #code-pane.maximized .CodeMirror { height: calc(100vh - 92px) !important; }
        /* Minimized left dock: show only icon in header */
        #code-pane.dock-left:not(.visible) .code-label { display: none; }
        #code-pane.dock-left:not(.visible) .code-tabs { display: none; }
        #code-pane.dock-left:not(.visible) .code-pane-toggle { width: 48px; justify-content: center; }
        .config-item {
            margin-bottom: 12px;
        }
        .config-item label {
            display: block;
            margin-bottom: 5px;
        }
        .config-item input[type="range"], .config-item select {
            width: 100%;
        }
        .config-item select {
             background-color: #333;
             color: white;
             border: 1px solid #555;
             padding: 5px;
             border-radius: 3px;
        }
        .config-item input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            padding: 0;
        }
        h2, h3 {
            color: var(--primary-color);
            margin-top: 0;
            font-family: var(--font-mono);
            font-weight: 500;
        }
        #stats-overlay h3 { color: var(--secondary-color); }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 300px;
            margin: 0 auto;
        }
        .chart-toggle {
            position: absolute;
            bottom: 5px;
            left: 5px;
            background-color: rgba(0,0,0,0.5);
            padding: 5px 8px;
            border-radius: 5px;
            font-size: 12px;
        }
        .chart-toggle label {
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .chart-container canvas {
            background-color: #111;
            border-radius: 5px;
            width: 100%;
            /* aspect-ratio: 1 / 1; */
            display: block;
        }
        #help-overlay code { background-color: #333; padding: 2px 5px; border-radius: 3px; }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/dracula.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/lint/lint.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/show-hint.min.css">
</head>
<body>
    <canvas id="boids-canvas"></canvas>
    
    <div class="overlay-toggle-container">
        <button class="overlay-toggle" data-overlay="config-overlay">Config</button>
        <button class="overlay-toggle" data-overlay="stats-overlay">Stats</button>
        <button class="overlay-toggle" data-overlay="help-overlay">Help</button>
        <button class="overlay-toggle" id="reset-button" title="Reset simulation (boids + stats)">Reset</button>
    </div>

    <div class="overlay" id="config-overlay"></div>
    <div class="overlay" id="stats-overlay"></div>
    <div class="overlay" id="help-overlay"></div>

    <div id="code-pane" class="dock-bottom">
        <button class="code-pane-toggle">
            <!-- Minimalist editor icon (window with lines) -->
            <svg class="code-icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <rect x="3" y="5" width="18" height="14" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="1.5"/>
                <circle cx="6.5" cy="7.5" r="0.9" fill="currentColor"/>
                <circle cx="9.5" cy="7.5" r="0.9" fill="currentColor"/>
                <line x1="6" y1="11" x2="18" y2="11" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                <line x1="6" y1="14" x2="15" y2="14" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
            </svg>
            <span class="code-label">Code</span>
        </button>
        <div class="code-tabs">
            <span class="split-picker split-left"><select id="split-left"></select></span>
            <span class="split-picker split-right"><select id="split-right"></select></span>
            <span class="rule-actions" aria-label="Rule actions">
                <button class="rule-btn" id="rule-new-btn" title="New rule" aria-label="New rule">＋</button>
                <button class="rule-btn" id="rule-rename-btn" title="Rename rule" aria-label="Rename rule">✎</button>
                <button class="rule-btn" id="rule-delete-btn" title="Delete rule" aria-label="Delete rule">🗑</button>
            </span>
            <button class="tab-button active" data-tab="cohesion">Cohesion</button>
            <button class="tab-button" data-tab="separation">Separation</button>
            <button class="tab-button" data-tab="alignment">Alignment</button>
            <button class="tab-button" data-tab="novel">Novel</button>
            <span class="dock-controls" aria-label="Code pane docking controls">
                <!-- Split toggle icon: two panes -->
                <button class="dock-btn" data-action="toggle-split" title="Toggle split view" aria-label="Toggle split view">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <rect x="4" y="5" width="16" height="14" rx="2"/>
                        <line x1="12" y1="6" x2="12" y2="19" stroke="currentColor" stroke-width="1.5"/>
                    </svg>
                </button>
                <!-- Bottom dock icon: bottom band inside a window -->
                <button class="dock-btn" data-dock="bottom" title="Dock bottom" aria-label="Dock bottom">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <rect x="4" y="5" width="16" height="14" rx="2"/>
                        <rect x="5.5" y="16" width="13" height="2.5" fill="currentColor" stroke="none"/>
                    </svg>
                </button>
                <!-- Left dock icon: left band inside a window -->
                <button class="dock-btn" data-dock="left" title="Dock left" aria-label="Dock left">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <rect x="4" y="5" width="16" height="14" rx="2"/>
                        <rect x="5.5" y="6.5" width="2.5" height="11" fill="currentColor" stroke="none"/>
                    </svg>
                </button>
                <!-- Maximize icon: full window fill -->
                <button class="dock-btn" data-dock="max" title="Maximize" aria-label="Maximize">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <rect x="4" y="5" width="16" height="14" rx="2"/>
                        <rect x="5.5" y="6.5" width="13" height="11" fill="currentColor" stroke="none"/>
                    </svg>
                </button>
            </span>
            
        </div>
        <div class="split-view" id="split-view">
            <div class="split-pane" data-slot="left"></div>
            <div class="split-pane" data-slot="right"></div>
        </div>
        <div id="cohesion" class="tab-content active"><textarea></textarea></div>
        <div id="separation" class="tab-content"><textarea></textarea></div>
        <div id="alignment" class="tab-content"><textarea></textarea></div>
        <div id="novel" class="tab-content"><textarea></textarea></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jshint/2.13.4/jshint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/lint/lint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/lint/javascript-lint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/show-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/javascript-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.1/chart.min.js"></script>
    
    <script>
    (() => {
        'use strict';

        /**
         * Typedefs to clarify rule API, in-scope vars, and common shapes.
         * These help autocomplete and readability in the embedded editors.
         */
        /**
         * @typedef {Object} Vector
         * @property {number} x
         * @property {number} y
         * @property {(v: Vector) => Vector} add
         * @property {(v: Vector) => Vector} sub
         * @property {(s: number) => Vector} mult
         * @property {(s: number) => Vector} div
         * @property {() => number} mag
         * @property {() => Vector} normalize
         * @property {(max: number) => Vector} limit
         * @property {() => number} heading
         * @property {() => Vector} clone
         */
        /** @typedef {{pos: Vector, vel: Vector, acc: Vector, maxSpeed: number, maxForce: number, hue: number, size: number, update: (gs: GameState) => void, draw: (ctx: CanvasRenderingContext2D) => void}} Boid */
        /** @typedef {{boids: Boid[], quadtree: any, width: number, height: number}} GameState */
        /** @typedef {{pos: {x: number, y: number}, down: boolean}} Mouse */
        /**
         * @typedef {Object} Config
         * @property {number} hue
         * @property {number} boidCount
         * @property {number} maxSpeed
         * @property {number} maxForce
         * @property {number} perceptionRadius
         * @property {boolean} visualizeQuadtree
         * @property {boolean} debug
         * @property {number} cohesionWeight
         * @property {number} separationWeight
         * @property {number} alignmentWeight
         * @property {number} novelWeight
         * @property {'triangle'|'circle'|'oval'|'ring'} boidShape
         * @property {number} boidSize
         * @property {number} boidSizeVariance
         * @property {string} header
         * @property {string} subheader
         */
        /**
         * @callback RuleFunction
         * @param {Boid} boid
         * @param {GameState} gameState
         * @param {Boid[]} neighbors
         * @param {Config} config
         * @param {Mouse} mouse
         * @param {typeof Vector} Vector
         * @returns {Vector}
         */

        // --- GLOBAL STATE & CONSTANTS ---
        const canvas = document.getElementById('boids-canvas');
        const ctx = canvas.getContext('2d');

        let config = {};
        const editors = {};
        const charts = {};
        
        let gameState = {
            boids: [],
            quadtree: null,
            width: 0,
            height: 0,
        };

        const mouse = {
            pos: { x: -1000, y: -1000 },
            down: false,
            clickEffect: null
        };

        let lastTime = 0;
        let fps = 0;
        const fpsHistory = [];
        const updateTimeHistory = [];
        const angleHistory = [];
        const MAX_ANGLE_HISTORY = 750;

        const userFunctions = [];

        // --- UTILITY CLASSES & FUNCTIONS ---

        class Vector {
            constructor(x = 0, y = 0) { this.x = x; this.y = y; }
            add(v) { this.x += v.x; this.y += v.y; return this; }
            sub(v) { this.x -= v.x; this.y -= v.y; return this; }
            mult(s) { this.x *= s; this.y *= s; return this; }
            div(s) { if (s !== 0) { this.x /= s; this.y /= s; } return this; }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            normalize() { const m = this.mag(); if (m > 0) this.div(m); return this; }
            limit(max) { if (this.mag() > max) { this.normalize().mult(max); } return this; }
            heading() { return Math.atan2(this.y, this.x); }
            clone() { return new Vector(this.x, this.y); }
            static add(v1, v2) { return new Vector(v1.x + v2.x, v1.y + v2.y); }
            static sub(v1, v2) { return new Vector(v1.x - v2.x, v1.y - v2.y); }
            static dist(v1, v2) { return Vector.sub(v1, v2).mag(); }
            static random2D() { const angle = Math.random() * Math.PI * 2; return new Vector(Math.cos(angle), Math.sin(angle)); }
        }

        function getURLParams() {
            const params = new URLSearchParams(window.location.search);
            const result = {};
            for (const [key, value] of params) {
                try {
                    result[key] = JSON.parse(value);
                } catch (e) {
                    result[key] = value;
                }
            }
            return result;
        }

        function updateURL(key, value) {
            const params = new URLSearchParams(window.location.search);
            params.set(key, JSON.stringify(value));
            const newUrl = `${window.location.pathname}?${params.toString()}`;
            window.history.pushState({ path: newUrl }, '', newUrl);
            logConfig(`URL updated: ${key} = ${JSON.stringify(value)}`);
        }

        function updateAllURLParams() {
            if (!config.debug) return;
            const params = new URLSearchParams();
            for (const key in config) {
                params.set(key, JSON.stringify(config[key]));
            }
            const newUrl = `${window.location.pathname}?${params.toString()}`;
            window.history.replaceState({ path: newUrl }, '', newUrl);
            logConfig('Debug mode: All config params updated in URL.');
        }
        
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function logConfig(...args) {
            if (config.debug) {
                console.log('[Boids Log]', ...args);
            }
        }

        // --- SIMULATION CORE ---

        class Rectangle {
            constructor(x, y, w, h) {
                this.x = x; this.y = y; this.w = w; this.h = h;
            }
            contains(boid) {
                return (boid.pos.x >= this.x - this.w &&
                        boid.pos.x < this.x + this.w &&
                        boid.pos.y >= this.y - this.h &&
                        boid.pos.y < this.y + this.h);
            }
            intersects(range) {
                return !(range.x - range.w > this.x + this.w ||
                         range.x + range.w < this.x - this.w ||
                         range.y - range.h > this.y + this.h ||
                         range.y + range.h < this.y - this.h);
            }
        }

        class QuadTree {
            constructor(boundary, capacity) {
                this.boundary = boundary;
                this.capacity = capacity;
                this.boids = [];
                this.divided = false;
            }

            subdivide() {
                const { x, y, w, h } = this.boundary;
                const nw = new Rectangle(x - w / 2, y - h / 2, w / 2, h / 2);
                this.northwest = new QuadTree(nw, this.capacity);
                const ne = new Rectangle(x + w / 2, y - h / 2, w / 2, h / 2);
                this.northeast = new QuadTree(ne, this.capacity);
                const sw = new Rectangle(x - w / 2, y + h / 2, w / 2, h / 2);
                this.southwest = new QuadTree(sw, this.capacity);
                const se = new Rectangle(x + w / 2, y + h / 2, w / 2, h / 2);
                this.southeast = new QuadTree(se, this.capacity);
                this.divided = true;
            }

            insert(boid) {
                if (!this.boundary.contains(boid)) return false;
                if (this.boids.length < this.capacity) {
                    this.boids.push(boid);
                    return true;
                }
                if (!this.divided) this.subdivide();
                return this.northeast.insert(boid) || this.northwest.insert(boid) || this.southeast.insert(boid) || this.southwest.insert(boid);
            }

            query(range, found = []) {
                if (!this.boundary.intersects(range)) return found;
                for (let b of this.boids) {
                    if (range.contains(b)) found.push(b);
                }
                if (this.divided) {
                    this.northwest.query(range, found);
                    this.northeast.query(range, found);
                    this.southwest.query(range, found);
                    this.southeast.query(range, found);
                }
                return found;
            }

            draw(ctx) {
                ctx.strokeStyle = `hsla(${config.hue}, 100%, 50%, 0.2)`;
                ctx.strokeRect(this.boundary.x - this.boundary.w, this.boundary.y - this.boundary.h, this.boundary.w * 2, this.boundary.h * 2);
                if (this.divided) {
                    this.northeast.draw(ctx); this.northwest.draw(ctx);
                    this.southeast.draw(ctx); this.southwest.draw(ctx);
                }
            }
        }
        
        class Boid {
            constructor(x, y) {
                this.pos = new Vector(x, y);
                this.vel = Vector.random2D().mult(Math.random() * 2 + 2);
                this.acc = new Vector();
                this.maxSpeed = config.maxSpeed;
                this.maxForce = config.maxForce;
                this.hue = (config.hue + (Math.random() * 60 - 30) + 360) % 360;
                this.size = Math.max(1, config.boidSize + (Math.random() * 2 - 1) * config.boidSizeVariance);
            }

            update(gameState) {
                const perceptionRadius = config.perceptionRadius;
                const range = new Rectangle(this.pos.x, this.pos.y, perceptionRadius, perceptionRadius);
                const neighbors = gameState.quadtree.query(range).filter(other => other !== this);
                this.acc.mult(0);
                for (const fn of userFunctions) {
                    if (fn.weight > 0 && fn.updateBoid) {
                        const force = fn.updateBoid(this, gameState, neighbors);
                        if (force instanceof Vector) {
                           force.mult(fn.weight);
                           this.acc.add(force);
                        }
                    }
                }
                this.vel.add(this.acc);
                this.vel.limit(this.maxSpeed);
                this.pos.add(this.vel);
                this.edges();
            }

            edges() {
                if (this.pos.x > gameState.width) this.pos.x = 0;
                else if (this.pos.x < 0) this.pos.x = gameState.width;
                if (this.pos.y > gameState.height) this.pos.y = 0;
                else if (this.pos.y < 0) this.pos.y = gameState.height;
            }

            draw(ctx) {
                const angle = this.vel.heading();
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.rotate(angle);
                ctx.fillStyle = `hsl(${this.hue}, 100%, 70%)`;
                ctx.strokeStyle = `hsl(${this.hue}, 100%, 70%)`;
                ctx.beginPath();
                switch (config.boidShape) {
                    case 'circle':
                        ctx.arc(0, 0, this.size / 1.5, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'ring':
                        ctx.arc(0, 0, this.size / 2, 0, Math.PI * 2);
                        ctx.lineWidth = Math.max(1, this.size / 4);
                        ctx.stroke();
                        break;
                    case 'oval':
                        ctx.scale(1.5, 0.6);
                        ctx.arc(0, 0, this.size / 2, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'triangle':
                    default:
                        ctx.moveTo(this.size, 0);
                        ctx.lineTo(-this.size / 2, -this.size / 2);
                        ctx.lineTo(-this.size / 2, this.size / 2);
                        ctx.closePath();
                        ctx.fill();
                        break;
                }
                ctx.restore();
            }
        }

        // --- DEFAULT USER FUNCTIONS ---
        
        const defaultFunctionsCode = {
          cohesion: `/**
  Rule API
  @function rule
  @param {Boid} boid - Current boid under update (pos, vel, acc, maxSpeed, maxForce, size, hue)
  @param {{boids: Boid[], quadtree: any, width: number, height: number}} gameState - Global sim state
  @param {Boid[]} neighbors - Nearby boids (pre-filtered by perception)
  @param {Object} config - Live configuration (e.g., perceptionRadius, weights, boidShape, etc.)
  @param {{pos: {x:number, y:number}, down: boolean}} mouse - Pointer state
  @param {typeof Vector} Vector - 2D vector helper class
  @returns {Vector} Steering force to apply this frame

  Cohesion: steer toward the average position of nearby boids.
  Steps:
    1) Average neighbor positions within perception radius
    2) Desired velocity toward that center at maxSpeed
    3) Steering = desired - current velocity, limited to maxForce
*/
const radius = config.perceptionRadius;
let center = new Vector(0, 0);
let total = 0;
for (const other of neighbors) {
  if (other !== boid) {
    const d = Vector.dist(boid.pos, other.pos);
    if (d > 0 && d < radius) {
      center.add(other.pos);
      total++;
    }
  }
}
if (total === 0) return new Vector(0, 0);
center.div(total);
const desired = Vector.sub(center, boid.pos).normalize().mult(boid.maxSpeed);
return Vector.sub(desired, boid.vel).limit(boid.maxForce);`,

          separation: `/**
  Rule API
  @function rule
  @param {Boid} boid
  @param {{boids: Boid[], quadtree: any, width: number, height: number}} gameState
  @param {Boid[]} neighbors
  @param {Object} config
  @param {{pos: {x:number,y:number}, down: boolean}} mouse
  @param {typeof Vector} Vector
  @returns {Vector}

  Separation: steer away from nearby boids to avoid crowding.
  Strategy: Inverse-square falloff (1/d^2) gives strong close-range repulsion.
  Tip: Slightly higher force multiplier helps quick response.
*/
const desiredSeparation = Math.max(8, config.boidSize * 2.5);
let steer = new Vector(0, 0);
let total = 0;
for (const other of neighbors) {
  if (other !== boid) {
    const offset = Vector.sub(boid.pos, other.pos);
    const d = offset.mag();
    if (d > 0 && d < desiredSeparation) {
      // Inverse-square falloff: closer ⇒ stronger
      offset.normalize().div(d * d);
      steer.add(offset);
      total++;
    }
  }
}
if (total === 0) return new Vector(0, 0);
steer.div(total).normalize().mult(boid.maxSpeed);
return Vector.sub(steer, boid.vel).limit(boid.maxForce * 1.5);`,

          alignment: `/**
  Rule API
  @function rule
  @param {Boid} boid
  @param {{boids: Boid[], quadtree: any, width: number, height: number}} gameState
  @param {Boid[]} neighbors
  @param {Object} config
  @param {{pos: {x:number,y:number}, down: boolean}} mouse
  @param {typeof Vector} Vector
  @returns {Vector}

  Alignment: match the average heading (velocity) of neighbors.
*/
const radius = config.perceptionRadius;
let avgVel = new Vector(0, 0);
let total = 0;
for (const other of neighbors) {
  if (other !== boid) {
    const d = Vector.dist(boid.pos, other.pos);
    if (d > 0 && d < radius) {
      avgVel.add(other.vel);
      total++;
    }
  }
}
if (total === 0) return new Vector(0, 0);
avgVel.div(total).normalize().mult(boid.maxSpeed);
return Vector.sub(avgVel, boid.vel).limit(boid.maxForce);`,

          novel: `/**
  Rule API
  @function rule
  @param {Boid} boid
  @param {{boids: Boid[], quadtree: any, width: number, height: number}} gameState
  @param {Boid[]} neighbors
  @param {Object} config
  @param {{pos: {x:number,y:number}, down: boolean}} mouse
  @param {typeof Vector} Vector
  @returns {Vector}

  Novel: mouse-driven flee force when mouse is down.
  Behavior: if within fleeRadius of the cursor, push away proportionally.
*/
const mouseForce = new Vector(0, 0);
const mousePos = new Vector(mouse.pos.x, mouse.pos.y);
const fleeRadius = 150;
const d = Vector.dist(boid.pos, mousePos);
if (mouse.down && d < fleeRadius) {
  const strength = (fleeRadius - d) / fleeRadius; // 0..1
  const desired = Vector.sub(boid.pos, mousePos) // away from mouse
    .normalize()
    .mult(boid.maxSpeed * 2.0 * strength);
  const steer = Vector.sub(desired, boid.vel).limit(boid.maxForce * 2.0);
  mouseForce.add(steer);
}
return mouseForce;`
        };

        // --- INITIALIZATION ---
        
        function init() {
            setupCanvas();
            const urlParams = getURLParams();
            config = {
                hue: 200, boidCount: 200, maxSpeed: 3, maxForce: 0.2,
                perceptionRadius: 50, visualizeQuadtree: true, debug: false,
                cohesionWeight: 1.0, separationWeight: 1.5, alignmentWeight: 1.0, novelWeight: 1.2,
                boidShape: 'triangle', boidSize: 10, boidSizeVariance: 2,
                header: "Boids Simulation", subheader: "Click and drag to interact",
                codePaneDock: 'bottom', // bottom | left | max
                codePaneLeftWidth: null,
                splitLeftRule: 'cohesion',
                splitRightRule: 'separation',
                ...urlParams
            };
            logConfig('Initial config:', config);
            userFunctions.push(
                { name: 'cohesion', weight: config.cohesionWeight, updateBoid: null },
                { name: 'separation', weight: config.separationWeight, updateBoid: null },
                { name: 'alignment', weight: config.alignmentWeight, updateBoid: null },
                { name: 'novel', weight: config.novelWeight, updateBoid: null }
            );
            setupUI();
            setupCodePane();
            applyDockMode(config.codePaneDock);
            createBoids();
            window.addEventListener('resize', debounce(setupCanvas, 250));
            canvas.addEventListener('mousemove', e => { mouse.pos.x = e.clientX; mouse.pos.y = e.clientY; });
            canvas.addEventListener('mousedown', e => { mouse.down = true; });
            canvas.addEventListener('mouseup', e => { mouse.down = false; });
            canvas.addEventListener('touchstart', e => { mouse.down = true; updateTouchPos(e); }, {passive: false});
            canvas.addEventListener('touchend', e => { mouse.down = false; });
            canvas.addEventListener('touchmove', e => { e.preventDefault(); updateTouchPos(e); }, {passive: false});
            lastTime = performance.now();
            animate();
        }

        function updateTouchPos(e) {
            if (e.touches && e.touches.length > 0) {
                mouse.pos.x = e.touches[0].clientX;
                mouse.pos.y = e.touches[0].clientY;
            }
        }

        function setupCanvas() {
            gameState.width = canvas.width = window.innerWidth;
            gameState.height = canvas.height = window.innerHeight;
            if (gameState.boids.length > 0) createBoids();
        }

        // --- UI SETUP ---
        function setupUI() {
            document.documentElement.style.setProperty('--hue', config.hue);
            document.querySelectorAll('.overlay-toggle').forEach(button => {
                button.addEventListener('click', () => {
                    const id = button.dataset.overlay;
                    const targetOverlay = id ? document.getElementById(id) : null;
                    if (!targetOverlay) return;
                    const isVisible = targetOverlay.classList.contains('visible');
                    document.querySelectorAll('.overlay').forEach(o => o.classList.remove('visible'));
                    if (!isVisible) targetOverlay.classList.add('visible');
                });
            });
            // Reset button
            const resetBtn = document.getElementById('reset-button');
            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
                    hardReset();
                });
            }
            document.querySelectorAll('.overlay').forEach(overlay => {
                const closeBtn = document.createElement('button');
                closeBtn.className = 'close-button';
                closeBtn.innerHTML = '&times;';
                closeBtn.onclick = () => overlay.classList.remove('visible');
                overlay.prepend(closeBtn);
            });
            const codePane = document.getElementById('code-pane');
            document.querySelector('.code-pane-toggle').addEventListener('click', (e) => {
                // Ignore clicks on dock control buttons inside the header
                if (e.target && e.target.classList.contains('dock-btn')) return;
                codePane.classList.toggle('visible');
                updateCodeOverlayButton();
                refreshEditors();
            });
            // Dock controls + split toggle
            document.querySelectorAll('.dock-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const action = e.currentTarget.getAttribute('data-action');
                    if (action === 'toggle-split') {
                        config.splitEnabled = !config.splitEnabled;
                        updateSplitModeUI();
                        if (!config.debug) updateURL('splitEnabled', !!config.splitEnabled);
                        return;
                    }
                    const mode = e.currentTarget.getAttribute('data-dock');
                    if (!mode) return;
                    config.codePaneDock = mode === 'max' ? 'max' : (mode === 'left' ? 'left' : 'bottom');
                    applyDockMode(config.codePaneDock);
                    if (config.debug) updateAllURLParams(); else updateURL('codePaneDock', config.codePaneDock);
                });
            });
            updateCodeOverlayButton();
            setupConfigUI();
            setupStatsUI();
            setupHelpUI();
        }

        function applyDockMode(mode) {
            const pane = document.getElementById('code-pane');
            pane.classList.remove('dock-bottom', 'dock-left', 'maximized');
            document.querySelectorAll('.dock-btn').forEach(b => b.classList.remove('active'));
            if (mode === 'left') {
                pane.classList.add('dock-left');
                document.querySelector('.dock-btn[data-dock="left"]').classList.add('active');
                if (config.codePaneLeftWidth && Number.isFinite(+config.codePaneLeftWidth)) {
                    pane.style.width = parseInt(config.codePaneLeftWidth, 10) + 'px';
                } else {
                    pane.style.width = '';
                }
                document.body.classList.remove('code-pane-maximized');
                updateSplitModeUI();
            } else if (mode === 'max' || mode === 'maximized') {
                pane.classList.add('maximized', 'visible');
                document.querySelector('.dock-btn[data-dock="max"]').classList.add('active');
                document.body.classList.add('code-pane-maximized');
                updateSplitModeUI();
            } else {
                pane.classList.add('dock-bottom');
                document.querySelector('.dock-btn[data-dock="bottom"]').classList.add('active');
                document.body.classList.remove('code-pane-maximized');
                updateSplitModeUI();
            }
            updateCodeOverlayButton();
            // Keep collapsed state meaningful for bottom/left
            refreshEditors();
        }

        function updateSplitModeUI() {
            const pane = document.getElementById('code-pane');
            const splitBtn = document.querySelector('.dock-btn[data-action="toggle-split"]');
            const maximized = pane.classList.contains('maximized');
            const enabled = !!config.splitEnabled && maximized;
            pane.classList.toggle('split-on', enabled);
            if (splitBtn) splitBtn.classList.toggle('active', enabled);
            if (setupCodePane._split) {
                if (enabled) {
                    setupCodePane._split.showSplitUI(true);
                    setupCodePane._split.updateSplitMounts();
                } else {
                    setupCodePane._split.showSplitUI(false);
                    setupCodePane._split.unmountAll();
                }
            }
            refreshEditors();
        }

        function updateCodeOverlayButton() {
            const container = document.querySelector('.overlay-toggle-container');
            const pane = document.getElementById('code-pane');
            if (!container || !pane) return;
            const existing = document.getElementById('overlay-code-button');
            const isMax = document.body.classList.contains('code-pane-maximized');
            const needs = pane.classList.contains('dock-left') && !pane.classList.contains('visible') && !isMax;
            if (needs) {
                if (!existing) {
                    const btn = document.createElement('button');
                    btn.id = 'overlay-code-button';
                    btn.className = 'overlay-toggle';
                    btn.textContent = 'Code';
                    btn.title = 'Show code pane';
                    // Start in entering state for fade/slide in
                    btn.classList.add('entering');
                    btn.addEventListener('click', () => {
                        pane.classList.add('visible');
                        updateCodeOverlayButton();
                        refreshEditors();
                    });
                    container.prepend(btn);
                    // Trigger transition on next frame
                    requestAnimationFrame(() => requestAnimationFrame(() => btn.classList.remove('entering')));
                }
            } else if (existing) {
                // If overlays are visible, animate out. If maximized (container hidden), remove immediately.
                if (!document.body.classList.contains('code-pane-maximized')) {
                    if (!existing.dataset.removing) {
                        existing.dataset.removing = '1';
                        existing.classList.add('leaving');
                        const cleanup = () => {
                            existing.removeEventListener('transitionend', cleanup);
                            if (existing && existing.parentNode) existing.parentNode.removeChild(existing);
                        };
                        existing.addEventListener('transitionend', cleanup);
                        // Fallback removal in case transitionend doesn't fire
                        setTimeout(() => cleanup(), 300);
                    }
                } else {
                    existing.remove();
                }
            }
        }

        function refreshEditors() {
            Object.values(editors).forEach(editor => editor.refresh());
        }

        // Throttled UI indicator for rule fallback activity
        let _ruleStatusUITs = 0;
        function updateRuleStatusUI(force = false) {
            const now = performance.now();
            if (!force && now - _ruleStatusUITs < 200) return;
            _ruleStatusUITs = now;
            userFunctions.forEach(fn => {
                const active = !!(fn._fallbackUntil && now < fn._fallbackUntil);
                const tab = document.querySelector(`.tab-button[data-tab="${fn.name}"]`);
                if (tab) {
                    tab.classList.toggle('fallback-active', active);
                    if (active) {
                        tab.dataset.tip = `Fallback active for ${fn.name}`;
                    } else {
                        delete tab.dataset.tip;
                    }
                }
            });
        }

        function setupConfigUI() {
            const container = document.getElementById('config-overlay');
            container.innerHTML = '<h2>Configuration</h2>';
            const closeBtn = document.createElement('button');
            closeBtn.className = 'close-button';
            closeBtn.innerHTML = '&times;';
            closeBtn.onclick = () => container.classList.remove('visible');
            container.prepend(closeBtn);
            
            const createSlider = (id, label, min, max, step, value) => {
                const item = document.createElement('div');
                item.className = 'config-item';
                const valueSpan = document.createElement('span');
                valueSpan.textContent = ` ${Number(value).toFixed(2)}`;
                item.innerHTML = `<label for="${id}">${label}</label>`;
                const input = document.createElement('input');
                input.type = 'range'; input.id = id; input.min = min; input.max = max; input.step = step; input.value = value;
                input.addEventListener('input', e => {
                    const newValue = parseFloat(e.target.value);
                    config[id] = newValue;
                    valueSpan.textContent = ` ${newValue.toFixed(2)}`;
                    if (id.endsWith('Weight')) {
                        const fn = userFunctions.find(f => f.name === id.replace('Weight', ''));
                        if(fn) fn.weight = newValue;
                    }
                    if (config.debug) updateAllURLParams();
                });
                input.addEventListener('change', e => {
                    if (!config.debug) updateURL(id, parseFloat(e.target.value));
                    if (id === 'boidSize' || id === 'boidSizeVariance' || id === 'boidCount') {
                        createBoids();
                    }
                });
                item.appendChild(input);
                item.querySelector('label').appendChild(valueSpan);
                container.appendChild(item);
            };

            const createSelect = (id, label, options, value) => {
                const item = document.createElement('div');
                item.className = 'config-item';
                item.innerHTML = `<label for="${id}">${label}</label>`;
                const select = document.createElement('select');
                select.id = id;
                options.forEach(opt => {
                    const option = document.createElement('option');
                    option.value = opt;
                    option.textContent = opt.charAt(0).toUpperCase() + opt.slice(1);
                    if (opt === value) option.selected = true;
                    select.appendChild(option);
                });
                select.addEventListener('change', e => {
                    config[id] = e.target.value;
                    if (config.debug) updateAllURLParams(); else updateURL(id, e.target.value);
                });
                item.appendChild(select);
                container.appendChild(item);
            };

            createSlider('boidCount', 'Boid Count', 10, 1000, 10, config.boidCount);
            createSlider('boidSize', 'Boid Size', 2, 20, 1, config.boidSize);
            createSlider('boidSizeVariance', 'Size Variance', 0, 10, 0.5, config.boidSizeVariance);
            createSelect('boidShape', 'Boid Shape', ['triangle', 'circle', 'oval', 'ring'], config.boidShape);
            createSlider('maxSpeed', 'Max Speed', 0.5, 10, 0.1, config.maxSpeed);
            createSlider('maxForce', 'Max Force', 0.01, 1, 0.01, config.maxForce);
            createSlider('perceptionRadius', 'Perception', 10, 200, 1, config.perceptionRadius);
            
            userFunctions.forEach(fn => {
                 createSlider(`${fn.name}Weight`, `${fn.name.charAt(0).toUpperCase() + fn.name.slice(1)} Weight`, 0, 5, 0.1, config[`${fn.name}Weight`]);
            });
            
            const createToggle = (id, label, value) => {
                const item = document.createElement('div');
                item.innerHTML = `<label class="config-item"><input type="checkbox" id="${id}" ${value ? 'checked' : ''}> ${label}</label>`;
                item.querySelector('input').addEventListener('change', e => {
                    config[id] = e.target.checked;
                    logConfig(`${id} changed to ${config[id]}`);
                    if (config.debug) updateAllURLParams(); else updateURL(id, config[id]);
                });
                container.appendChild(item);
            };
            createToggle('visualizeQuadtree', 'Show Quadtree', config.visualizeQuadtree);
            createToggle('debug', 'Debug Mode', config.debug);

            const colorItem = document.createElement('div');
            colorItem.className = 'config-item';
            colorItem.innerHTML = `<label for="hue">Theme Hue</label><input type="color" id="hue-picker" value="${hslToHex(config.hue, 100, 50)}">`;
            colorItem.querySelector('#hue-picker').addEventListener('input', e => {
                const hsl = hexToHsl(e.target.value);
                config.hue = hsl[0];
                document.documentElement.style.setProperty('--hue', config.hue);
                if (config.debug) updateAllURLParams(); else updateURL('hue', config.hue);
            });
            container.appendChild(colorItem);
        }
        
        function setupStatsUI() {
            const container = document.getElementById('stats-overlay');
            container.innerHTML = `
                <button class="close-button">&times;</button>
                <h2>Statistics</h2>
                <p>Particle Count: <span id="particle-count">0</span></p>
                <p>FPS: <span id="fps-counter">0</span></p>
                <div><canvas id="fps-chart" height="80"></canvas></div>
                <p>Update Time: <span id="update-time">0.00</span> ms</p>
                <p>(Mean: <span id="update-time-mean">0.00</span>, StdDev: <span id="update-time-stddev">0.00</span>)</p>
                <div><canvas id="update-time-chart" height="80"></canvas></div>
                <h3>Flock Coherence</h3>
                <div class="chart-container"><canvas id="polar-spiral-chart"></canvas></div>
                <h3>Mean Direction</h3>
                <div class="chart-container">
                    <canvas id="mean-polar-chart"></canvas>
                    <div class="chart-toggle">
                        <label><input type="checkbox" id="show-stdev-bands" checked>Show StdDev Bands</label>
                    </div>
                </div>
            `;
            container.querySelector('.close-button').onclick = () => container.classList.remove('visible');
            
            charts.fpsChart = new Chart(document.getElementById('fps-chart').getContext('2d'), {
                type: 'line',
                data: { labels: Array(50).fill(''), datasets: [{ label: 'FPS', data: Array(50).fill(0), borderColor: `hsl(${config.hue}, 100%, 50%)`, borderWidth: 1, pointRadius: 0, tension: 0.4 }] },
                options: { scales: { y: { beginAtZero: true, max: 70 } } }
            });

            charts.updateTimeChart = new Chart(document.getElementById('update-time-chart').getContext('2d'), {
                type: 'line',
                data: { labels: Array(50).fill(''), datasets: [{ label: 'Update Time (ms)', data: Array(50).fill(0), borderColor: `hsl(${(config.hue + 120) % 360}, 100%, 50%)`, borderWidth: 1, pointRadius: 0, tension: 0.4 }] },
                options: { scales: { y: { beginAtZero: true } } }
            });

            charts.polarCtx = document.getElementById('polar-spiral-chart').getContext('2d');
            charts.meanPolarCtx = document.getElementById('mean-polar-chart').getContext('2d');
            charts.showStdDevBands = document.getElementById('show-stdev-bands');
        }
        
        function setupHelpUI() {
            const container = document.getElementById('help-overlay');
            container.innerHTML = `<button class="close-button">&times;</button><h2>Boids Simulation</h2> <p>This is an interactive simulation of flocking behavior, inspired by Craig Reynolds' Boids algorithm.</p> <h3>Configuration</h3> <p>All configuration options are available as URL parameters.</p> <ul><li><b>boidCount, boidSize, boidSizeVariance, boidShape</b></li><li><b>maxSpeed, maxForce, perceptionRadius</b></li><li><b>cohesionWeight, separationWeight, etc.</b></li><li><b>visualizeQuadtree, debug, hue</b></li></ul> <h3>Change Log</h3><p>v1.7 - Added visual success/error indicators for live code reloading.<br>v1.6 - Added boid shape/size configs and monospace font styling.<br>v1.5 - Added beautiful mean direction polar chart with togglable stdev bands.<br>v1.4 - Added close buttons and expanded statistics panel.<br>v1.3 - Fixed critical scope error for dynamic code.<br>v1.2 - Added dynamic polar spiral graph for flock coherence.<br>v1.1 - Fixed critical errors related to dynamic function creation.<br>v1.0 - Initial implementation.</p>`;
            container.querySelector('.close-button').onclick = () => container.classList.remove('visible');
        }

        function setupCodePane() {
            const tabs = document.querySelectorAll('.tab-button');
            const contents = document.querySelectorAll('.tab-content');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    contents.forEach(c => c.classList.remove('active'));
                    tab.classList.add('active');
                    document.getElementById(tab.dataset.tab).classList.add('active');
                    editors[tab.dataset.tab].refresh();
                });
            });

            // Provide lightweight autocompletion with in-scope symbols and common vectors
            function ruleHint(editor) {
                const cur = editor.getCursor();
                const token = editor.getTokenAt(cur);
                const start = token.start;
                const end = cur.ch;
                const word = token.string.trim();
                const from = CodeMirror.Pos(cur.line, start);
                const to = CodeMirror.Pos(cur.line, end);
                const line = editor.getLine(cur.line);
                const before = line.slice(0, cur.ch);
                const isConfigCtx = /(^|\W)config\.$/.test(before);
                const configKeys = Object.keys(config || {}).map(k => `config.${k}`);
                const base = [
                    'boid', 'boid.pos', 'boid.vel', 'boid.acc', 'boid.maxSpeed', 'boid.maxForce', 'boid.size', 'boid.hue',
                    'gameState', 'gameState.width', 'gameState.height', 'gameState.boids', 'neighbors',
                    'config',
                    'mouse', 'mouse.pos.x', 'mouse.pos.y', 'mouse.down',
                    'Vector', 'Vector.sub', 'Vector.dist', 'Vector.random2D',
                    'add()', 'sub()', 'mult()', 'div()', 'mag()', 'normalize()', 'limit()', 'heading()', 'clone()',
                    'return new Vector(0, 0)', 'const v = new Vector(0, 0)'
                ];
                const pool = isConfigCtx ? configKeys : base.concat(configKeys);
                // Deduplicate and filter by current token
                const seen = new Set();
                const list = pool.filter(s => {
                    const key = s.toLowerCase();
                    if (seen.has(key)) return false;
                    seen.add(key);
                    return !word || key.startsWith(word.toLowerCase());
                });
                return { list, from, to };
            }

            const originalParents = {};

            for (const fn of userFunctions) {
                const textarea = document.querySelector(`#${fn.name} textarea`);
                textarea.value = defaultFunctionsCode[fn.name];
                editors[fn.name] = CodeMirror.fromTextArea(textarea, {
                    mode: 'javascript', theme: 'dracula', lineNumbers: true,
                    lint: true, gutters: ["CodeMirror-lint-markers"],
                    extraKeys: { 'Ctrl-Space': 'autocomplete' },
                    hintOptions: { hint: ruleHint, completeSingle: false }
                });
                originalParents[fn.name] = document.getElementById(fn.name);

                // Live-compile user rule code into a function with a narrow, explicit scope.
                // Scope parameters available inside the editor code:
                //   boid (Boid), gameState ({boids, quadtree, width, height}), neighbors (Boid[]),
                //   config (object), mouse ({pos, down}), Vector (math helper)
                const updateFunction = debounce((editor) => {
                    const tabButton = document.querySelector(`.tab-button[data-tab="${fn.name}"]`);
                    try {
                        const code = editor.getValue();
                        const params = ['boid', 'gameState', 'neighbors', 'config', 'mouse', 'Vector'];
                        const dynamicFunc = new Function(...params, code);
                        const prev = fn.updateBoid;

                        // Dry-run with a tiny mock to validate (no side effects expected)
                        const mockBoid = new Boid(0, 0);
                        const mockState = { boids: [mockBoid], quadtree: null, width: 10, height: 10 };
                        const mockNeighbors = [];
                        let ok = true;
                        try {
                            const res = dynamicFunc(mockBoid, mockState, mockNeighbors, config, mouse, Vector);
                            // Must be Vector or falsy; non-Vector returns are tolerated as no-op
                            if (res && !(res instanceof Vector)) ok = false;
                        } catch (e) {
                            ok = false;
                        }
                        if (!ok) throw new Error('Rule dry-run failed');

                        // Adopt the new function, wrapped with runtime safety
                        fn.updateBoid = (boid, gameState, neighbors) => {
                            try {
                                const out = dynamicFunc(boid, gameState, neighbors, config, mouse, Vector);
                                return out instanceof Vector ? out : new Vector();
                            } catch (e) {
                                const now = performance.now();
                                if (!fn._lastRuntimeErrorTs || (now - fn._lastRuntimeErrorTs) > 1000) {
                                    console.error(`Runtime error in rule '${fn.name}':`, e);
                                    fn._lastRuntimeErrorTs = now;
                                }
                                // Mark fallback active for a short window and update UI (throttled)
                                fn._fallbackUntil = now + 2000;
                                updateRuleStatusUI();
                                return new Vector();
                            }
                        };

                        console.log(`Rule '${fn.name}' reloaded successfully.`);
                        logConfig(`Rule '${fn.name}' reloaded successfully.`);
                        if (tabButton) {
                           tabButton.classList.add('reloaded-success');
                           setTimeout(() => tabButton.classList.remove('reloaded-success'), 600);
                        }
                    } catch (e) {
                        console.error(`Error reloading rule '${fn.name}':`, e);
                        // Keep previous good function if any; else use no-op
                        fn.updateBoid = typeof fn.updateBoid === 'function' ? fn.updateBoid : () => new Vector();
                        // Also mark fallback indicator briefly to signal error state
                        fn._fallbackUntil = performance.now() + 2000;
                        updateRuleStatusUI();
                        if (tabButton) {
                           tabButton.classList.add('reloaded-error');
                           setTimeout(() => tabButton.classList.remove('reloaded-error'), 600);
                        }
                    }
                }, 500);
                editors[fn.name].on('change', updateFunction);
                // Show autocomplete as you type for convenience
                editors[fn.name].on('inputRead', (cm, change) => {
                    if (!change.text) return;
                    const ch = change.text.join('');
                    if (/^[\w\.$]$/.test(ch)) {
                        cm.showHint({ hint: ruleHint, completeSingle: false });
                    }
                });
                updateFunction(editors[fn.name]); // Initial compilation
            }

            // Split view setup
            const leftSel = document.getElementById('split-left');
            const rightSel = document.getElementById('split-right');
            const slots = {
                left: document.querySelector('.split-pane[data-slot="left"]'),
                right: document.querySelector('.split-pane[data-slot="right"]'),
            };
            const mounted = {}; // rule -> slot name

            function populateSelects() {
                [leftSel, rightSel].forEach(sel => { sel.innerHTML = ''; });
                userFunctions.forEach(fn => {
                    const optL = document.createElement('option'); optL.value = fn.name; optL.textContent = fn.name;
                    const optR = document.createElement('option'); optR.value = fn.name; optR.textContent = fn.name;
                    leftSel.appendChild(optL); rightSel.appendChild(optR);
                });
            }
            function updateSelectStates() {
                // Ensure distinct selections
                if (leftSel.value === rightSel.value) {
                    const other = userFunctions.find(u => u.name !== leftSel.value);
                    if (other) rightSel.value = other.name;
                }
                // Disable chosen rule in the opposite select
                Array.from(leftSel.options).forEach(o => { o.disabled = (o.value === rightSel.value); });
                Array.from(rightSel.options).forEach(o => { o.disabled = (o.value === leftSel.value); });
            }
            function unmountRule(rule) {
                if (!mounted[rule]) return;
                const slotName = mounted[rule];
                const wrapper = editors[rule] && editors[rule].getWrapperElement();
                if (wrapper && originalParents[rule]) {
                    originalParents[rule].appendChild(wrapper);
                    editors[rule].refresh();
                }
                delete mounted[rule];
            }
            function mountRule(rule, slotName) {
                if (!rule || !slots[slotName]) return;
                // If this rule is mounted elsewhere, unmount first
                unmountRule(rule);
                const wrapper = editors[rule] && editors[rule].getWrapperElement();
                if (wrapper) {
                    slots[slotName].appendChild(wrapper);
                    mounted[rule] = slotName;
                    editors[rule].refresh();
                }
            }
            function updateSplitMounts() {
                // Ensure rules are distinct
                updateSelectStates();
                const L = leftSel.value;
                const R = rightSel.value;
                // Unmount any rule not chosen
                Object.keys(mounted).forEach(rule => {
                    if (rule !== L && rule !== R) unmountRule(rule);
                });
                // If a chosen rule is mounted in the wrong place, move it
                if (mounted[L] !== 'left') mountRule(L, 'left');
                if (mounted[R] !== 'right') mountRule(R, 'right');
            }
            function showSplitUI(show) {
                const sc = document.getElementById('split-controls');
                const sv = document.getElementById('split-view');
                if (sc) sc.style.display = 'none'; // managed in tabs row now
                if (sv) sv.style.display = show ? 'flex' : 'none';
            }
            // Expose hooks for dock mode changes
            setupCodePane._split = {
                populateSelects, updateSplitMounts, showSplitUI,
                get leftSel() { return leftSel; },
                get rightSel() { return rightSel; },
                unmountAll: () => { Object.keys(mounted).forEach(unmountRule); }
            };
            populateSelects();
            leftSel.value = config.splitLeftRule || 'cohesion';
            rightSel.value = (config.splitRightRule && config.splitRightRule !== leftSel.value)
                ? config.splitRightRule : (userFunctions.find(u => u.name !== leftSel.value) || userFunctions[0]).name;
            updateSelectStates();
            leftSel.addEventListener('change', () => {
                config.splitLeftRule = leftSel.value;
                if (!config.debug) updateURL('splitLeftRule', config.splitLeftRule);
                updateSplitMounts();
            });
            rightSel.addEventListener('change', () => {
                config.splitRightRule = rightSel.value;
                if (!config.debug) updateURL('splitRightRule', config.splitRightRule);
                updateSplitMounts();
            });
            // Reflect initial split toggle state when first applied to maximized
            updateSplitModeUI();

            // Rule actions
            document.getElementById('rule-new-btn').addEventListener('click', () => {
                const name = prompt('New rule name (letters, numbers, _-):', 'custom');
                if (!name) return;
                addRule(name);
            });
            document.getElementById('rule-rename-btn').addEventListener('click', () => {
                const current = getCurrentRuleTarget();
                if (!current) return;
                const newName = prompt(`Rename rule '${current}' to:`, current);
                if (!newName || newName === current) return;
                renameRule(current, newName);
            });
            document.getElementById('rule-delete-btn').addEventListener('click', () => {
                const target = getCurrentRuleTarget();
                if (!target) return;
                if (userFunctions.length <= 1) { alert('At least one rule is required.'); return; }
                if (!confirm(`Delete rule '${target}'? This cannot be undone.`)) return;
                deleteRule(target);
            });
        }

        function sanitizeRuleName(name) {
            let s = String(name).trim();
            s = s.replace(/\s+/g, '-').replace(/[^A-Za-z0-9_-]/g, '').toLowerCase();
            if (!s) s = 'rule';
            let base = s, i = 2;
            while (userFunctions.find(u => u.name === s)) { s = base + '-' + i++; }
            return s;
        }

        function defaultRuleTemplate(name) {
            return `/**\n * ${name}: custom rule template\n * @param {Boid} boid\n * @param {GameState} gameState\n * @param {Boid[]} neighbors\n * @param {Config} config\n * @param {Mouse} mouse\n * @param {typeof Vector} Vector\n * @returns {Vector}\n */\nconst steering = new Vector(0, 0);\n// Example: mild drift toward mouse when down\nif (mouse.down) {\n  const desired = Vector.sub(new Vector(mouse.pos.x, mouse.pos.y), boid.pos).normalize().mult(boid.maxSpeed * 0.2);\n  return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.2);\n}\nreturn steering;`;
        }

        function addRule(nameRaw) {
            const name = sanitizeRuleName(nameRaw);
            if (userFunctions.find(u => u.name === name)) { alert('Rule already exists.'); return; }
            // Create tab and content
            const tabsBar = document.querySelector('.code-tabs');
            const tabBtn = document.createElement('button');
            tabBtn.className = 'tab-button'; tabBtn.dataset.tab = name; tabBtn.textContent = name.charAt(0).toUpperCase() + name.slice(1);
            tabsBar.insertBefore(tabBtn, tabsBar.querySelector('.dock-controls'));
            const content = document.createElement('div'); content.id = name; content.className = 'tab-content';
            const ta = document.createElement('textarea'); content.appendChild(ta);
            document.getElementById('code-pane').appendChild(content);
            // Editor
            const ed = CodeMirror.fromTextArea(ta, { mode:'javascript', theme:'dracula', lineNumbers:true, lint:true, gutters:["CodeMirror-lint-markers"], extraKeys:{'Ctrl-Space':'autocomplete'}, hintOptions:{hint: editor => ruleHint(editor), completeSingle:false} });
            editors[name] = ed;
            // Compile function
            const fnObj = { name, weight: 1.0, updateBoid: null };
            userFunctions.push(fnObj);
            // Hook tab behavior
            tabBtn.addEventListener('click', () => {
                document.querySelectorAll('.tab-button').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                tabBtn.classList.add('active'); content.classList.add('active'); ed.refresh();
            });
            // Set default code and compile
            ed.setValue(defaultRuleTemplate(name));
            const updateFunction = debounce((editor) => {
                const tabButton = tabBtn;
                try {
                    const code = editor.getValue();
                    const params = ['boid','gameState','neighbors','config','mouse','Vector'];
                    const dynamicFunc = new Function(...params, code);
                    // dry-run
                    const mockBoid = new Boid(0,0); const mockState = { boids:[mockBoid], quadtree:null, width:10, height:10 };
                    let ok = true; try { const res = dynamicFunc(mockBoid, mockState, [], config, mouse, Vector); if (res && !(res instanceof Vector)) ok = false; } catch(e){ ok=false; }
                    if (!ok) throw new Error('Rule dry-run failed');
                    fnObj.updateBoid = (boid, gameState, neighbors) => { try { const out = dynamicFunc(boid, gameState, neighbors, config, mouse, Vector); return out instanceof Vector ? out : new Vector(); } catch (e) { fnObj._fallbackUntil = performance.now()+2000; updateRuleStatusUI(); return new Vector(); } };
                    tabButton.classList.add('reloaded-success'); setTimeout(()=>tabButton.classList.remove('reloaded-success'),600);
                } catch (e) {
                    console.error(`Error reloading rule '${name}':`, e);
                    fnObj.updateBoid = () => new Vector();
                    tabButton.classList.add('reloaded-error'); setTimeout(()=>tabButton.classList.remove('reloaded-error'),600);
                    fnObj._fallbackUntil = performance.now()+2000; updateRuleStatusUI();
                }
            }, 500);
            ed.on('change', updateFunction);
            ed.on('inputRead', (cm, change) => { if (!change.text) return; const ch = change.text.join(''); if (/^[\w\.$]$/.test(ch)) cm.showHint({ hint: ruleHint, completeSingle:false });});
            updateFunction(ed);
            // Rebuild config UI and split pickers
            config[`${name}Weight`] = 1.0;
            setupConfigUI();
            if (setupCodePane._split) { setupCodePane._split.populateSelects(); setupCodePane._split.updateSplitMounts(); }
        }

        function getCurrentRuleTarget() {
            const pane = document.getElementById('code-pane');
            const maximized = pane.classList.contains('maximized');
            if (maximized && config.splitEnabled) {
                // Default to left selection
                const leftSel = document.getElementById('split-left');
                return leftSel && leftSel.value || null;
            }
            const active = document.querySelector('.tab-button.active');
            return active ? active.dataset.tab : null;
        }

        function renameRule(oldNameRaw, newNameRaw) {
            const oldName = oldNameRaw; const newName = sanitizeRuleName(newNameRaw);
            if (!editors[oldName]) { alert('Rule not found.'); return; }
            if (editors[newName]) { alert('A rule with that name already exists.'); return; }
            // Update userFunctions entry
            const fnObj = userFunctions.find(u => u.name === oldName);
            if (!fnObj) return;
            fnObj.name = newName;
            // Move editor mapping
            editors[newName] = editors[oldName]; delete editors[oldName];
            // Update tab button and content IDs
            const tabBtn = document.querySelector(`.tab-button[data-tab="${oldName}"]`);
            const content = document.getElementById(oldName);
            if (tabBtn) { tabBtn.dataset.tab = newName; tabBtn.textContent = newName.charAt(0).toUpperCase()+newName.slice(1); }
            if (content) { content.id = newName; }
            // Update config weight key
            const oldKey = `${oldName}Weight`; const newKey = `${newName}Weight`;
            config[newKey] = (oldKey in config) ? config[oldKey] : 1.0; delete config[oldKey];
            setupConfigUI();
            // Update split selections
            const leftSel = document.getElementById('split-left');
            const rightSel = document.getElementById('split-right');
            if (leftSel && leftSel.value === oldName) leftSel.value = newName;
            if (rightSel && rightSel.value === oldName) rightSel.value = newName;
            if (setupCodePane._split) { setupCodePane._split.populateSelects(); setupCodePane._split.updateSplitMounts(); }
        }

        function deleteRule(name) {
            if (!editors[name]) return;
            // Remove from userFunctions
            const idx = userFunctions.findIndex(u => u.name === name);
            if (idx >= 0) userFunctions.splice(idx,1);
            // Remove editor DOM
            const wrapper = editors[name].getWrapperElement();
            if (wrapper && wrapper.parentNode) wrapper.parentNode.removeChild(wrapper);
            delete editors[name];
            // Remove tab and content
            const tabBtn = document.querySelector(`.tab-button[data-tab="${name}"]`);
            const content = document.getElementById(name);
            if (tabBtn && tabBtn.parentNode) tabBtn.parentNode.removeChild(tabBtn);
            if (content && content.parentNode) content.parentNode.removeChild(content);
            // Update active tab
            const firstTab = document.querySelector('.tab-button');
            const firstContentId = firstTab ? firstTab.dataset.tab : null;
            if (firstTab) firstTab.classList.add('active');
            if (firstContentId) {
                const firstContent = document.getElementById(firstContentId);
                if (firstContent) firstContent.classList.add('active');
            }
            // Remove weight config and rebuild UI
            delete config[`${name}Weight`];
            setupConfigUI();
            // Update split
            const leftSel = document.getElementById('split-left');
            const rightSel = document.getElementById('split-right');
            if (leftSel && leftSel.value === name) {
                const other = userFunctions[0] && userFunctions[0].name; if (other) leftSel.value = other;
            }
            if (rightSel && rightSel.value === name) {
                const other = userFunctions.find(u => u.name !== (leftSel && leftSel.value)) || userFunctions[0];
                if (other) rightSel.value = other.name;
            }
            if (setupCodePane._split) { setupCodePane._split.populateSelects(); setupCodePane._split.updateSplitMounts(); }
        }
        
        // --- SIMULATION LOGIC ---

        function createBoids() {
            gameState.boids = [];
            for (let i = 0; i < config.boidCount; i++) {
                gameState.boids.push(new Boid(Math.random() * gameState.width, Math.random() * gameState.height));
            }
            logConfig(`Created ${config.boidCount} boids.`);
        }

        function hardReset() {
            // Reset boids and stats without changing code or config
            createBoids();
            fpsHistory.length = 0;
            updateTimeHistory.length = 0;
            angleHistory.length = 0;
            lastTime = performance.now();
            // Clear charts if present
            if (charts.fpsChart) { charts.fpsChart.data.datasets[0].data = []; charts.fpsChart.update('none'); }
            if (charts.updateTimeChart) { charts.updateTimeChart.data.datasets[0].data = []; charts.updateTimeChart.update('none'); }
            if (charts.polarCtx) {
                const c = charts.polarCtx.canvas; charts.polarCtx.clearRect(0,0,c.width,c.height);
            }
            if (charts.meanPolarCtx) {
                const c = charts.meanPolarCtx.canvas; charts.meanPolarCtx.clearRect(0,0,c.width,c.height);
            }
            logConfig('Simulation hard reset.');
        }

        // --- MAIN LOOP ---

        function animate(timestamp) {
            const deltaTime = (timestamp - lastTime) || 0;
            lastTime = timestamp;
            fps = 1000 / deltaTime;
            const t0 = performance.now();
            update();
            const updateTime = performance.now() - t0;
            draw();
            updateStats(updateTime);
            requestAnimationFrame(animate);
        }

        function update() {
            const boundary = new Rectangle(gameState.width / 2, gameState.height / 2, gameState.width / 2, gameState.height / 2);
            gameState.quadtree = new QuadTree(boundary, 4);
            for (let boid of gameState.boids) gameState.quadtree.insert(boid);
            // Protect simulation step from rule runtime errors
            for (let boid of gameState.boids) {
                try {
                    boid.update(gameState);
                } catch (e) {
                    if (!update._lastErrorTs || (performance.now() - update._lastErrorTs) > 1000) {
                        console.error('Update step error (continuing):', e);
                        update._lastErrorTs = performance.now();
                    }
                }
            }
        }

        function draw() {
            ctx.fillStyle = 'rgba(26, 26, 26, 0.25)';
            ctx.fillRect(0, 0, gameState.width, gameState.height);
            if (config.visualizeQuadtree) gameState.quadtree.draw(ctx);
            for (let boid of gameState.boids) boid.draw(ctx);
            if (mouse.down) {
                 ctx.beginPath();
                 ctx.arc(mouse.pos.x, mouse.pos.y, 150, 0, Math.PI * 2);
                 const gradient = ctx.createRadialGradient(mouse.pos.x, mouse.pos.y, 10, mouse.pos.x, mouse.pos.y, 150);
                 gradient.addColorStop(0, `hsla(${config.hue}, 100%, 50%, 0.3)`);
                 gradient.addColorStop(1, `hsla(${config.hue}, 100%, 50%, 0)`);
                 ctx.fillStyle = gradient;
                 ctx.fill();
            }
            ctx.fillStyle = `hsl(${config.hue}, 100%, 50%)`;
            ctx.beginPath();
            ctx.arc(mouse.pos.x, mouse.pos.y, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = `hsla(${config.hue}, 100%, 80%, 0.8)`;
            ctx.font = 'bold 36px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(config.header, gameState.width / 2, 50);
            ctx.font = '24px sans-serif';
            ctx.fillText(config.subheader, gameState.width / 2, 90);
        }

        function updateStats(updateTime) {
            if (isFinite(fps)) {
                document.getElementById('fps-counter').textContent = Math.round(fps);
                fpsHistory.push(fps);
                if (fpsHistory.length > 50) fpsHistory.shift();
                charts.fpsChart.data.datasets[0].data = fpsHistory;
                charts.fpsChart.update('none');
            }
            // Update rule fallback indicators (throttled)
            updateRuleStatusUI();
            document.getElementById('particle-count').textContent = Math.round(config.boidCount);
            if (isFinite(updateTime)) {
                document.getElementById('update-time').textContent = updateTime.toFixed(2);
                updateTimeHistory.push(updateTime);
                if (updateTimeHistory.length > 50) updateTimeHistory.shift();
                const mean = updateTimeHistory.reduce((a, b) => a + b, 0) / updateTimeHistory.length;
                const stdDev = Math.sqrt(updateTimeHistory.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b, 0) / updateTimeHistory.length);
                document.getElementById('update-time-mean').textContent = mean.toFixed(2);
                document.getElementById('update-time-stddev').textContent = stdDev.toFixed(2);
                charts.updateTimeChart.data.datasets[0].data = updateTimeHistory;
                charts.updateTimeChart.update('none');
            }
            if (gameState.boids.length > 0) {
                const sumVec = new Vector(0, 0);
                for (const boid of gameState.boids) sumVec.add(boid.vel.clone().normalize());
                const meanAngle = sumVec.heading();
                const R = sumVec.mag() / gameState.boids.length;
                const stdDev = R < 1 ? Math.sqrt(-2 * Math.log(R)) : 0;
                angleHistory.push({ meanAngle, stdDev });
                if (angleHistory.length > MAX_ANGLE_HISTORY) angleHistory.shift();
            }
            drawPolarSpiralChart();
            drawMeanPolarChart();
        }

        function drawPolarSpiralChart() {
            if (!charts.polarCtx || angleHistory.length < 2) return;
            const ctx = charts.polarCtx;
            const canvas = ctx.canvas;
            const { width, height } = canvas;
            const centerX = width / 2;
            const centerY = height / 2;
            const maxRadius = Math.min(centerX, centerY) * 0.9;
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 1; i <= 4; i++) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, (maxRadius / 4) * i, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.beginPath();
            for (let i = 0; i < angleHistory.length; i++) {
                const record = angleHistory[i];
                const radius = Math.min(record.stdDev / Math.sqrt(2), 1.0) * maxRadius;
                const x = centerX + radius * Math.cos(record.meanAngle);
                const y = centerY + radius * Math.sin(record.meanAngle);
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.strokeStyle = `hsl(${config.hue}, 100%, 50%)`;
            ctx.lineWidth = 2;
            ctx.stroke();
            const lastRecord = angleHistory[angleHistory.length - 1];
            const lastRadius = Math.min(lastRecord.stdDev / Math.sqrt(2), 1.0) * maxRadius;
            const lastX = centerX + lastRadius * Math.cos(lastRecord.meanAngle);
            const lastY = centerY + lastRadius * Math.sin(lastRecord.meanAngle);
            ctx.beginPath();
            ctx.arc(lastX, lastY, 4, 0, Math.PI * 2);
            ctx.fillStyle = 'white';
            ctx.fill();
        }

        function drawMeanPolarChart() {
            if (!charts.meanPolarCtx || angleHistory.length < 2) return;
            const ctx = charts.meanPolarCtx;
            const canvas = ctx.canvas;
            const { width, height } = canvas;
            const centerX = width / 2;
            const centerY = height / 2;
            const maxRadius = Math.min(centerX, centerY) * 0.9;

            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, width, height);
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 5, centerX, centerY, maxRadius);
            bgGradient.addColorStop(0, '#222');
            bgGradient.addColorStop(1, '#111');
            ctx.beginPath();
            ctx.arc(centerX, centerY, maxRadius, 0, Math.PI * 2);
            ctx.fillStyle = bgGradient;
            ctx.fill();

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 1; i <= 4; i++) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, (maxRadius / 4) * i, 0, Math.PI * 2);
                ctx.stroke();
            }
            for (let i = 0; i < 8; i++) {
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + maxRadius * Math.cos(i * Math.PI / 4), centerY + maxRadius * Math.sin(i * Math.PI / 4));
                ctx.stroke();
            }

            if (charts.showStdDevBands.checked) {
                ctx.beginPath();
                for (let i = 0; i < angleHistory.length; i++) {
                    const radius = (i / MAX_ANGLE_HISTORY) * maxRadius;
                    const x = centerX + radius * Math.cos(angleHistory[i].meanAngle + angleHistory[i].stdDev);
                    const y = centerY + radius * Math.sin(angleHistory[i].meanAngle + angleHistory[i].stdDev);
                    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                }
                for (let i = angleHistory.length - 1; i >= 0; i--) {
                    const radius = (i / MAX_ANGLE_HISTORY) * maxRadius;
                    const x = centerX + radius * Math.cos(angleHistory[i].meanAngle - angleHistory[i].stdDev);
                    const y = centerY + radius * Math.sin(angleHistory[i].meanAngle - angleHistory[i].stdDev);
                    ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fillStyle = `hsla(${config.hue}, 100%, 50%, 0.15)`;
                ctx.fill();
            }
            
            ctx.beginPath();
            for (let i = 0; i < angleHistory.length; i++) {
                const radius = (i / MAX_ANGLE_HISTORY) * maxRadius;
                const x = centerX + radius * Math.cos(angleHistory[i].meanAngle);
                const y = centerY + radius * Math.sin(angleHistory[i].meanAngle);
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            const lineGradient = ctx.createLinearGradient(centerX - maxRadius, centerY, centerX + maxRadius, centerY);
            lineGradient.addColorStop(0, `hsl(${config.hue}, 100%, 30%)`);
            lineGradient.addColorStop(0.5, `hsl(${config.hue}, 100%, 50%)`);
            lineGradient.addColorStop(1, `hsl(${config.hue}, 100%, 70%)`);
            ctx.strokeStyle = lineGradient;
            ctx.lineWidth = 2;
            ctx.stroke();

            const lastRecord = angleHistory[angleHistory.length - 1];
            const lastRadius = ((angleHistory.length - 1) / MAX_ANGLE_HISTORY) * maxRadius;
            const lastX = centerX + lastRadius * Math.cos(lastRecord.meanAngle);
            const lastY = centerY + lastRadius * Math.sin(lastRecord.meanAngle);
            ctx.beginPath();
            ctx.arc(lastX, lastY, 4, 0, Math.PI * 2);
            ctx.fillStyle = 'white';
            ctx.fill();

            const meanDeg = (lastRecord.meanAngle * 180 / Math.PI + 360) % 360;
            const stdDevDeg = lastRecord.stdDev * 180 / Math.PI;
            ctx.font = `12px ${getComputedStyle(document.documentElement).getPropertyValue('--font-mono')}`;
            ctx.fillStyle = '#ccc';
            ctx.textAlign = 'left';
            ctx.fillText(`Mean: ${meanDeg.toFixed(1)}°`, 10, 20);
            ctx.fillText(`StdDev: ${stdDevDeg.toFixed(1)}°`, 10, 35);
        }

        // --- COLOR HELPERS ---
        function hslToHex(h, s, l) {
            l /= 100; const a = s * Math.min(l, 1 - l) / 100;
            const f = n => { const k = (n + h / 30) % 12; const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1); return Math.round(255 * color).toString(16).padStart(2, '0'); };
            return `#${f(0)}${f(8)}${f(4)}`;
        }
        function hexToHsl(hex) {
            let r=0,g=0,b=0; if(hex.length==4){r=parseInt(hex[1]+hex[1],16);g=parseInt(hex[2]+hex[2],16);b=parseInt(hex[3]+hex[3],16);}else if(hex.length==7){r=parseInt(hex[1]+hex[2],16);g=parseInt(hex[3]+hex[4],16);b=parseInt(hex[5]+hex[6],16);}
            r/=255;g/=255;b/=255; let cmin=Math.min(r,g,b),cmax=Math.max(r,g,b),delta=cmax-cmin,h=0,s=0,l=0;
            if(delta==0)h=0;else if(cmax==r)h=((g-b)/delta)%6;else if(cmax==g)h=(b-r)/delta+2;else h=(r-g)/delta+4;
            h=Math.round(h*60); if(h<0)h+=360; l=(cmax+cmin)/2; s=delta==0?0:delta/(1-Math.abs(2*l-1)); s=+(s*100).toFixed(1);l=+(l*100).toFixed(1); return[h,s,l];
        }

        // --- START ---
        init();
    })();
    </script>
</body>
</html>
