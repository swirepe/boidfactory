<!DOCTYPE html>
<!--
  Boids Simulation – Single-file Lab (v1.2)
  
  Goals
  - Clean, readable structure with sectioned comments
  - Smartly documented example rules (cohesion/separation/alignment/novel)
  - Minimal external dependencies (CDN for editors/charts only)

  Structure
  - CSS: variables, layout, overlays, code pane, charts
  - HTML: full-screen canvas, overlays (config/stats/help), code pane tabs
  - JS: utilities → simulation core → UI → main loop → charts → helpers

  Notes
  - Example rule code is editable live; each rule must return a Vector.
  - The dynamic function scope provides: boid, gameState, neighbors, config, mouse, Vector.
  - Keep rule code side-effect free (only return a force vector) for clarity.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Boids Simulation</title>
    <style>
        :root {
            --hue: 200;
            --font-mono: 'SF Mono', 'Consolas', 'Courier New', monospace;
            --primary-color: hsl(var(--hue), 100%, 50%);
            --secondary-color: hsl(var(--hue), 50%, 70%);
            --background-color: #1a1a1a;
            --text-color: #f0f0f0;
            --overlay-bg-color: rgba(20, 20, 20, 0.9);
            --border-color: var(--primary-color);
        }
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--background-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas {
            display: block;
            cursor: none;
        }
        .overlay {
            position: fixed;
            top: 10px;
            background-color: var(--overlay-bg-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            max-height: calc(100vh - 80px);
            overflow-y: auto;
            transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.4s;
            transform: translateX(120%);
            opacity: 0;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
            z-index: 1002;
            font-family: var(--font-mono);
        }
        .overlay.visible {
            transform: translateX(0);
            opacity: 1;
        }
        .close-button {
            position: absolute;
            top: 5px;
            right: 10px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            padding: 5px;
            line-height: 1;
        }
        .close-button:hover {
            color: var(--primary-color);
        }
        .overlay-toggle-container {
            position: fixed;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1001;
        }
        /* Hide overlay buttons when code pane is maximized */
        body.code-pane-maximized .overlay-toggle-container { display: none; }
        /* Subtle enter/leave transitions for temporary Code overlay button */
        #overlay-code-button {
            opacity: 1;
            transform: translateY(0);
            transition: opacity 0.22s ease, transform 0.22s ease;
        }
        #overlay-code-button.entering,
        #overlay-code-button.leaving {
            opacity: 0;
            transform: translateY(-6px);
        }
        .overlay-toggle {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.2s, transform 0.2s;
            font-weight: bold;
            font-family: var(--font-mono);
        }
        .overlay-toggle:hover {
            background-color: hsl(var(--hue), 100%, 60%);
            transform: scale(1.05);
        }
        #config-overlay { right: 10px; width: 320px; }
        #stats-overlay { right: 10px; width: 320px; text-align: left; }
        #help-overlay { right: 10px; width: 450px; }

        /* Code Pane: supports docking to bottom, left, or maximized */
        #code-pane {
            position: fixed;
            background-color: var(--overlay-bg-color);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            transition: transform 0.4s cubic-bezier(0.25, 1, 0.5, 1), width 0.2s, height 0.2s;
        }
        /* Bottom dock (default) */
        #code-pane.dock-bottom { left: 0; bottom: 0; width: 100%; border-top: 2px solid var(--border-color); }
        #code-pane.dock-bottom:not(.visible) { transform: translateY(calc(100% - 40px)); }
        #code-pane.dock-bottom.visible { transform: translateY(0); height: 40vh; }
        /* Left dock */
        #code-pane.dock-left { top: 0; left: 0; height: 100vh; width: 40vw; min-width: 320px; border-right: 2px solid var(--border-color); }
        #code-pane.dock-left:not(.visible) { transform: translateX(-100%); }
        #code-pane.dock-left.visible { transform: translateX(0); }
        /* Maximized */
        #code-pane.maximized { top: 0; left: 0; width: 100vw; height: 100vh; border-top: 2px solid var(--border-color); transform: none !important; }
        #code-pane.maximized .code-pane-toggle { background-color: var(--primary-color); }
        .code-pane-toggle {
            background-color: var(--primary-color);
            color: white;
            border: none;
            width: 100%;
            padding: 10px;
            cursor: pointer;
            font-size: 16px;
            font-family: var(--font-mono);
            display: flex;
            align-items: center;
            gap: 8px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.12);
            box-shadow: 0 1px 0 rgba(0,0,0,0.35);
        }
        .code-icon { width: 18px; height: 18px; opacity: 0.9; }
        .code-label { flex: 1; }
        /* Dock controls */
        .dock-controls { display: flex; gap: 6px; }
        .dock-btn {
            background: transparent;
            border: none;
            color: rgba(255,255,255,0.8);
            width: 32px;
            height: 32px;
            padding: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.15s ease, color 0.15s ease;
        }
        .dock-btn:hover { opacity: 1; }
        .dock-btn svg { width: 20px; height: 20px; display: block; }
        .dock-btn.active { color: var(--primary-color); opacity: 1; }
        .code-tabs { display: flex; align-items: center; gap: 6px; padding: 2px 6px; flex-shrink: 0; flex-wrap: wrap; row-gap: 4px; }
        .code-tabs .dock-controls { margin-left: auto; }
        .tab-button {
            flex-grow: 1;
            padding: 6px 8px;
            cursor: pointer;
            background-color: #333;
            border: none;
            color: white;
            border-bottom: 3px solid transparent;
            transition: background-color 0.2s;
            font-family: var(--font-mono);
        }
        .tab-button.active {
            background-color: var(--background-color);
            border-bottom-color: var(--primary-color);
        }
        /* Indicator when a rule is using fallback due to recent runtime errors */
        .tab-button.fallback-active { position: relative; }
        .tab-button.fallback-active::after {
            content: '';
            position: absolute;
            top: 6px;
            right: 8px;
            width: 8px;
            height: 8px;
            background: #ff4d4f; /* subtle red dot */
            border-radius: 50%;
            box-shadow: 0 0 0 2px rgba(0,0,0,0.3);
        }
        @keyframes flash-success {
            50% { background-color: hsl(var(--hue), 100%, 30%); }
        }
        @keyframes flash-error {
            50% { background-color: #801c1c; }
        }
        .tab-button.reloaded-success {
            animation: flash-success 0.6s ease-in-out;
        }
        .tab-button.reloaded-error {
            animation: flash-error 0.6s ease-in-out;
        }
        .tab-content {
            display: none;
            flex-grow: 1;
        }
        .tab-content.active {
            display: block;
        }
        /* Maximized split controls and panes */
        .split-controls { display: none !important; }
        .split-controls label { font-family: var(--font-mono); font-size: 12px; color: #ddd; }
        .split-controls select { background: #333; color: #fff; border: 1px solid #555; padding: 4px 6px; border-radius: 4px; }
        .split-view { display: none; }
        #code-pane.maximized.split-on .split-view { display: flex; gap: 0; align-items: stretch; }
        .split-pane { flex: 1 1 50%; min-width: 0; padding: 6px; box-sizing: border-box; }
        /* Ensure tab contents are visible inside split panes even without 'active' */
        #code-pane.maximized.split-on .split-view .tab-content { display: block; width: 100%; }
        .split-sash { width: 8px; cursor: col-resize; background: transparent; position: relative; z-index: 1; }
        .split-sash::before { content: ''; position: absolute; top: 0; bottom: 0; left: 3px; width: 2px; background: rgba(255,255,255,0.08); }
        .split-sash:hover::before { background: rgba(255,255,255,0.18); }
        /* Hide tabs when in split mode, but keep row for dock icons */
        #code-pane.maximized.split-on .tab-button { display: none; }
        /* Show split toggle icon only in maximized mode */
        .dock-btn[data-action="toggle-split"] { display: none; }
        #code-pane.maximized .dock-btn[data-action="toggle-split"] { display: inline-flex; }
        /* Split pickers inside the tabs row */
        .split-picker { display: none; }
        #code-pane.maximized.split-on .code-tabs { display: flex; align-items: center; gap: 8px; padding: 0 6px; }
        #code-pane.maximized.split-on .split-picker { display: block; }
        #code-pane.maximized.split-on .dock-controls { margin-left: auto; }
        .rule-actions { display: inline-flex; gap: 6px; }
        .rule-btn { background: transparent; border: none; color: rgba(255,255,255,0.8); width: 28px; height: 28px; display: inline-flex; align-items: center; justify-content: center; cursor: pointer; opacity: 0.8; }
        .rule-btn:hover { opacity: 1; color: var(--primary-color); }
        .preset-controls { display: inline-flex; gap: 6px; align-items: center; }
        .preset-controls select { background: #333; color: #fff; border: 1px solid #555; padding: 4px 6px; border-radius: 4px; font-family: var(--font-mono); font-size: 12px; }
        /* Per-editor mini task bar */
        .editor-bar { display: flex; align-items: center; gap: 8px; padding: 6px; background: rgba(0,0,0,0.15); border: 1px solid rgba(255,255,255,0.08); border-radius: 6px; margin-bottom: 6px; }
        .editor-bar select { background: #333; color: #fff; border: 1px solid #555; padding: 4px 6px; border-radius: 4px; font-family: var(--font-mono); font-size: 12px; }
        .editor-bar .bar-btn { background: transparent; border: 1px solid rgba(255,255,255,0.15); color: #ddd; padding: 2px 8px; border-radius: 4px; cursor: pointer; font-family: var(--font-mono); font-size: 12px; opacity: 0.85; }
        .editor-bar .bar-btn:hover { opacity: 1; color: var(--primary-color); border-color: var(--primary-color); }
        .split-picker select { background: #333; color: #fff; border: 1px solid #555; padding: 4px 6px; border-radius: 4px; font-family: var(--font-mono); font-size: 12px; }
        .split-picker.split-left { justify-self: start; }
        .split-picker.split-right { justify-self: end; }
        /* Editor sizing by dock mode */
        .CodeMirror { border: none; }
        #code-pane.dock-bottom.visible .CodeMirror { height: calc(40vh - 92px) !important; }
        #code-pane.dock-left .CodeMirror { height: calc(100vh - 92px) !important; }
        #code-pane.maximized .CodeMirror { height: calc(100vh - 92px) !important; }
        /* Editor gutter tweaks */
        .CodeMirror-gutters { background: #2a2a2a !important; border-right: 1px solid #444 !important; }
        .CodeMirror-linenumbers { min-width: 2.5ch !important; }
        .CodeMirror-linenumber { padding: 0 6px 0 4px !important; color: #aaa !important; }
        /* Minimized left dock: show only icon in header */
        #code-pane.dock-left:not(.visible) .code-label { display: none; }
        #code-pane.dock-left:not(.visible) .code-tabs { display: none; }
        #code-pane.dock-left:not(.visible) .code-pane-toggle { width: 48px; justify-content: center; }
        .config-item {
            margin-bottom: 12px;
        }
        .config-item label {
            display: block;
            margin-bottom: 5px;
        }
        .config-item input[type="range"], .config-item select {
            width: 100%;
        }
        .config-item select {
             background-color: #333;
             color: white;
             border: 1px solid #555;
             padding: 5px;
             border-radius: 3px;
        }
        .config-item input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            padding: 0;
        }
        h2, h3 {
            color: var(--primary-color);
            margin-top: 0;
            font-family: var(--font-mono);
            font-weight: 500;
        }
        #stats-overlay h3 { color: var(--secondary-color); }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 300px;
            margin: 0 auto;
        }
        .chart-toggle {
            position: absolute;
            bottom: 5px;
            left: 5px;
            background-color: rgba(0,0,0,0.5);
            padding: 5px 8px;
            border-radius: 5px;
            font-size: 12px;
        }
        .chart-toggle label {
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .chart-container canvas {
            background-color: #111;
            border-radius: 5px;
            width: 100%;
            /* aspect-ratio: 1 / 1; */
            display: block;
        }
        #help-overlay code { background-color: #333; padding: 2px 5px; border-radius: 3px; }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/dracula.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/lint/lint.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/show-hint.min.css">
</head>
<body>
    <canvas id="boids-canvas"></canvas>
    
    <div class="overlay-toggle-container">
        <button class="overlay-toggle" data-overlay="config-overlay">Config</button>
        <button class="overlay-toggle" data-overlay="stats-overlay">Stats</button>
        <button class="overlay-toggle" data-overlay="help-overlay">Help</button>
        <button class="overlay-toggle" data-overlay="info-overlay">Info</button>
        <button class="overlay-toggle" id="reset-button" title="Reset simulation (boids + stats)">Reset</button>
    </div>

    <div class="overlay" id="config-overlay"></div>
    <div class="overlay" id="stats-overlay"></div>
    <div class="overlay" id="help-overlay"></div>
    <div class="overlay" id="info-overlay"></div>

    <div id="code-pane" class="dock-bottom">
        <button class="code-pane-toggle">
            <!-- Minimalist editor icon (window with lines) -->
            <svg class="code-icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                <rect x="3" y="5" width="18" height="14" rx="2" ry="2" fill="none" stroke="currentColor" stroke-width="1.5"/>
                <circle cx="6.5" cy="7.5" r="0.9" fill="currentColor"/>
                <circle cx="9.5" cy="7.5" r="0.9" fill="currentColor"/>
                <line x1="6" y1="11" x2="18" y2="11" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                <line x1="6" y1="14" x2="15" y2="14" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
            </svg>
            <span class="code-label">Code</span>
        </button>
        <div class="code-tabs">
            <span class="split-picker split-left"><select id="split-left"></select></span>
            <span class="split-picker split-right"><select id="split-right"></select></span>
            <button class="tab-button active" data-tab="cohesion">Cohesion</button>
            <button class="tab-button" data-tab="separation">Separation</button>
            <button class="tab-button" data-tab="alignment">Alignment</button>
            <button class="tab-button" data-tab="novel">Novel</button>
            <span class="dock-controls" aria-label="Code pane docking controls">
                <!-- Split toggle icon: two panes -->
                <button class="dock-btn" data-action="toggle-split" title="Toggle split view" aria-label="Toggle split view">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <rect x="4" y="5" width="16" height="14" rx="2"/>
                        <line x1="12" y1="6" x2="12" y2="19" stroke="currentColor" stroke-width="1.5"/>
                    </svg>
                </button>
                <!-- Bottom dock icon: bottom band inside a window -->
                <button class="dock-btn" data-dock="bottom" title="Dock bottom" aria-label="Dock bottom">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <rect x="4" y="5" width="16" height="14" rx="2"/>
                        <rect x="5.5" y="16" width="13" height="2.5" fill="currentColor" stroke="none"/>
                    </svg>
                </button>
                <!-- Left dock icon: left band inside a window -->
                <button class="dock-btn" data-dock="left" title="Dock left" aria-label="Dock left">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <rect x="4" y="5" width="16" height="14" rx="2"/>
                        <rect x="5.5" y="6.5" width="2.5" height="11" fill="currentColor" stroke="none"/>
                    </svg>
                </button>
                <!-- Maximize icon: full window fill -->
                <button class="dock-btn" data-dock="max" title="Maximize" aria-label="Maximize">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                        <rect x="4" y="5" width="16" height="14" rx="2"/>
                        <rect x="5.5" y="6.5" width="13" height="11" fill="currentColor" stroke="none"/>
                    </svg>
                </button>
            </span>
        </div>
        <div class="split-view" id="split-view">
            <div class="split-pane" data-slot="left"></div>
            <div class="split-sash" aria-hidden="true"></div>
            <div class="split-pane" data-slot="right"></div>
        </div>
        <div id="cohesion" class="tab-content active"><textarea></textarea></div>
        <div id="separation" class="tab-content"><textarea></textarea></div>
        <div id="alignment" class="tab-content"><textarea></textarea></div>
        <div id="novel" class="tab-content"><textarea></textarea></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jshint/2.13.4/jshint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/lint/lint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/lint/javascript-lint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/show-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/javascript-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.1/chart.min.js"></script>
    
    <script>
    (() => {
        'use strict';

        /**
         * Typedefs to clarify rule API, in-scope vars, and common shapes.
         * These help autocomplete and readability in the embedded editors.
         */
        /**
         * @typedef {Object} Vector
         * @property {number} x
         * @property {number} y
         * @property {(v: Vector) => Vector} add
         * @property {(v: Vector) => Vector} sub
         * @property {(s: number) => Vector} mult
         * @property {(s: number) => Vector} div
         * @property {() => number} mag
         * @property {() => Vector} normalize
         * @property {(max: number) => Vector} limit
         * @property {() => number} heading
         * @property {() => Vector} clone
         */
        /** @typedef {{pos: Vector, vel: Vector, acc: Vector, maxSpeed: number, maxForce: number, hue: number, size: number, update: (gs: GameState) => void, draw: (ctx: CanvasRenderingContext2D) => void}} Boid */
        /** @typedef {{boids: Boid[], quadtree: any, width: number, height: number}} GameState */
        /** @typedef {{pos: {x: number, y: number}, down: boolean}} Mouse */
        /**
         * @typedef {Object} Config
         * @property {number} hue
         * @property {number} boidCount
         * @property {number} maxSpeed
         * @property {number} maxForce
         * @property {number} perceptionRadius
         * @property {boolean} visualizeQuadtree
         * @property {boolean} debug
         * @property {number} cohesionWeight
         * @property {number} separationWeight
         * @property {number} alignmentWeight
         * @property {number} novelWeight
         * @property {'triangle'|'circle'|'oval'|'ring'} boidShape
         * @property {number} boidSize
         * @property {number} boidSizeVariance
         * @property {string} header
         * @property {string} subheader
         */
        /**
         * @callback RuleFunction
         * @param {Boid} boid
         * @param {GameState} gameState
         * @param {Boid[]} neighbors
         * @param {Config} config
         * @param {Mouse} mouse
         * @param {typeof Vector} Vector
         * @param {{
         *   depositTrail: (x:number, y:number, amount?:number) => void,
         *   addDrawable: (fn: (ctx: CanvasRenderingContext2D, gs: GameState) => void) => void
         * }} api - Optional helpers for visuals/overlays.
         * @returns {Vector}
         */

        // --- GLOBAL STATE & CONSTANTS ---
        const canvas = document.getElementById('boids-canvas');
        const ctx = canvas.getContext('2d');

        let config = {};
        const editors = {};
        const charts = {};
        
        let gameState = {
            boids: [],
            quadtree: null,
            width: 0,
            height: 0,
        };

        // Optional rule-driven visuals collection and pheromone trails
        const drawables = [];
        const pheromones = {
            enabled: true,
            cell: 8,
            cols: 0,
            rows: 0,
            grid: null,
            decay: 0.97,
        };

        const RuleAPI = {
            depositTrail(x, y, amount = 1) {
                if (!pheromones.enabled || !pheromones.grid) return;
                const cx = Math.floor(Math.max(0, Math.min(gameState.width - 1, x)) / pheromones.cell);
                const cy = Math.floor(Math.max(0, Math.min(gameState.height - 1, y)) / pheromones.cell);
                const i = cy * pheromones.cols + cx;
                if (i >= 0 && i < pheromones.grid.length) pheromones.grid[i] += amount;
            },
            addDrawable(fn) {
                if (typeof fn !== 'function') return;
                const d = Math.max(0, Math.min(2, typeof config.visualDensity === 'number' ? config.visualDensity : 1));
                // If d < 1, probabilistically skip; if d > 1, occasionally duplicate for richness
                if (d < 1 && Math.random() > d) return;
                drawables.push(fn);
                if (d > 1 && Math.random() < (d - 1)) drawables.push(fn);
            }
        };

        const mouse = {
            pos: { x: -1000, y: -1000 },
            prev: { x: -1000, y: -1000 },
            vel: { x: 0, y: 0 },
            down: false,
            clickEffect: null
        };

        let lastTime = 0;
        let fps = 0;
        const fpsHistory = [];
        const updateTimeHistory = [];
        const drawablesHistory = [];
        const angleHistory = [];
        const MAX_ANGLE_HISTORY = 750;

        const userFunctions = [];

        // --- UTILITY CLASSES & FUNCTIONS ---

        class Vector {
            constructor(x = 0, y = 0) { this.x = x; this.y = y; }
            add(v) { this.x += v.x; this.y += v.y; return this; }
            sub(v) { this.x -= v.x; this.y -= v.y; return this; }
            mult(s) { this.x *= s; this.y *= s; return this; }
            div(s) { if (s !== 0) { this.x /= s; this.y /= s; } return this; }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            normalize() { const m = this.mag(); if (m > 0) this.div(m); return this; }
            limit(max) { if (this.mag() > max) { this.normalize().mult(max); } return this; }
            heading() { return Math.atan2(this.y, this.x); }
            clone() { return new Vector(this.x, this.y); }
            static add(v1, v2) { return new Vector(v1.x + v2.x, v1.y + v2.y); }
            static sub(v1, v2) { return new Vector(v1.x - v2.x, v1.y - v2.y); }
            static dist(v1, v2) { return Vector.sub(v1, v2).mag(); }
            static random2D() { const angle = Math.random() * Math.PI * 2; return new Vector(Math.cos(angle), Math.sin(angle)); }
        }

        function getURLParams() {
            const params = new URLSearchParams(window.location.search);
            const result = {};
            for (const [key, value] of params) {
                try {
                    result[key] = JSON.parse(value);
                } catch (e) {
                    result[key] = value;
                }
            }
            return result;
        }

        function updateURL(key, value) {
            const params = new URLSearchParams(window.location.search);
            params.set(key, JSON.stringify(value));
            const newUrl = `${window.location.pathname}?${params.toString()}`;
            window.history.pushState({ path: newUrl }, '', newUrl);
            logConfig(`URL updated: ${key} = ${JSON.stringify(value)}`);
        }

        function updateAllURLParams() {
            if (!config.debug) return;
            const params = new URLSearchParams();
            for (const key in config) {
                params.set(key, JSON.stringify(config[key]));
            }
            const newUrl = `${window.location.pathname}?${params.toString()}`;
            window.history.replaceState({ path: newUrl }, '', newUrl);
            logConfig('Debug mode: All config params updated in URL.');
        }
        
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function logConfig(...args) {
            if (config.debug) {
                console.log('[Boids Log]', ...args);
            }
        }

        // --- SIMULATION CORE ---

        class Rectangle {
            constructor(x, y, w, h) {
                this.x = x; this.y = y; this.w = w; this.h = h;
            }
            contains(boid) {
                return (boid.pos.x >= this.x - this.w &&
                        boid.pos.x < this.x + this.w &&
                        boid.pos.y >= this.y - this.h &&
                        boid.pos.y < this.y + this.h);
            }
            intersects(range) {
                return !(range.x - range.w > this.x + this.w ||
                         range.x + range.w < this.x - this.w ||
                         range.y - range.h > this.y + this.h ||
                         range.y + range.h < this.y - this.h);
            }
        }

        class QuadTree {
            constructor(boundary, capacity) {
                this.boundary = boundary;
                this.capacity = capacity;
                this.boids = [];
                this.divided = false;
            }

            subdivide() {
                const { x, y, w, h } = this.boundary;
                const nw = new Rectangle(x - w / 2, y - h / 2, w / 2, h / 2);
                this.northwest = new QuadTree(nw, this.capacity);
                const ne = new Rectangle(x + w / 2, y - h / 2, w / 2, h / 2);
                this.northeast = new QuadTree(ne, this.capacity);
                const sw = new Rectangle(x - w / 2, y + h / 2, w / 2, h / 2);
                this.southwest = new QuadTree(sw, this.capacity);
                const se = new Rectangle(x + w / 2, y + h / 2, w / 2, h / 2);
                this.southeast = new QuadTree(se, this.capacity);
                this.divided = true;
            }

            insert(boid) {
                if (!this.boundary.contains(boid)) return false;
                if (this.boids.length < this.capacity) {
                    this.boids.push(boid);
                    return true;
                }
                if (!this.divided) this.subdivide();
                return this.northeast.insert(boid) || this.northwest.insert(boid) || this.southeast.insert(boid) || this.southwest.insert(boid);
            }

            query(range, found = []) {
                if (!this.boundary.intersects(range)) return found;
                for (let b of this.boids) {
                    if (range.contains(b)) found.push(b);
                }
                if (this.divided) {
                    this.northwest.query(range, found);
                    this.northeast.query(range, found);
                    this.southwest.query(range, found);
                    this.southeast.query(range, found);
                }
                return found;
            }

            draw(ctx) {
                ctx.strokeStyle = `hsla(${config.hue}, 100%, 50%, 0.2)`;
                ctx.strokeRect(this.boundary.x - this.boundary.w, this.boundary.y - this.boundary.h, this.boundary.w * 2, this.boundary.h * 2);
                if (this.divided) {
                    this.northeast.draw(ctx); this.northwest.draw(ctx);
                    this.southeast.draw(ctx); this.southwest.draw(ctx);
                }
            }
        }
        
        class Boid {
            constructor(x, y) {
                this.pos = new Vector(x, y);
                this.vel = Vector.random2D().mult(Math.random() * 2 + 2);
                this.acc = new Vector();
                this.maxSpeed = config.maxSpeed;
                this.maxForce = config.maxForce;
                this.hue = (config.hue + (Math.random() * 60 - 30) + 360) % 360;
                this.size = Math.max(1, config.boidSize + (Math.random() * 2 - 1) * config.boidSizeVariance);
            }

            update(gameState) {
                const perceptionRadius = config.perceptionRadius;
                const range = new Rectangle(this.pos.x, this.pos.y, perceptionRadius, perceptionRadius);
                const neighbors = gameState.quadtree.query(range).filter(other => other !== this);
                this.acc.mult(0);
                for (const fn of userFunctions) {
                    if (fn.weight > 0 && fn.updateBoid) {
                        const force = fn.updateBoid(this, gameState, neighbors);
                        if (force instanceof Vector) {
                           force.mult(fn.weight);
                           this.acc.add(force);
                        }
                    }
                }
                this.vel.add(this.acc);
                this.vel.limit(this.maxSpeed);
                this.pos.add(this.vel);
                this.edges();
            }

            edges() {
                if (this.pos.x > gameState.width) this.pos.x = 0;
                else if (this.pos.x < 0) this.pos.x = gameState.width;
                if (this.pos.y > gameState.height) this.pos.y = 0;
                else if (this.pos.y < 0) this.pos.y = gameState.height;
            }

            draw(ctx) {
                const angle = this.vel.heading();
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.rotate(angle);
                ctx.fillStyle = `hsl(${this.hue}, 100%, 70%)`;
                ctx.strokeStyle = `hsl(${this.hue}, 100%, 70%)`;
                ctx.beginPath();
                switch (config.boidShape) {
                    case 'circle':
                        ctx.arc(0, 0, this.size / 1.5, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'ring':
                        ctx.arc(0, 0, this.size / 2, 0, Math.PI * 2);
                        ctx.lineWidth = Math.max(1, this.size / 4);
                        ctx.stroke();
                        break;
                    case 'oval':
                        ctx.scale(1.5, 0.6);
                        ctx.arc(0, 0, this.size / 2, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'triangle':
                    default:
                        ctx.moveTo(this.size, 0);
                        ctx.lineTo(-this.size / 2, -this.size / 2);
                        ctx.lineTo(-this.size / 2, this.size / 2);
                        ctx.closePath();
                        ctx.fill();
                        break;
                }
                ctx.restore();
            }
        }

        // --- DEFAULT USER FUNCTIONS ---
        
        const defaultFunctionsCode = {
          cohesion: `/**
  Rule API
  @function rule
  @param {Boid} boid - Current boid under update (pos, vel, acc, maxSpeed, maxForce, size, hue)
  @param {{boids: Boid[], quadtree: any, width: number, height: number}} gameState - Global sim state
  @param {Boid[]} neighbors - Nearby boids (pre-filtered by perception)
  @param {Object} config - Live configuration (e.g., perceptionRadius, weights, boidShape, etc.)
  @param {{pos: {x:number, y:number}, down: boolean}} mouse - Pointer state
  @param {typeof Vector} Vector - 2D vector helper class
  @param {{depositTrail:(x:number,y:number,a?:number)=>void, addDrawable:(fn:Function)=>void}} api - Optional visuals helpers
  @returns {Vector} Steering force to apply this frame

  Cohesion: steer toward the average position of nearby boids.
  Steps:
    1) Average neighbor positions within perception radius
    2) Desired velocity toward that center at maxSpeed
    3) Steering = desired - current velocity, limited to maxForce
*/
const radius = config.perceptionRadius;
let center = new Vector(0, 0);
let total = 0;
for (const other of neighbors) {
  if (other !== boid) {
    const d = Vector.dist(boid.pos, other.pos);
    if (d > 0 && d < radius) {
      center.add(other.pos);
      total++;
    }
  }
}
if (total === 0) return new Vector(0, 0);
center.div(total);
const desired = Vector.sub(center, boid.pos).normalize().mult(boid.maxSpeed);
return Vector.sub(desired, boid.vel).limit(boid.maxForce);`,

          separation: `/**
  Rule API
  @function rule
  @param {Boid} boid
  @param {{boids: Boid[], quadtree: any, width: number, height: number}} gameState
  @param {Boid[]} neighbors
  @param {Object} config
  @param {{pos: {x:number,y:number}, down: boolean}} mouse
  @param {typeof Vector} Vector
  @param {{depositTrail:(x:number,y:number,a?:number)=>void, addDrawable:(fn:Function)=>void}} api
  @returns {Vector}

  Separation: steer away from nearby boids to avoid crowding.
  Strategy: Inverse-square falloff (1/d^2) gives strong close-range repulsion.
  Tip: Slightly higher force multiplier helps quick response.
*/
const desiredSeparation = Math.max(8, config.boidSize * 2.5);
let steer = new Vector(0, 0);
let total = 0;
for (const other of neighbors) {
  if (other !== boid) {
    const offset = Vector.sub(boid.pos, other.pos);
    const d = offset.mag();
    if (d > 0 && d < desiredSeparation) {
      // Inverse-square falloff: closer ⇒ stronger
      offset.normalize().div(d * d);
      steer.add(offset);
      total++;
    }
  }
}
if (total === 0) return new Vector(0, 0);
steer.div(total).normalize().mult(boid.maxSpeed);
return Vector.sub(steer, boid.vel).limit(boid.maxForce * 1.5);`,

          alignment: `/**
  Rule API
  @function rule
  @param {Boid} boid
  @param {{boids: Boid[], quadtree: any, width: number, height: number}} gameState
  @param {Boid[]} neighbors
  @param {Object} config
  @param {{pos: {x:number,y:number}, down: boolean}} mouse
  @param {typeof Vector} Vector
  @param {{depositTrail:(x:number,y:number,a?:number)=>void, addDrawable:(fn:Function)=>void}} api
  @returns {Vector}

  Alignment: match the average heading (velocity) of neighbors.
*/
const radius = config.perceptionRadius;
let avgVel = new Vector(0, 0);
let total = 0;
for (const other of neighbors) {
  if (other !== boid) {
    const d = Vector.dist(boid.pos, other.pos);
    if (d > 0 && d < radius) {
      avgVel.add(other.vel);
      total++;
    }
  }
}
if (total === 0) return new Vector(0, 0);
avgVel.div(total).normalize().mult(boid.maxSpeed);
return Vector.sub(avgVel, boid.vel).limit(boid.maxForce);`,

          novel: `/**
  Rule API
  @function rule
  @param {Boid} boid
  @param {{boids: Boid[], quadtree: any, width: number, height: number}} gameState
  @param {Boid[]} neighbors
  @param {Object} config
  @param {{pos: {x:number,y:number}, down: boolean}} mouse
  @param {typeof Vector} Vector
  @param {{depositTrail:(x:number,y:number,a?:number)=>void, addDrawable:(fn:Function)=>void}} api
  @returns {Vector}

  Novel: mouse-driven flee force when mouse is down.
  Behavior: if within fleeRadius of the cursor, push away proportionally.
*/
const mouseForce = new Vector(0, 0);
const mousePos = new Vector(mouse.pos.x, mouse.pos.y);
const fleeRadius = 150;
const d = Vector.dist(boid.pos, mousePos);
if (mouse.down && d < fleeRadius) {
  const strength = (fleeRadius - d) / fleeRadius; // 0..1
  const desired = Vector.sub(boid.pos, mousePos) // away from mouse
    .normalize()
    .mult(boid.maxSpeed * 2.0 * strength);
  const steer = Vector.sub(desired, boid.vel).limit(boid.maxForce * 2.0);
  mouseForce.add(steer);
}
return mouseForce;`
        };

        // --- RULE PRESETS ---
        // Tastefully documented presets. Each snippet implements the Rule API and returns a Vector.
        const rulePresets = [
          // Templates — quick starters to illustrate the Drawable API
          { id: 'template-drawable-ring', name: 'Template — Drawable Ring', code: `/**
  Drawable Ring (Template)
  Draws a faint ring at the boid position every frame. No steering.
  Use: replace visuals or steering to build your own rule.
  @returns {Vector}
*/
if (typeof api !== 'undefined' && api && api.addDrawable) {
  const x = boid.pos.x, y = boid.pos.y, r = 12;
  api.addDrawable(function(ctx){
    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.strokeStyle = 'hsla(' + (boid.hue) + ',100%,70%,0.18)';
    ctx.lineWidth = 1; ctx.stroke();
  });
}
return new Vector();` },

          { id: 'template-drawable-streak', name: 'Template — Drawable Streak', code: `/**
  Drawable Streak (Template)
  Draws a short line along current velocity; minimal forward bias.
  @returns {Vector}
*/
const v = boid.vel.clone().normalize().mult(18);
if (typeof api !== 'undefined' && api && api.addDrawable) {
  const x = boid.pos.x, y = boid.pos.y;
  api.addDrawable(function(ctx){
    ctx.beginPath(); ctx.moveTo(x - v.x, y - v.y); ctx.lineTo(x + v.x * 0.3, y + v.y * 0.3);
    ctx.strokeStyle = 'hsla(' + (boid.hue) + ',100%,70%,0.25)'; ctx.lineWidth = 1.5; ctx.stroke();
  });
}
return v.mult(0.001);` },

          { id: 'template-trail-heatmap', name: 'Template — Trail Heatmap', code: `/**
  Trail Heatmap (Template)
  Deposits into the pheromone grid to leave fading trails.
  @returns {Vector}
*/
if (typeof api !== 'undefined' && api && api.depositTrail) {
  api.depositTrail(boid.pos.x, boid.pos.y, 1.0);
}
return new Vector();` },

          { id: 'template-drawable-arrow', name: 'Template — Drawable Arrow', code: `/**
  Drawable Arrow (Template)
  Draws a velocity arrow with a small head; tiny forward bias.
  @returns {Vector}
*/
const dir = boid.vel.clone().normalize();
const L = 18; const x = boid.pos.x, y = boid.pos.y;
if (typeof api !== 'undefined' && api && api.addDrawable) {
  api.addDrawable(function(ctx){
    const tipX = x + dir.x * L, tipY = y + dir.y * L;
    const ortX = -dir.y, ortY = dir.x; // perpendicular
    ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(tipX, tipY);
    ctx.strokeStyle = 'hsla(' + (boid.hue) + ',100%,70%,0.28)'; ctx.lineWidth = 1.5; ctx.stroke();
    // Arrow head
    ctx.beginPath();
    ctx.moveTo(tipX, tipY);
    ctx.lineTo(tipX - dir.x * 5 + ortX * 3, tipY - dir.y * 5 + ortY * 3);
    ctx.moveTo(tipX, tipY);
    ctx.lineTo(tipX - dir.x * 5 - ortX * 3, tipY - dir.y * 5 - ortY * 3);
    ctx.strokeStyle = 'hsla(' + (boid.hue) + ',100%,70%,0.28)'; ctx.lineWidth = 1; ctx.stroke();
  });
}
return dir.mult(0.0015);` },

          { id: 'template-drawable-petals', name: 'Template — Drawable Petals', code: `/**
  Drawable Petals (Template)
  Draws petal-like arcs around the boid. Purely visual.
  @returns {Vector}
*/
if (typeof api !== 'undefined' && api && api.addDrawable) {
  const x=boid.pos.x, y=boid.pos.y, r=8, n=5;
  api.addDrawable(function(ctx){
    ctx.strokeStyle='hsla(' + (boid.hue) + ',100%,70%,0.18)'; ctx.lineWidth=1;
    for (let i=0;i<n;i++) { const a=i*(Math.PI*2/n); ctx.beginPath(); ctx.arc(x+Math.cos(a)*r, y+Math.sin(a)*r, r*0.6, a-0.7, a+0.7); ctx.stroke(); }
  });
}
return new Vector();` },

          { id: 'template-grid-cell-highlight', name: 'Template — Grid Cell Highlight', code: `/**
  Grid Cell Highlight (Template)
  Highlights the 16px grid cell the boid occupies; no steering.
  @returns {Vector}
*/
const CELL=16; const cx=Math.floor(boid.pos.x/CELL)*CELL, cy=Math.floor(boid.pos.y/CELL)*CELL;
if (typeof api !== 'undefined' && api && api.addDrawable) {
  api.addDrawable(function(ctx){
    ctx.strokeStyle='hsla(' + (boid.hue) + ',100%,70%,0.18)'; ctx.lineWidth=1;
    ctx.strokeRect(cx+0.5, cy+0.5, CELL-1, CELL-1);
  });
}
return new Vector();` },

          { id: 'template-metrics-overlay', name: 'Template — Metrics Overlay', code: `/**
  Metrics Overlay (Template)
  Shows speed and neighbor count near the boid. Handy for debugging.
  @returns {Vector}
*/
const speed = boid.vel.mag().toFixed(1);
const ncount = neighbors.length;
if (typeof api !== 'undefined' && api && api.addDrawable) {
  const x=boid.pos.x, y=boid.pos.y;
  api.addDrawable(function(ctx){
    ctx.fillStyle = '#ddd'; ctx.font = '10px monospace'; ctx.textAlign='left';
    ctx.fillText('v:'+speed+' n:'+ncount, x+6, y-6);
  });
}
return new Vector();` },
          // Core rules
          { id: 'cohesion-core', name: 'Cohesion (Core)', code: defaultFunctionsCode.cohesion },
          { id: 'alignment-core', name: 'Alignment (Core)', code: defaultFunctionsCode.alignment },
          { id: 'separation-core', name: 'Separation (Core)', code: defaultFunctionsCode.separation },
          { id: 'novel-core', name: 'Novel (Core)', code: defaultFunctionsCode.novel },

          // Presets — styled with JSDoc and succinct guidance
          { id: 'neighbor-centroid-pull', name: 'Neighbor Centroid Pull', code: `/**
  Neighbor Centroid Pull
  Pull gently toward the average neighbor position (soft cohesion)
  @returns {Vector}
*/
const r = config.perceptionRadius;
let c = new Vector(0, 0), n = 0;
for (const o of neighbors) {
  const d = Vector.dist(boid.pos, o.pos);
  if (d > 0 && d < r) { c.add(o.pos); n++; }
}
if (!n) return new Vector();
c.div(n);
const desired = Vector.sub(c, boid.pos).normalize().mult(boid.maxSpeed * 0.8);
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.8);` },

          { id: 'anti-alignment-swirl', name: 'Anti‑alignment Swirl', code: `/**
  Anti‑alignment Swirl
  Nudge against neighbors' mean heading to create swirling patterns
  @returns {Vector}
*/
const r = config.perceptionRadius;
let v = new Vector(0, 0), n = 0;
for (const o of neighbors) {
  const d = Vector.dist(boid.pos, o.pos);
  if (d > 0 && d < r) { v.add(o.vel); n++; }
}
if (!n) return new Vector();
v.div(n).normalize().mult(boid.maxSpeed);
const anti = v.mult(-1);
return Vector.sub(anti, boid.vel).limit(boid.maxForce * 0.6);` },

          { id: 'local-drag', name: 'Local Drag', code: `/**
  Local Drag
  Denser regions impose stronger drag (viscous slowdown)
  @returns {Vector}
*/
let density = 0;
const r = config.perceptionRadius;
for (const o of neighbors) {
  const d = Vector.dist(boid.pos, o.pos);
  if (d > 0 && d < r) density++;
}
const drag = Math.min(0.9, density * 0.01);
const desired = boid.vel.clone().mult(1 - drag);
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.4);` },

          { id: 'mouse-vortex', name: 'Mouse Vortex', code: `/**
  Mouse Vortex
  Spin around the mouse while pressed (tangential flow)
  @returns {Vector}
*/
if (!mouse.down) return new Vector();
const mp = new Vector(mouse.pos.x, mouse.pos.y);
const toM = Vector.sub(mp, boid.pos);
const d = toM.mag(); if (d < 20) return new Vector();
const tang = new Vector(-toM.y, toM.x).normalize();
const strength = Math.min(1, 200 / (d + 1));
const desired = tang.mult(boid.maxSpeed * strength);
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'mouse-attract', name: 'Mouse Attract / Repel', code: `/**
  Mouse Attract / Repel
  Attract when mouse is down, gently repel otherwise
  @returns {Vector}
*/
const mp = new Vector(mouse.pos.x, mouse.pos.y);
let dir = mouse.down ? Vector.sub(mp, boid.pos) : Vector.sub(boid.pos, mp);
const d = dir.mag(); if (d === 0) return new Vector();
dir.normalize();
const speed = mouse.down ? boid.maxSpeed : boid.maxSpeed * 0.6;
const desired = dir.mult(speed);
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'edge-soft-wall', name: 'Edge Soft Wall', code: `/**
  Edge Soft Wall
  Apply a soft inward force near boundaries
  @returns {Vector}
*/
const margin = 100;
let steer = new Vector();
if (boid.pos.x < margin) steer.x += (margin - boid.pos.x) / margin;
if (boid.pos.x > gameState.width - margin) steer.x -= (boid.pos.x - (gameState.width - margin)) / margin;
if (boid.pos.y < margin) steer.y += (margin - boid.pos.y) / margin;
if (boid.pos.y > gameState.height - margin) steer.y -= (boid.pos.y - (gameState.height - margin)) / margin;
if (steer.mag() > 0) steer.normalize().mult(boid.maxSpeed * 0.8).sub(boid.vel).limit(boid.maxForce * 0.8);
return steer;` },

          { id: 'orbital-centroid', name: 'Orbit Centroid', code: `/**
  Orbit Centroid
  Circle around neighbors' centroid (tangential flow)
  @returns {Vector}
*/
const r = config.perceptionRadius;
let c = new Vector(), n = 0;
for (const o of neighbors) {
  const d = Vector.dist(boid.pos, o.pos);
  if (d > 0 && d < r) { c.add(o.pos); n++; }
}
if (!n) return new Vector();
c.div(n);
const toC = Vector.sub(c, boid.pos);
if (toC.mag() === 0) return new Vector();
const tang = new Vector(-toC.y, toC.x).normalize();
const desired = tang.mult(boid.maxSpeed * 0.9);
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.9);` },

          { id: 'jitter', name: 'Subtle Jitter', code: `/**
  Subtle Jitter
  Add gentle noise for shimmering, organic motion
  @returns {Vector}
*/
const jitter = Vector.random2D().mult(0.2);
const desired = boid.vel.clone().add(jitter).normalize().mult(boid.maxSpeed);
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.3);` },

          { id: 'polarize-hues', name: 'Contrast Neighbor Color', code: `/**
  Contrast Neighbor Color
  Drift hue toward complement of neighbors' average hue
  @returns {Vector}
*/
let h = 0, n = 0;
for (const o of neighbors) { h += o.hue; n++; }
if (n > 0) {
  const avg = (h / n) % 360;
  const contrast = (avg + 180) % 360;
  const step = 0.5; // deg/frame
  let delta = (contrast - boid.hue + 540) % 360 - 180;
  boid.hue = (boid.hue + Math.sign(delta) * Math.min(Math.abs(delta), step) + 360) % 360;
}
return new Vector();` },

          { id: 'nearest-three', name: 'Nearest Three Cohesion', code: `/**
  Nearest Three Cohesion
  Use the three nearest neighbors to compute centroid
  @returns {Vector}
*/
const r = config.perceptionRadius;
const arr = [];
for (const o of neighbors) {
  const d = Vector.dist(boid.pos, o.pos);
  if (d > 0 && d < r) arr.push({ o, d });
}
arr.sort((a, b) => a.d - b.d);
const take = arr.slice(0, 3);
if (!take.length) return new Vector();
let c = new Vector();
for (const t of take) c.add(t.o.pos);
c.div(take.length);
const desired = Vector.sub(c, boid.pos).normalize().mult(boid.maxSpeed);
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'density-separation', name: 'Density Separation', code: `/**
  Density Separation
  Activate strong separation only when very crowded
  @returns {Vector}
*/
let close = 0;
for (const o of neighbors) if (Vector.dist(boid.pos, o.pos) < config.boidSize * 2.2) close++;
if (close < 3) return new Vector();
let steer = new Vector();
for (const o of neighbors) {
  const d = Vector.dist(boid.pos, o.pos);
  if (d > 0 && d < config.boidSize * 2.2) steer.add(Vector.sub(boid.pos, o.pos).normalize().div(d));
}
steer.normalize().mult(boid.maxSpeed).sub(boid.vel).limit(boid.maxForce * 1.6);
return steer;` },

          { id: 'pair-alignment', name: 'Pair Alignment', code: `/**
  Pair Alignment
  Align primarily with the single nearest neighbor
  @returns {Vector}
*/
let minD = Infinity, t = null;
for (const o of neighbors) {
  const d = Vector.dist(boid.pos, o.pos);
  if (d > 0 && d < minD) { minD = d; t = o; }
}
if (!t) return new Vector();
const desired = t.vel.clone().normalize().mult(boid.maxSpeed);
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.8);` },

          { id: 'center-spiral', name: 'Spiral to Center', code: `/**
  Spiral to Center
  Create slow spirals toward the canvas center
  @returns {Vector}
*/
const center = new Vector(gameState.width / 2, gameState.height / 2);
const toC = Vector.sub(center, boid.pos);
if (toC.mag() === 0) return new Vector();
const tang = new Vector(-toC.y, toC.x).normalize();
const desired = tang.mult(boid.maxSpeed * 0.6).add(toC.clone().normalize().mult(boid.maxSpeed * 0.2));
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'random-walk', name: 'Random Walk Bias', code: `/**
  Random Walk Bias
  Add a slowly changing random heading for variety
  @returns {Vector}
*/
if (!boid._randDir || Math.random() < 0.01) boid._randDir = Vector.random2D();
const desired = boid._randDir.clone().mult(boid.maxSpeed * 0.7);
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.6);` },

          { id: 'mouse-spiral-in', name: 'Mouse Spiral In', code: `/**
  Mouse Spiral In
  Spiral inward toward the mouse while pressed
  @returns {Vector}
*/
if (!mouse.down) return new Vector();
const mp = new Vector(mouse.pos.x, mouse.pos.y);
const toM = Vector.sub(mp, boid.pos);
const tang = new Vector(-toM.y, toM.x).normalize();
const desired = tang.mult(boid.maxSpeed * 0.6).add(toM.clone().normalize().mult(boid.maxSpeed * 0.4));
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'split-flock', name: 'Split Flock by Hue', code: `/**
  Split Flock by Hue
  Flock with similar hue; repel dissimilar neighbors
  @returns {Vector}
*/
let like = new Vector(), unlike = new Vector();
let ln = 0, un = 0;
for (const o of neighbors) {
  const diff = Math.abs(((boid.hue - o.hue + 540) % 360) - 180);
  if (diff < 40) { like.add(o.pos); ln++; } else { unlike.add(Vector.sub(boid.pos, o.pos).normalize()); un++; }
}
let steer = new Vector();
if (ln) { like.div(ln); steer.add(Vector.sub(like, boid.pos).normalize()); }
if (un) { steer.add(unlike.div(un)); }
if (steer.mag() > 0) steer.normalize().mult(boid.maxSpeed).sub(boid.vel).limit(boid.maxForce);
return steer;` },

          { id: 'velocity-match-mouse', name: 'Velocity Match (Mouse)', code: `/**
  Velocity Match (Mouse)
  Align with a rotating tangential vector around the mouse
  @returns {Vector}
*/
const mp = new Vector(mouse.pos.x, mouse.pos.y);
const toM = Vector.sub(boid.pos, mp);
const tang = new Vector(-toM.y, toM.x).normalize();
const desired = tang.mult(boid.maxSpeed * 0.7);
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.8);` },

          { id: 'breathing-speed', name: 'Breathing Speed', code: `/**
  Breathing Speed
  Smoothly oscillate target speed over time
  @returns {Vector}
*/
const t = (performance.now() % 4000) / 4000 * 2 * Math.PI;
const sp = 0.5 + 0.5 * Math.sin(t);
const desired = boid.vel.clone().normalize().mult(boid.maxSpeed * (0.5 + 0.5 * sp));
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.5);` },

          { id: 'size-pressure', name: 'Size by Pressure', code: `/**
  Size by Pressure
  Adjust size based on local density (pressure)
  @returns {Vector}
*/
let density = 0;
for (const o of neighbors) if (Vector.dist(boid.pos, o.pos) < config.perceptionRadius * 0.5) density++;
const target = 6 + Math.min(10, density * 0.5);
boid.size += Math.sign(target - boid.size) * 0.2;
return new Vector();` },

          { id: 'seek-voids', name: 'Seek Voids', code: `/**
  Seek Voids
  Move toward least crowded angular sector around the boid
  @returns {Vector}
*/
const sectors = 8;
const counts = new Array(sectors).fill(0);
for (const o of neighbors) {
  const ang = Math.atan2(o.pos.y - boid.pos.y, o.pos.x - boid.pos.x);
  const i = (Math.floor((ang + Math.PI) / (2 * Math.PI) * sectors)) % sectors;
  counts[i]++;
}
let minI = 0; for (let i = 1; i < sectors; i++) if (counts[i] < counts[minI]) minI = i;
const ang = (minI / sectors) * 2 * Math.PI - Math.PI;
const dir = new Vector(Math.cos(ang), Math.sin(ang));
const desired = dir.mult(boid.maxSpeed);
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'pairwise-tether', name: 'Pairwise Tether', code: `/**
  Pairwise Tether
  Spring-like attraction to nearest neighbor with rest length
  @returns {Vector}
*/
let minD = Infinity, t = null;
for (const o of neighbors) {
  const d = Vector.dist(boid.pos, o.pos);
  if (d > 0 && d < minD) { minD = d; t = o; }
}
if (!t) return new Vector();
const rest = config.perceptionRadius * 0.4;
const dir = Vector.sub(t.pos, boid.pos);
const d = dir.mag(); if (d === 0) return new Vector();
const k = 0.02; const f = (d - rest) * k;
const desired = dir.normalize().mult(Math.max(-boid.maxSpeed, Math.min(boid.maxSpeed, f * boid.maxSpeed)));
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'orbit-mouse', name: 'Orbit Mouse', code: `/**
  Orbit Mouse
  Orbit the mouse at a gentle distance, balancing tangential and radial components
  @returns {Vector}
*/
const mp = new Vector(mouse.pos.x, mouse.pos.y);
const toM = Vector.sub(mp, boid.pos);
const d = toM.mag(); if (d === 0) return new Vector();
const targetDist = 120;
const tang = new Vector(-toM.y, toM.x).normalize();
const radial = (d - targetDist) / targetDist;
const desired = tang.mult(boid.maxSpeed * 0.7).add(toM.normalize().mult(boid.maxSpeed * 0.3 * (-radial)));
// Visual: draw faint orbit ring around the mouse occasionally
if (typeof api !== 'undefined' && api && api.addDrawable && Math.random() < 0.08) {
  const cx = mp.x, cy = mp.y, R = targetDist;
  api.addDrawable((ctx) => {
    ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI * 2);
    ctx.strokeStyle = 'hsla(' + (((config.hue + 40) % 360)) + ', 100%, 60%, 0.12)';
    ctx.lineWidth = 1; ctx.stroke();
  });
}
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          // ——— Nature-Inspired (10) ———
          { id: 'nature-ants-trail', name: 'Nature — Ants Trail Following', code: `/**
  Ants Trail Following
  Favor neighbors ahead within a forward cone to emulate pheromone trails.
  Steps:
    1) Compute forward unit vector f from boid velocity.
    2) For neighbors within angle cone (~60°), average their velocities.
    3) Steer to match that average (like following a trail laid ahead).
    4) Deposit a trail at the current position for others to follow.
  @returns {Vector}
*/
const f = boid.vel.clone().normalize();
const cosTheta = Math.cos(Math.PI / 3); // 60° cone
let sum = new Vector(); let n = 0;
for (const o of neighbors) {
  const dir = Vector.sub(o.pos, boid.pos).normalize();
  const ahead = (f.x * dir.x + f.y * dir.y) > cosTheta;
  if (ahead) { sum.add(o.vel); n++; }
}
if (!n) return new Vector();
const desired = sum.div(n).normalize().mult(boid.maxSpeed);
// Leave a pheromone trail mark (amount scales with speed)
if (typeof api !== 'undefined' && api && api.depositTrail) {
  api.depositTrail(boid.pos.x, boid.pos.y, Math.min(1.5, 0.2 + boid.vel.mag() * 0.1));
}
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'nature-predator-shadow', name: 'Nature — Predator Shadowing', code: `/**
  Predator Shadowing
  Treat the fastest neighbor as a potential predator and slip laterally out of its line of approach.
  Idea: move perpendicular to predator->boid vector (evasion without stopping).
  @returns {Vector}
*/
let pred = null; let maxSp = -1;
for (const o of neighbors) { const sp = o.vel.mag(); if (sp > maxSp) { maxSp = sp; pred = o; } }
if (!pred) return new Vector();
const toMe = Vector.sub(boid.pos, pred.pos); if (toMe.mag() === 0) return new Vector();
const lateral = new Vector(-toMe.y, toMe.x).normalize();
const desired = lateral.mult(boid.maxSpeed);
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.9);` },

          { id: 'nature-butterfly-chase', name: 'Nature — Butterfly Mate Chase', code: `/**
  Butterfly Mate Chase
  Chase nearest similar-hue neighbor with a gentle sinusoidal lateral weave.
  @returns {Vector}
*/
let tgt = null; let minD = Infinity;
for (const o of neighbors) {
  const hueDiff = Math.abs(((boid.hue - o.hue + 540) % 360) - 180);
  const d = Vector.dist(boid.pos, o.pos);
  if (hueDiff < 35 && d < minD) { minD = d; tgt = o; }
}
if (!tgt) return new Vector();
const dir = Vector.sub(tgt.pos, boid.pos);
const base = dir.clone().normalize();
const t = performance.now() * 0.003;
const weave = new Vector(-base.y, base.x).mult(0.4 * Math.sin(t));
const desired = base.add(weave).normalize().mult(boid.maxSpeed * 0.9);
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'nature-river-current', name: 'Nature — River Current Drift', code: `/**
  River Current Drift
  Add a position-dependent current (fast midstream, slow near banks) to mimic rivers.
  Field: v_c = (a * sin(π y / H), 0), peaking at screen center.
  @returns {Vector}
*/
const a = 0.6 * boid.maxSpeed;
const H = gameState.height || 1;
const current = new Vector(a * Math.sin(Math.PI * boid.pos.y / H), 0);
const desired = boid.vel.clone().add(current).normalize().mult(boid.maxSpeed);
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.5);` },

          { id: 'nature-thermal-soar', name: 'Nature — Thermal Soaring', code: `/**
  Thermal Soaring
  Birds circle and climb in periodic updraft cells; emulate tangential drift around thermal centers.
  @returns {Vector}
*/
const scale = 220;
const cx = Math.round(boid.pos.x / scale) * scale + scale * 0.5;
const cy = Math.round(boid.pos.y / scale) * scale + scale * 0.5;
const toC = new Vector(cx - boid.pos.x, cy - boid.pos.y);
if (toC.mag() === 0) return new Vector();
const tang = new Vector(-toC.y, toC.x).normalize();
const radial = toC.clone().normalize().mult(0.3);
const desired = tang.mult(boid.maxSpeed * 0.8).add(radial.mult(boid.maxSpeed * 0.2));
// Visual: mark thermal center with a soft dot
if (typeof api !== 'undefined' && api && api.addDrawable && Math.random() < 0.08) {
  const x = cx, y = cy;
  api.addDrawable((ctx) => { ctx.beginPath(); ctx.arc(x, y, 5, 0, Math.PI * 2); ctx.fillStyle = 'hsla(' + (config.hue) + ', 100%, 70%, 0.18)'; ctx.fill(); });
}
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'nature-wolf-encircle', name: 'Nature — Pack Encircle (Mouse)', code: `/**
  Pack Encircle (Mouse)
  When mouse is down (as prey), take up ring positions and orbit to encircle.
  Angle target derived from hue for variety.
  @returns {Vector}
*/
if (!mouse.down) return new Vector();
const mp = new Vector(mouse.pos.x, mouse.pos.y);
const toM = Vector.sub(mp, boid.pos);
const baseAng = ((boid.hue % 360) / 360) * 2 * Math.PI;
const targetR = 140;
const posOnRing = new Vector(Math.cos(baseAng), Math.sin(baseAng)).mult(targetR);
const targetPt = mp.clone().add(posOnRing);
const desired = Vector.sub(targetPt, boid.pos).normalize().mult(boid.maxSpeed * 0.9);
// Visual: ring and spoke to target (sparse)
if (typeof api !== 'undefined' && api && api.addDrawable && Math.random() < 0.08) {
  const cx = mp.x, cy = mp.y, R = targetR, tx = targetPt.x, ty = targetPt.y;
  api.addDrawable((ctx) => {
    ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI * 2);
    ctx.strokeStyle = 'hsla(' + (((config.hue + 20) % 360)) + ', 100%, 60%, 0.12)'; ctx.lineWidth = 1; ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(tx, ty);
    ctx.strokeStyle = 'hsla(' + (config.hue) + ', 100%, 70%, 0.12)'; ctx.lineWidth = 1; ctx.stroke();
  });
}
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'nature-murmuration-accel', name: 'Nature — Murmuration (Accel Coupling)', code: `/**
  Murmuration (Acceleration Coupling)
  React to neighbors' instantaneous accelerations to transmit waves through the flock.
  @returns {Vector}
*/
let sumA = new Vector(); let nA = 0;
for (const o of neighbors) { if (o !== boid) { sumA.add(o.acc); nA++; } }
if (!nA) return new Vector();
const desired = sumA.div(nA).limit(boid.maxForce * 2);
return desired;` },

          { id: 'nature-salmon-upstream', name: 'Nature — Salmon Upstream', code: `/**
  Salmon Upstream
  Swim against a vertically varying flow (opposing a sinusoidal downstream).
  @returns {Vector}
*/
const flowDown = Math.sin(boid.pos.y / 40) * 0.7 * boid.maxSpeed;
const oppose = new Vector(-flowDown, -0.1 * boid.maxSpeed);
const desired = boid.vel.clone().add(oppose).normalize().mult(boid.maxSpeed);
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.6);` },

          { id: 'nature-edge-perch', name: 'Nature — Edge Perching Tendency', code: `/**
  Edge Perching Tendency
  Mild attraction toward horizontal bands as if preferring perches/thermals at certain altitudes.
  @returns {Vector}
*/
const bands = [0.25, 0.5, 0.75];
let bestY = null; let bestScore = Infinity;
for (const b of bands) {
  const y = b * (gameState.height || 1);
  const dy = Math.abs(y - boid.pos.y); if (dy < bestScore) { bestScore = dy; bestY = y; }
}
if (bestY == null) return new Vector();
const desired = new Vector(0, bestY - boid.pos.y).limit(boid.maxForce * 2);
return desired;` },

          { id: 'nature-herd-leader', name: 'Nature — Herd Leader Bias', code: `/**
  Herd Leader Bias
  Favor following the single nearest neighbor (leader) more than the crowd.
  @returns {Vector}
*/
let leader = null; let dmin = Infinity;
for (const o of neighbors) { const d = Vector.dist(boid.pos, o.pos); if (d > 0 && d < dmin) { dmin = d; leader = o; } }
if (!leader) return new Vector();
const desired = leader.vel.clone().normalize().mult(boid.maxSpeed);
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          // ——— CS / ML / AI-Inspired (10) ———
          { id: 'ai-gradient-descent-density', name: 'AI — Gradient Descent on Density', code: `/**
  Gradient Descent on Density
  Minimize crowding by descending the local density gradient (move toward open space).
  Implementation: sum normalized offsets from neighbors (an estimator of ∇density),
  then step opposite that sum with a small learning rate.
  @returns {Vector}
*/
let g = new Vector();
for (const o of neighbors) { g.add(Vector.sub(boid.pos, o.pos).normalize()); }
if (g.mag() === 0) return new Vector();
const lr = 0.8; // learning rate
const desired = g.normalize().mult(boid.maxSpeed * lr);
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'ai-simulated-annealing', name: 'AI — Simulated Annealing Drift', code: `/**
  Simulated Annealing Drift
  Add exploratory noise that cools over time to escape local minima, then settle.
  @returns {Vector}
*/
const T0 = 1.0, halfLifeMs = 12000; // initial temp and cooling rate
const t = performance.now();
const T = T0 * Math.pow(0.5, t / halfLifeMs);
const rnd = Vector.random2D().mult(boid.maxSpeed * 0.5 * T);
return Vector.sub(rnd, new Vector()).limit(boid.maxForce * 0.6);` },

          { id: 'ai-pid-speed', name: 'AI — PID Speed Controller', code: `/**
  PID Speed Controller
  Keep speed near a target using a simple proportional term (I/D omitted for stability without memory).
  @returns {Vector}
*/
const v = boid.vel.mag();
const target = boid.maxSpeed * 0.75;
const err = target - v;
const kp = 0.6;
const desired = boid.vel.clone().normalize().mult(v + kp * err);
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.6);` },

          { id: 'ai-robust-median-heading', name: 'AI — Robust Median Heading', code: `/**
  Robust Median Heading
  Compute a circular median of neighbor headings (robust to outliers) and align to it.
  @returns {Vector}
*/
const angs = [];
for (const o of neighbors) { if (o !== boid) angs.push(Math.atan2(o.vel.y, o.vel.x)); }
if (!angs.length) return new Vector();
angs.sort((a,b) => a-b);
const med = angs[Math.floor(angs.length/2)];
const dir = new Vector(Math.cos(med), Math.sin(med));
const desired = dir.mult(boid.maxSpeed);
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'ai-reward-shaping', name: 'AI — Reward Shaping (Mouse Attraction)', code: `/**
  Reward Shaping (Mouse Attraction)
  Encourage moving toward the mouse (reward) while avoiding high density (penalty).
  @returns {Vector}
*/
const toMouse = new Vector(mouse.pos.x - boid.pos.x, mouse.pos.y - boid.pos.y);
let density = 0; for (const o of neighbors) if (Vector.dist(boid.pos, o.pos) < config.perceptionRadius * 0.7) density++;
const reward = toMouse.normalize().mult(boid.maxSpeed * 0.6);
const penalty = new Vector(); if (density > 0) penalty.add(boid.vel.clone().mult(-0.2 * Math.min(1, density / 8)));
const desired = reward.add(penalty).normalize().mult(boid.maxSpeed);
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'ai-entropy-seeking', name: 'AI — Entropy-Seeking Heading', code: `/**
  Entropy-Seeking Heading
  Avoid dominant local heading by nudging perpendicular to the majority, increasing directional diversity.
  @returns {Vector}
*/
let v = new Vector(); let n = 0; for (const o of neighbors) { v.add(o.vel); n++; }
if (!n) return new Vector();
const mean = v.div(n);
const perp = new Vector(-mean.y, mean.x).normalize();
const desired = perp.mult(boid.maxSpeed * 0.7);
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.8);` },

          { id: 'ai-hash-goal-explore', name: 'AI — Hash-Cell Exploration', code: `/**
  Hash-Cell Exploration
  Map space to a grid and use a simple hash to pick a persistent pseudo-random heading per cell.
  @returns {Vector}
*/
const cell = 120; const cx = Math.floor(boid.pos.x / cell), cy = Math.floor(boid.pos.y / cell);
let h = (cx * 73856093) ^ (cy * 19349663);
h ^= (h << 13); h ^= (h >> 17); h ^= (h << 5);
const ang = ((h >>> 0) % 6283) / 1000 - Math.PI; // [-π, π)
const dir = new Vector(Math.cos(ang), Math.sin(ang));
const desired = dir.mult(boid.maxSpeed * 0.9);
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 0.8);` },

          { id: 'ai-laplacian-smoothing', name: 'AI — Laplacian Velocity Smoothing', code: `/**
  Laplacian Velocity Smoothing
  Steer toward the distance-weighted average neighbor velocity (graph Laplacian intuition).
  @returns {Vector}
*/
let sumV = new Vector(); let sumW = 0;
for (const o of neighbors) { const d = Math.max(1, Vector.dist(boid.pos, o.pos)); const w = 1 / (d*d); sumV.add(o.vel.clone().mult(w)); sumW += w; }
if (sumW === 0) return new Vector();
const avg = sumV.div(sumW).normalize().mult(boid.maxSpeed);
return Vector.sub(avg, boid.vel).limit(boid.maxForce);` },

          { id: 'ai-attention-k', name: 'AI — Attention to k Nearest', code: `/**
  Attention to k Nearest
  Focus on the k nearest neighbors with inverse-distance weights (attention-like).
  @returns {Vector}
*/
const k = 5; const arr = neighbors.slice().map(o => ({ o, d: Vector.dist(boid.pos, o.pos) })).filter(x => x.d > 0);
arr.sort((a,b)=>a.d-b.d);
let acc = new Vector(); let wsum = 0; for (let i=0;i<Math.min(k,arr.length);i++){ const w=1/arr[i].d; acc.add(arr[i].o.vel.clone().mult(w)); wsum+=w; }
if (!wsum) return new Vector();
const desired = acc.div(wsum).normalize().mult(boid.maxSpeed);
// Visual: lines to attended neighbors (sparse)
if (typeof api !== 'undefined' && api && api.addDrawable && Math.random() < 0.12) {
  const bx = boid.pos.x, by = boid.pos.y; const take = Math.min(k, arr.length);
  api.addDrawable((ctx) => {
    ctx.strokeStyle = 'hsla(' + (((config.hue + 80) % 360)) + ', 100%, 70%, 0.12)'; ctx.lineWidth = 1;
    for (let i = 0; i < take; i++) { ctx.beginPath(); ctx.moveTo(bx, by); ctx.lineTo(arr[i].o.pos.x, arr[i].o.pos.y); ctx.stroke(); }
  });
}
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'ai-decision-tree', name: 'AI — Decision Tree (Stateful Guard)', code: `/**
  Decision Tree (Stateful Guard)
  If local density > threshold, prioritize separation-like open-space seeking; else use cohesion-like pull.
  @returns {Vector}
*/
let close = 0; for (const o of neighbors) if (Vector.dist(boid.pos, o.pos) < config.perceptionRadius * 0.6) close++;
if (close > 6) {
  // open space
  let g = new Vector(); for (const o of neighbors) g.add(Vector.sub(boid.pos, o.pos).normalize());
  if (g.mag()===0) return new Vector();
  return g.normalize().mult(boid.maxSpeed).sub(boid.vel).limit(boid.maxForce);
} else {
  // cohesion
  let c = new Vector(); let n=0; for (const o of neighbors){ c.add(o.pos); n++; }
  if (!n) return new Vector(); c.div(n);
  return Vector.sub(c.sub(boid.pos).normalize().mult(boid.maxSpeed), boid.vel).limit(boid.maxForce);
}` },

          // ——— Physics / Math-Inspired (10) ———
          { id: 'phys-lennard-jones', name: 'Physics — Lennard-Jones Potential', code: `/**
  Lennard-Jones Potential
  Models short-range repulsion and longer-range attraction: F(r) ~ 24ε[(2(σ/r)^13) - (σ/r)^7].
  Implementation uses a smoothed approximation to avoid singularities.
  @returns {Vector}
*/
const sigma = Math.max(8, config.boidSize);
const epsilon = 0.3;
let F = new Vector();
for (const o of neighbors) {
  const rVec = Vector.sub(o.pos, boid.pos); let r = rVec.mag(); if (r < 1) r = 1;
  const sr = sigma / r; const sr6 = Math.pow(sr,6); const sr12 = sr6*sr6;
  const mag = 24*epsilon*((2*sr12) - sr6) / r; // derivative scaled
  F.add(rVec.normalize().mult(mag));
}
// Visual: local connection mesh (sparse)
if (typeof api !== 'undefined' && api && api.addDrawable && Math.random() < 0.08) {
  api.addDrawable((ctx) => {
    ctx.strokeStyle = 'hsla(' + (((config.hue + 140) % 360)) + ', 100%, 65%, 0.1)'; ctx.lineWidth = 1;
    for (const o of neighbors) { const d = Vector.dist(boid.pos, o.pos); if (d < config.perceptionRadius * 0.6) { ctx.beginPath(); ctx.moveTo(boid.pos.x, boid.pos.y); ctx.lineTo(o.pos.x, o.pos.y); ctx.stroke(); } }
  });
}
return F.limit(boid.maxForce);` },

          { id: 'phys-coulomb-hue', name: 'Physics — Coulomb by Hue', code: `/**
  Coulomb by Hue
  Assign pseudo-charge from hue: similar hues attract, dissimilar repel (cosine in hue circle).
  F ~ k q_i q_j / r^2 along the line.
  @returns {Vector}
*/
let force = new Vector();
for (const o of neighbors) {
  const dh = Math.abs(((boid.hue - o.hue + 540) % 360) - 180);
  const qi = Math.cos((boid.hue/180)*Math.PI), qj = Math.cos((o.hue/180)*Math.PI);
  const q = Math.cos(dh/180*Math.PI) * qi * qj;
  let rVec = Vector.sub(o.pos, boid.pos); let r = rVec.mag(); if (r < 4) r = 4;
  const mag = (q) / (r*r);
  force.add(rVec.normalize().mult(mag));
}
return force.limit(boid.maxForce);` },

          { id: 'phys-harmonic-center', name: 'Physics — Harmonic to Center', code: `/**
  Harmonic to Center
  Spring toward screen center with mild damping: F = -k(x - x_c).
  @returns {Vector}
*/
const cx = (gameState.width||0)/2, cy = (gameState.height||0)/2;
const k = 0.0025;
const toC = new Vector(cx - boid.pos.x, cy - boid.pos.y);
return toC.mult(k * boid.maxSpeed * 50).limit(boid.maxForce);` },

          { id: 'phys-gyroscopic', name: 'Physics — Gyroscopic Precession', code: `/**
  Gyroscopic Precession
  Accelerate perpendicular to current acceleration to create smooth arcs.
  @returns {Vector}
*/
const a = boid.acc.clone(); if (a.mag() === 0) return new Vector();
const perp = new Vector(-a.y, a.x).normalize().mult(boid.maxSpeed*0.6);
return Vector.sub(perp, boid.vel).limit(boid.maxForce*0.8);` },

          { id: 'phys-rotating-field', name: 'Physics — Rotating Vector Field', code: `/**
  Rotating Vector Field
  A simple divergence-free field: v = (sin(y/L), -sin(x/L)) producing curls.
  @returns {Vector}
*/
const L = 90;
const field = new Vector(Math.sin(boid.pos.y / L), -Math.sin(boid.pos.x / L)).mult(boid.maxSpeed*0.8);
// Visual: field hint arrow (sparse)
if (typeof api !== 'undefined' && api && api.addDrawable && Math.random() < 0.12) {
  const x = boid.pos.x, y = boid.pos.y; const fx = field.x * 0.2, fy = field.y * 0.2;
  api.addDrawable((ctx) => { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + fx, y + fy); ctx.strokeStyle = 'hsla(' + (config.hue) + ', 100%, 70%, 0.18)'; ctx.lineWidth = 1; ctx.stroke(); });
}
return Vector.sub(field, boid.vel).limit(boid.maxForce);` },

          { id: 'math-lissajous', name: 'Math — Lissajous Driver', code: `/**
  Lissajous Driver
  Target a parametric Lissajous heading: x = sin(a t), y = sin(b t + δ) applied as desired direction.
  @returns {Vector}
*/
const t = performance.now() * 0.002;
const a = 1.0, b = 1.7, d = Math.PI/3;
const dir = new Vector(Math.sin(a*t), Math.sin(b*t + d)).normalize();
const desired = dir.mult(boid.maxSpeed);
return Vector.sub(desired, boid.vel).limit(boid.maxForce*0.7);` },

          { id: 'phys-brownian', name: 'Physics — Brownian Jitter', code: `/**
  Brownian Jitter
  Add small unbiased random impulses to simulate thermal noise.
  @returns {Vector}
*/
return Vector.random2D().mult(boid.maxForce * 0.5);` },

          { id: 'math-scalar-potential', name: 'Math — Scalar Potential Flow', code: `/**
  Scalar Potential Flow
  Move along negative gradient of φ(x,y) = sin(x/L) cos(y/L) to follow potential valleys.
  @returns {Vector}
*/
const L = 120;
const dphidx = Math.cos(boid.pos.x / L) * Math.cos(boid.pos.y / L) / L;
const dphidy = -Math.sin(boid.pos.x / L) * Math.sin(boid.pos.y / L) / L;
const grad = new Vector(dphidx, dphidy);
const desired = grad.mult(-1).normalize().mult(boid.maxSpeed*0.8);
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'math-golden-spiral-center', name: 'Math — Golden Spiral to Center', code: `/**
  Golden Spiral to Center
  Steer along a logarithmic spiral toward the screen center with golden ratio turn.
  @returns {Vector}
*/
const cx = (gameState.width||0)/2, cy = (gameState.height||0)/2;
const toC = new Vector(cx - boid.pos.x, cy - boid.pos.y);
if (toC.mag() === 0) return new Vector();
const phi = (1 + Math.sqrt(5)) / 2; // golden ratio
const tang = new Vector(-toC.y, toC.x).normalize();
const desired = toC.normalize().mult(boid.maxSpeed*0.5).add(tang.mult(boid.maxSpeed*0.5/phi));
// Visual: tiny spiral stroke fragment (sparse)
if (typeof api !== 'undefined' && api && api.addDrawable && Math.random() < 0.1) {
  const x = boid.pos.x, y = boid.pos.y; const vx = desired.x * 0.25, vy = desired.y * 0.25;
  api.addDrawable((ctx) => { ctx.beginPath(); ctx.moveTo(x, y); ctx.quadraticCurveTo(x + vy * 0.5, y - vx * 0.5, x + vx, y + vy); ctx.strokeStyle = 'hsla(' + (((config.hue + 300) % 360)) + ', 100%, 70%, 0.15)'; ctx.lineWidth = 1; ctx.stroke(); });
}
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          { id: 'math-fibonacci-spacing', name: 'Math — Fibonacci Spacing', code: `/**
  Fibonacci Spacing
  Encourage nearest-neighbor distance toward τ·size (τ ≈ golden ratio), repelling if closer and attracting if farther.
  @returns {Vector}
*/
let near = null; let dmin = Infinity;
for (const o of neighbors) { const d = Vector.dist(boid.pos, o.pos); if (d>0 && d<dmin) { dmin=d; near=o; } }
if (!near || !isFinite(dmin)) return new Vector();
const tau = (1 + Math.sqrt(5)) / 2;
const rest = Math.max(8, boid.size * tau);
const dir = Vector.sub(near.pos, boid.pos);
const sign = dmin > rest ? 1 : -1;
const desired = dir.normalize().mult(sign * boid.maxSpeed * Math.min(1, Math.abs(dmin-rest)/rest));
return Vector.sub(desired, boid.vel).limit(boid.maxForce);` },

          // ——— Visual Showcase (20) ———
          { id: 'visual-comet-trails', name: 'Visual — Comet Trails', code: `/**
  Comet Trails
  Draw short streaks behind boids; gentle forward bias.
  @returns {Vector}
*/
if (typeof api !== 'undefined' && api && api.addDrawable && Math.random() < 0.25) {
  const x=boid.pos.x,y=boid.pos.y; const t=boid.vel.clone().normalize().mult(10);
  api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.moveTo(x-t.x, y-t.y); ctx.lineTo(x, y); ctx.strokeStyle='hsla(' + (boid.hue) + ',100%,70%,0.28)'; ctx.lineWidth=1.5; ctx.stroke(); });
}
return boid.vel.clone().normalize().mult(0.001);` },

          { id: 'visual-ribbon-curves', name: 'Visual — Ribbon Curves', code: `/**
  Ribbon Curves
  Curvy quadratic strokes along velocity normals; slight lateral steer.
  @returns {Vector}
*/
const n = new Vector(-boid.vel.y, boid.vel.x).normalize();
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.18){
  const x=boid.pos.x,y=boid.pos.y; const v=boid.vel.clone().normalize().mult(12);
  api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.moveTo(x-v.x, y-v.y); ctx.quadraticCurveTo(x+n.x*6, y+n.y*6, x+v.x*0.4, y+v.y*0.4); ctx.strokeStyle='hsla(' + (((boid.hue+40)%360)) + ',100%,65%,0.22)'; ctx.lineWidth=1.2; ctx.stroke(); });
}
return n.mult(0.002);` },

          { id: 'visual-pulse-rings', name: 'Visual — Pulse Rings', code: `/**
  Pulse Rings
  Soft rings that expand from boid positions; minimal steering.
  @returns {Vector}
*/
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.08){
  const x=boid.pos.x,y=boid.pos.y,r=6+Math.random()*10;
  api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.strokeStyle='hsla(' + (((config.hue+80)%360)) + ',100%,70%,0.2)'; ctx.lineWidth=1; ctx.stroke();});
}
return new Vector();` },

          { id: 'visual-starburst', name: 'Visual — Starburst', code: `/**
  Starburst
  Short cross lines at select boids; slight radial push.
  @returns {Vector}
*/
const sp = boid.vel.clone().normalize(); const pr = new Vector(-sp.y, sp.x);
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.06){
  const x=boid.pos.x,y=boid.pos.y; const L=8;
  api.addDrawable((ctx)=>{ ctx.strokeStyle='hsla(' + (((config.hue+120)%360)) + ',100%,75%,0.22)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(x-L*sp.x,y-L*sp.y); ctx.lineTo(x+L*sp.x,y+L*sp.y); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x-L*pr.x,y-L*pr.y); ctx.lineTo(x+L*pr.x,y+L*pr.y); ctx.stroke();});
}
return sp.mult(0.002);` },

          { id: 'visual-aurora-bands', name: 'Visual — Aurora Bands', code: `/**
  Aurora Bands
  Horizontal translucent bands tied to y; no steering.
  @returns {Vector}
*/
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.05){
  const y=boid.pos.y; const h=12;
  api.addDrawable((ctx)=>{ ctx.fillStyle='hsla(' + (((config.hue+180)%360)) + ',100%,60%,0.06)'; ctx.fillRect(0,y-h/2,gameState.width,h); });
}
return new Vector();` },

          { id: 'visual-flow-ribbons', name: 'Visual — Flow Ribbons', code: `/**
  Flow Ribbons
  Draw two offset strokes along velocity; slight forward drive.
  @returns {Vector}
*/
const dir = boid.vel.clone().normalize(); const ort = new Vector(-dir.y, dir.x);
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.2){
  const x=boid.pos.x,y=boid.pos.y; const L=14;
  api.addDrawable((ctx)=>{ ctx.strokeStyle='hsla(' + (boid.hue) + ',100%,70%,0.18)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(x+ort.x*2,y+ort.y*2); ctx.lineTo(x+dir.x*L+ort.x*2,y+dir.y*L+ort.y*2); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x-ort.x*2,y-ort.y*2); ctx.lineTo(x+dir.x*L-ort.x*2,y+dir.y*L-ort.y*2); ctx.stroke();});
}
return dir.mult(0.002);` },

          { id: 'visual-fireflies', name: 'Visual — Fireflies', code: `/**
  Fireflies
  Twinkling dots with slight wander.
  @returns {Vector}
*/
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.15){
  const x=boid.pos.x,y=boid.pos.y; const a=0.2+Math.random()*0.5;
  api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.arc(x,y,1.8,0,Math.PI*2); ctx.fillStyle='hsla(' + (boid.hue) + ',100%,80%,' + a.toFixed(2) + ')'; ctx.fill(); });
}
return Vector.random2D().mult(0.003);` },

          { id: 'visual-vortex-spirals', name: 'Visual — Vortex Spirals', code: `/**
  Vortex Spirals
  Spiral glyphs perpendicular to velocity; slight swirl.
  @returns {Vector}
*/
const nrm=new Vector(-boid.vel.y, boid.vel.x).normalize();
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.08){
  const x=boid.pos.x,y=boid.pos.y; const r=8;
  api.addDrawable((ctx)=>{ ctx.beginPath(); for(let a=0;a<Math.PI*1.5;a+=0.3){ const R=r*a/(Math.PI*1.5); const px=x+Math.cos(a)*R, py=y+Math.sin(a)*R; if(a===0)ctx.moveTo(px,py); else ctx.lineTo(px,py);} ctx.strokeStyle='hsla(' + (((config.hue+220)%360)) + ',100%,70%,0.18)'; ctx.lineWidth=1; ctx.stroke();});
}
return nrm.mult(0.002);` },

          { id: 'visual-chord-weave', name: 'Visual — Chord Weave', code: `/**
  Chord Weave
  Connect random nearby boids to form chordal meshes.
  @returns {Vector}
*/
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.08){
  const bx=boid.pos.x,by=boid.pos.y; const maxL=config.perceptionRadius*0.5;
  api.addDrawable((ctx)=>{ ctx.strokeStyle='hsla(' + (((config.hue+260)%360)) + ',100%,70%,0.10)'; ctx.lineWidth=1; for(const o of neighbors){ const d=Vector.dist(boid.pos,o.pos); if(d<maxL && Math.random()<0.2){ ctx.beginPath(); ctx.moveTo(bx,by); ctx.lineTo(o.pos.x,o.pos.y); ctx.stroke(); } } });
}
return new Vector();` },

          { id: 'visual-lattice-ripples', name: 'Visual — Lattice Ripples', code: `/**
  Lattice Ripples
  Horizontal/vertical hints forming a loose lattice.
  @returns {Vector}
*/
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.07){
  const x=boid.pos.x,y=boid.pos.y,dx=10,dy=10;
  api.addDrawable((ctx)=>{ ctx.strokeStyle='hsla(' + (((config.hue+20)%360)) + ',100%,60%,0.08)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(x-dx,y); ctx.lineTo(x+dx,y); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x,y-dy); ctx.lineTo(x,y+dy); ctx.stroke();});
}
return new Vector();` },

          { id: 'visual-kaleido-fan', name: 'Visual — Kaleido Fan', code: `/**
  Kaleido Fan
  Short fan of rays from boid heading.
  @returns {Vector}
*/
const d=boid.vel.clone().normalize(); const ang=Math.atan2(d.y,d.x);
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.06){
  const x=boid.pos.x,y=boid.pos.y; const rays=5; const L=12;
  api.addDrawable((ctx)=>{ ctx.strokeStyle='hsla(' + (((config.hue+300)%360)) + ',100%,70%,0.15)'; ctx.lineWidth=1; for(let i=-2;i<=2;i++){ const a=ang+i*0.12; ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+Math.cos(a)*L,y+Math.sin(a)*L); ctx.stroke(); }});
}
return d.mult(0.002);` },

          { id: 'visual-petal-swirl', name: 'Visual — Petal Swirl', code: `/**
  Petal Swirl
  Petal-like arcs around moving boids.
  @returns {Vector}
*/
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.08){
  const x=boid.pos.x,y=boid.pos.y; const r=7; const n=4;
  api.addDrawable((ctx)=>{ ctx.strokeStyle='hsla(' + (((config.hue+340)%360)) + ',100%,70%,0.18)'; ctx.lineWidth=1; for(let i=0;i<n;i++){ const a=i*(Math.PI*2/n); ctx.beginPath(); ctx.arc(x+Math.cos(a)*r,y+Math.sin(a)*r, r*0.6, a-0.8, a+0.8); ctx.stroke(); } });
}
return new Vector();` },

          { id: 'visual-tide-lines', name: 'Visual — Tide Lines', code: `/**
  Tide Lines
  Faint angled stripes; minimal steer along stripe.
  @returns {Vector}
*/
const a=0.4; const dir=new Vector(Math.cos(a),Math.sin(a));
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.05){
  const y=boid.pos.y; api.addDrawable((ctx)=>{ ctx.strokeStyle='hsla(' + (((config.hue+30)%360)) + ',100%,65%,0.06)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(gameState.width,y+Math.tan(a)*gameState.width); ctx.stroke(); });
}
return dir.mult(0.001);` },

          { id: 'visual-wave-interference', name: 'Visual — Wave Interference', code: `/**
  Wave Interference
  Concentric arcs offset by phase; mild oscillatory steer.
  @returns {Vector}
*/
const t=performance.now()*0.002; const w=0.6; const osc=Math.sin(t+w*boid.pos.x*0.02);
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.06){
  const x=boid.pos.x,y=boid.pos.y,r=8+osc*4; api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.strokeStyle='hsla(' + (((config.hue+200)%360)) + ',100%,70%,0.12)'; ctx.stroke(); });
}
return boid.vel.clone().normalize().mult(0.0015*osc);` },

          { id: 'visual-orbit-petals', name: 'Visual — Orbit Petals', code: `/**
  Orbit Petals
  Petal arcs around the mouse position; draws only when pressed.
  @returns {Vector}
*/
if (!mouse.down) return new Vector();
const mp=new Vector(mouse.pos.x,mouse.pos.y); const toM=Vector.sub(mp,boid.pos); const tang=new Vector(-toM.y,toM.x).normalize();
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.1){
  const x=mp.x,y=mp.y,r=120; api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.arc(x,y,r,Math.atan2(tang.y,tang.x)-0.3, Math.atan2(tang.y,tang.x)+0.3); ctx.strokeStyle='hsla(' + (((config.hue+40)%360)) + ',100%,65%,0.15)'; ctx.lineWidth=1; ctx.stroke();});
}
return Vector.sub(tang.mult(boid.maxSpeed*0.6), boid.vel).limit(boid.maxForce*0.6);` },

          { id: 'visual-braids', name: 'Visual — Braids', code: `/**
  Braids
  Paired offset strokes that weave as velocities change.
  @returns {Vector}
*/
const dvec=boid.vel.clone().normalize(); const o=new Vector(-dvec.y,dvec.x).mult(3);
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.18){
  const x=boid.pos.x,y=boid.pos.y,L=14; api.addDrawable((ctx)=>{ ctx.strokeStyle='hsla(' + (((config.hue+280)%360)) + ',100%,70%,0.14)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(x+o.x,y+o.y); ctx.lineTo(x+dvec.x*L+o.x,y+dvec.y*L+o.y); ctx.stroke(); ctx.beginPath(); ctx.moveTo(x-o.x,y-o.y); ctx.lineTo(x+dvec.x*L-o.x,y+dvec.y*L-o.y); ctx.stroke();});
}
return dvec.mult(0.002);` },

          { id: 'visual-constellation-lines', name: 'Visual — Constellation Lines', code: `/**
  Constellation Lines
  Connect sparse nearby boids to form constellations.
  @returns {Vector}
*/
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.04){
  const bx=boid.pos.x,by=boid.pos.y; api.addDrawable((ctx)=>{ ctx.strokeStyle='hsla(' + (((config.hue+90)%360)) + ',100%,70%,0.12)'; ctx.lineWidth=1; for(const o of neighbors){ const d=Vector.dist(boid.pos,o.pos); if(d<80 && Math.random()<0.05){ ctx.beginPath(); ctx.moveTo(bx,by); ctx.lineTo(o.pos.x,o.pos.y); ctx.stroke(); } } });
}
return new Vector();` },

          { id: 'visual-shockwave-rings', name: 'Visual — Shockwave Rings', code: `/**
  Shockwave Rings
  Radiating rings from the mouse when pressed; boids mildly flee.
  @returns {Vector}
*/
if (!mouse.down) return new Vector();
const mp=new Vector(mouse.pos.x,mouse.pos.y); const d=Vector.dist(boid.pos,mp); const dir=Vector.sub(boid.pos,mp).normalize();
if (typeof api!=='undefined'&&api&&api.addDrawable){ const r= (performance.now()/12)%200; api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.arc(mp.x,mp.y,r,0,Math.PI*2); ctx.strokeStyle='hsla(' + (config.hue) + ',100%,65%,0.18)'; ctx.lineWidth=1; ctx.stroke();}); }
return dir.mult(boid.maxSpeed*Math.max(0, 1-d/200)).sub(boid.vel).limit(boid.maxForce);` },

          { id: 'visual-heartline-field', name: 'Visual — Heartline Field', code: `/**
  Heartline Field
  Draw bezier heart curves centered on boids; low-force drift.
  @returns {Vector}
*/
if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.04){
  const x=boid.pos.x,y=boid.pos.y,s=6;
  api.addDrawable((ctx)=>{ ctx.strokeStyle='hsla(' + (((config.hue+330)%360)) + ',100%,70%,0.18)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(x, y-s); ctx.bezierCurveTo(x-s, y-s*1.6, x-s*1.2, y, x, y+s); ctx.moveTo(x, y-s); ctx.bezierCurveTo(x+s, y-s*1.6, x+s*1.2, y, x, y+s); ctx.stroke();});
}
return new Vector();` },

          { id: 'visual-neon-echoes', name: 'Visual — Neon Echoes', code: `/**
  Neon Echoes
  Two echoing outlines trailing behind boids.
  @returns {Vector}
*/
const u=boid.vel.clone().normalize(); if (typeof api!=='undefined'&&api&&api.addDrawable&&Math.random()<0.2){ const x=boid.pos.x,y=boid.pos.y; api.addDrawable((ctx)=>{ ctx.strokeStyle='hsla(' + (((config.hue+20)%360)) + ',100%,70%,0.16)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(x-u.x*6,y-u.y*6); ctx.lineTo(x-u.x*2,y-u.y*2); ctx.stroke(); ctx.strokeStyle='hsla(' + (((config.hue+200)%360)) + ',100%,70%,0.12)'; ctx.beginPath(); ctx.moveTo(x-u.x*10,y-u.y*10); ctx.lineTo(x-u.x*6,y-u.y*6); ctx.stroke();}); }
return u.mult(0.002);` },

          // ——— Interaction‑Driven (Clicks/Drags) ———
          { id: 'click-gravity-well-strong', name: 'Click — Gravity Well (Strong)', code: `/**
  Gravity Well (Strong)
  When mouse is down, pull boids strongly toward the cursor with 1/r falloff.
  @returns {Vector}
*/
if (!mouse.down) return new Vector();
const mp = new Vector(mouse.pos.x, mouse.pos.y);
const toM = Vector.sub(mp, boid.pos);
const d = Math.max(1, toM.mag());
const force = toM.normalize().mult(boid.maxSpeed * Math.min(1.5, 120 / d));
// Visual
if (typeof api !== 'undefined' && api && api.addDrawable) { const x=mp.x,y=mp.y; api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.arc(x,y,80,0,Math.PI*2); ctx.strokeStyle='hsla(' + (config.hue) + ',100%,65%,0.12)'; ctx.lineWidth=1; ctx.stroke(); }); }
return Vector.sub(force, boid.vel).limit(boid.maxForce * 2.0);` },

          { id: 'click-explosion', name: 'Click — Explosion', code: `/**
  Explosion
  Strong outward impulse away from mouse when pressed.
  @returns {Vector}
*/
if (!mouse.down) return new Vector();
const mp = new Vector(mouse.pos.x, mouse.pos.y);
const away = Vector.sub(boid.pos, mp); const d = Math.max(1, away.mag());
const magnitude = Math.min(2.2, 160 / d);
const desired = away.normalize().mult(boid.maxSpeed * magnitude);
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 2.5);` },

          { id: 'click-vortex-strong', name: 'Click — Vortex (Strong)', code: `/**
  Vortex (Strong)
  Combines tangential spin with mild inward pull around the mouse when pressed.
  @returns {Vector}
*/
if (!mouse.down) return new Vector();
const mp = new Vector(mouse.pos.x, mouse.pos.y);
const toM = Vector.sub(mp, boid.pos); const d = Math.max(1, toM.mag());
const tang = new Vector(-toM.y, toM.x).normalize();
const desired = tang.mult(boid.maxSpeed * 1.1).add(toM.normalize().mult(boid.maxSpeed * 0.25));
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 2.0);` },

          { id: 'click-brake-zone', name: 'Click — Brake Zone', code: `/**
  Brake Zone
  Boids near the cursor are rapidly braked (anti-velocity) while mouse is down.
  @returns {Vector}
*/
if (!mouse.down) return new Vector();
const mp = new Vector(mouse.pos.x, mouse.pos.y); const dist = Vector.dist(boid.pos, mp);
if (dist > 120) return new Vector();
const brake = boid.vel.clone().mult(-1.0);
return brake.limit(boid.maxForce * 2.0);` },

          { id: 'click-speed-boost', name: 'Click — Speed Boost', code: `/**
  Speed Boost
  Boids near the cursor get a forward push along their heading.
  @returns {Vector}
*/
if (!mouse.down) return new Vector();
const mp = new Vector(mouse.pos.x, mouse.pos.y); const dist = Vector.dist(boid.pos, mp);
if (dist > 140) return new Vector();
const boost = boid.vel.clone().normalize().mult(boid.maxSpeed * 0.9);
return Vector.sub(boost, boid.vel).limit(boid.maxForce * 1.8);` },

          { id: 'drag-wind-gust', name: 'Drag — Wind Gust', code: `/**
  Wind Gust
  While dragging, apply a directional wind along mouse velocity, stronger near the cursor.
  @returns {Vector}
*/
if (!mouse.down) return new Vector();
const w = new Vector(mouse.vel.x || 0, mouse.vel.y || 0);
if (w.mag() < 0.1) return new Vector();
const mp = new Vector(mouse.pos.x, mouse.pos.y);
const d = Math.max(1, Vector.dist(boid.pos, mp));
const desired = w.normalize().mult(boid.maxSpeed * Math.min(1.2, 180 / d));
// Visual
if (typeof api !== 'undefined' && api && api.addDrawable) { const x=mp.x,y=mp.y, L=24; const mag=Math.max(1e-6, desired.mag()); const ux=desired.x/mag*L, uy=desired.y/mag*L; api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+ux,y+uy); ctx.strokeStyle='hsla(' + (config.hue) + ',100%,70%,0.16)'; ctx.lineWidth=2; ctx.stroke(); }); }
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 2.2);` },

          { id: 'drag-barrier-repel', name: 'Drag — Barrier Repel', code: `/**
  Barrier Repel
  Treat the short segment from previous to current mouse position as a barrier; boids near it are repelled.
  @returns {Vector}
*/
if (!mouse.down) return new Vector();
const ax = mouse.prev.x, ay = mouse.prev.y, bx = mouse.pos.x, by = mouse.pos.y;
const abx = bx - ax, aby = by - ay; const ab2 = abx*abx + aby*aby;
if (ab2 < 25) return new Vector();
// Project boid onto segment
const apx = boid.pos.x - ax, apy = boid.pos.y - ay;
let t = (apx*abx + apy*aby) / ab2; t = Math.max(0, Math.min(1, t));
const cx = ax + abx * t, cy = ay + aby * t;
const dx = boid.pos.x - cx, dy = boid.pos.y - cy; const dist2 = dx*dx + dy*dy;
if (dist2 > 900) return new Vector();
const n = new Vector(dx, dy).normalize();
const desired = n.mult(boid.maxSpeed * Math.min(1.5, 300 / Math.sqrt(dist2 + 1)));
// Visual
if (typeof api !== 'undefined' && api && api.addDrawable) { const x1=ax,y1=ay,x2=bx,y2=by; api.addDrawable((ctx)=>{ ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.strokeStyle='hsla(' + (config.hue) + ',100%,60%,0.15)'; ctx.lineWidth=2; ctx.stroke(); }); }
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 2.0);` },

          { id: 'drag-line-tractor', name: 'Drag — Line Tractor', code: `/**
  Line Tractor
  Attract boids toward the dragged segment (previous → current mouse pos); stronger when closer.
  @returns {Vector}
*/
if (!mouse.down) return new Vector();
const ax = mouse.prev.x, ay = mouse.prev.y, bx = mouse.pos.x, by = mouse.pos.y;
const abx = bx - ax, aby = by - ay; const ab2 = abx*abx + aby*aby;
if (ab2 < 25) return new Vector();
const apx = boid.pos.x - ax, apy = boid.pos.y - ay; let t = (apx*abx + apy*aby)/ab2; t = Math.max(0, Math.min(1, t));
const cx = ax + abx*t, cy = ay + aby*t;
const toLine = new Vector(cx - boid.pos.x, cy - boid.pos.y); const d = Math.max(1, toLine.mag());
const desired = toLine.normalize().mult(boid.maxSpeed * Math.min(1.5, 240 / d));
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 2.0);` },

          { id: 'drag-shear-field', name: 'Drag — Shear Field', code: `/**
  Shear Field
  While dragging, push boids perpendicular to mouse velocity, scaled by distance from the cursor line.
  @returns {Vector}
*/
if (!mouse.down) return new Vector();
const v = new Vector(mouse.vel.x || 0, mouse.vel.y || 0); if (v.mag() < 0.1) return new Vector();
const tangent = v.clone().normalize(); const normal = new Vector(-tangent.y, tangent.x);
const mp = new Vector(mouse.pos.x, mouse.pos.y);
const rel = Vector.sub(boid.pos, mp);
const side = Math.sign(rel.x*normal.x + rel.y*normal.y) || 1;
const dist = Math.abs(rel.x*normal.x + rel.y*normal.y);
const desired = normal.mult(side * boid.maxSpeed * Math.min(1.2, 180 / Math.max(20, dist)));
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 2.0);` },

          { id: 'click-implosion', name: 'Click — Implosion', code: `/**
  Implosion
  Strong inward pull near the cursor; very high near-field intensity.
  @returns {Vector}
*/
if (!mouse.down) return new Vector();
const mp = new Vector(mouse.pos.x, mouse.pos.y);
const toM = Vector.sub(mp, boid.pos); const d = Math.max(1, toM.mag());
const desired = toM.normalize().mult(boid.maxSpeed * Math.min(2.4, 240 / d));
return Vector.sub(desired, boid.vel).limit(boid.maxForce * 3.0);` },
        ];

        // --- INITIALIZATION ---
        
        function init() {
            setupCanvas();
            const urlParams = getURLParams();
            config = {
                hue: 200, boidCount: 200, maxSpeed: 3, maxForce: 0.2,
                perceptionRadius: 50, visualizeQuadtree: true, debug: false,
                cohesionWeight: 1.0, separationWeight: 1.5, alignmentWeight: 1.0, novelWeight: 1.2,
                visualDensity: 1.0,
                boidShape: 'triangle', boidSize: 10, boidSizeVariance: 2,
                header: "Boids Simulation", subheader: "Click and drag to interact",
                codePaneDock: 'bottom', // bottom | left | max
                codePaneLeftWidth: null,
                splitLeftRule: 'cohesion',
                splitRightRule: 'separation',
                // Preset controls — persisted via URL
                presetIncludeCore: true,
                presetCount: 4,
                ...urlParams
            };
            logConfig('Initial config:', config);
            userFunctions.push(
                { name: 'cohesion', weight: config.cohesionWeight, updateBoid: null },
                { name: 'separation', weight: config.separationWeight, updateBoid: null },
                { name: 'alignment', weight: config.alignmentWeight, updateBoid: null },
                { name: 'novel', weight: config.novelWeight, updateBoid: null }
            );
            setupUI();
            setupCodePane();
            // If requested via URL, load random presets at startup
            if (typeof urlParams !== 'undefined' && urlParams) {
                const rp = urlParams.randomPresets;
                if (rp !== undefined && rp !== false && rp !== 'false') {
                    let n = 4;
                    if (typeof rp === 'number') {
                        n = Math.max(1, Math.min(rulePresets.length, rp));
                    } else if (typeof urlParams.presetCount === 'number') {
                        n = Math.max(1, Math.min(rulePresets.length, urlParams.presetCount));
                    }
                    resetRulesWithPresets(n, !!config.presetIncludeCore);
                }
            }
            applyDockMode(config.codePaneDock);
            createBoids();
            window.addEventListener('resize', debounce(setupCanvas, 250));
            canvas.addEventListener('mousemove', e => {
                const px = mouse.pos.x, py = mouse.pos.y;
                mouse.prev.x = px; mouse.prev.y = py;
                mouse.pos.x = e.clientX; mouse.pos.y = e.clientY;
                // Simple smoothing on mouse velocity
                mouse.vel.x = (mouse.pos.x - px) * 0.6 + mouse.vel.x * 0.4;
                mouse.vel.y = (mouse.pos.y - py) * 0.6 + mouse.vel.y * 0.4;
            });
            canvas.addEventListener('mousedown', e => { mouse.down = true; });
            canvas.addEventListener('mouseup', e => { mouse.down = false; });
            canvas.addEventListener('touchstart', e => { mouse.down = true; updateTouchPos(e); }, {passive: false});
            canvas.addEventListener('touchend', e => { mouse.down = false; });
            canvas.addEventListener('touchmove', e => { e.preventDefault();
                const oldx = mouse.pos.x, oldy = mouse.pos.y;
                updateTouchPos(e);
                mouse.prev.x = oldx; mouse.prev.y = oldy;
                mouse.vel.x = (mouse.pos.x - oldx) * 0.6 + mouse.vel.x * 0.4;
                mouse.vel.y = (mouse.pos.y - oldy) * 0.6 + mouse.vel.y * 0.4;
            }, {passive: false});
            lastTime = performance.now();
            animate();
        }

        function updateTouchPos(e) {
            if (e.touches && e.touches.length > 0) {
                mouse.pos.x = e.touches[0].clientX;
                mouse.pos.y = e.touches[0].clientY;
            }
        }

        function setupCanvas() {
            gameState.width = canvas.width = window.innerWidth;
            gameState.height = canvas.height = window.innerHeight;
            // Pheromone grid sizing
            pheromones.cols = Math.max(1, Math.ceil(gameState.width / pheromones.cell));
            pheromones.rows = Math.max(1, Math.ceil(gameState.height / pheromones.cell));
            pheromones.grid = new Float32Array(pheromones.cols * pheromones.rows);
            if (gameState.boids.length > 0) createBoids();
        }

        // --- UI SETUP ---
        function setupUI() {
            document.documentElement.style.setProperty('--hue', config.hue);
            document.querySelectorAll('.overlay-toggle').forEach(button => {
                button.addEventListener('click', () => {
                    const id = button.dataset.overlay;
                    const targetOverlay = id ? document.getElementById(id) : null;
                    if (!targetOverlay) return;
                    const isVisible = targetOverlay.classList.contains('visible');
                    document.querySelectorAll('.overlay').forEach(o => o.classList.remove('visible'));
                    if (!isVisible) targetOverlay.classList.add('visible');
                });
            });
            // Reset button
            const resetBtn = document.getElementById('reset-button');
            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
                    hardReset();
                });
            }
            document.querySelectorAll('.overlay').forEach(overlay => {
                const closeBtn = document.createElement('button');
                closeBtn.className = 'close-button';
                closeBtn.innerHTML = '&times;';
                closeBtn.onclick = () => overlay.classList.remove('visible');
                overlay.prepend(closeBtn);
            });
            const codePane = document.getElementById('code-pane');
            document.querySelector('.code-pane-toggle').addEventListener('click', (e) => {
                // Ignore clicks on dock control buttons inside the header
                if (e.target && e.target.classList.contains('dock-btn')) return;
                codePane.classList.toggle('visible');
                updateCodeOverlayButton();
                refreshEditors();
            });
            // Dock controls + split toggle
            document.querySelectorAll('.dock-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const action = e.currentTarget.getAttribute('data-action');
                    if (action === 'toggle-split') {
                        config.splitEnabled = !config.splitEnabled;
                        updateSplitModeUI();
                        if (!config.debug) updateURL('splitEnabled', !!config.splitEnabled);
                        return;
                    }
                    const mode = e.currentTarget.getAttribute('data-dock');
                    if (!mode) return;
                    config.codePaneDock = mode === 'max' ? 'max' : (mode === 'left' ? 'left' : 'bottom');
                    applyDockMode(config.codePaneDock);
                    if (config.debug) updateAllURLParams(); else updateURL('codePaneDock', config.codePaneDock);
                });
            });
            updateCodeOverlayButton();
            setupConfigUI();
            setupStatsUI();
            setupHelpUI();
            setupInfoUI();
        }

        function applyDockMode(mode) {
            const pane = document.getElementById('code-pane');
            pane.classList.remove('dock-bottom', 'dock-left', 'maximized');
            document.querySelectorAll('.dock-btn').forEach(b => b.classList.remove('active'));
            if (mode === 'left') {
                pane.classList.add('dock-left');
                document.querySelector('.dock-btn[data-dock="left"]').classList.add('active');
                if (config.codePaneLeftWidth && Number.isFinite(+config.codePaneLeftWidth)) {
                    pane.style.width = parseInt(config.codePaneLeftWidth, 10) + 'px';
                } else {
                    pane.style.width = '';
                }
                document.body.classList.remove('code-pane-maximized');
                updateSplitModeUI();
            } else if (mode === 'max' || mode === 'maximized') {
                pane.classList.add('maximized', 'visible');
                document.querySelector('.dock-btn[data-dock="max"]').classList.add('active');
                document.body.classList.add('code-pane-maximized');
                updateSplitModeUI();
            } else {
                pane.classList.add('dock-bottom');
                document.querySelector('.dock-btn[data-dock="bottom"]').classList.add('active');
                document.body.classList.remove('code-pane-maximized');
                updateSplitModeUI();
            }
            updateCodeOverlayButton();
            // Keep collapsed state meaningful for bottom/left
            refreshEditors();
        }

        function updateSplitModeUI() {
            const pane = document.getElementById('code-pane');
            const splitBtn = document.querySelector('.dock-btn[data-action="toggle-split"]');
            const maximized = pane.classList.contains('maximized');
            const enabled = !!config.splitEnabled && maximized;
            pane.classList.toggle('split-on', enabled);
            if (splitBtn) splitBtn.classList.toggle('active', enabled);
            if (setupCodePane._split) {
                if (enabled) {
                    setupCodePane._split.showSplitUI(true);
                    setupCodePane._split.updateSplitMounts();
                } else {
                    setupCodePane._split.showSplitUI(false);
                    setupCodePane._split.unmountAll();
                }
            }
            refreshEditors();
        }

        function updateCodeOverlayButton() {
            const container = document.querySelector('.overlay-toggle-container');
            const pane = document.getElementById('code-pane');
            if (!container || !pane) return;
            const existing = document.getElementById('overlay-code-button');
            const isMax = document.body.classList.contains('code-pane-maximized');
            const needs = pane.classList.contains('dock-left') && !pane.classList.contains('visible') && !isMax;
            if (needs) {
                if (!existing) {
                    const btn = document.createElement('button');
                    btn.id = 'overlay-code-button';
                    btn.className = 'overlay-toggle';
                    btn.textContent = 'Code';
                    btn.title = 'Show code pane';
                    // Start in entering state for fade/slide in
                    btn.classList.add('entering');
                    btn.addEventListener('click', () => {
                        pane.classList.add('visible');
                        updateCodeOverlayButton();
                        refreshEditors();
                    });
                    container.prepend(btn);
                    // Trigger transition on next frame
                    requestAnimationFrame(() => requestAnimationFrame(() => btn.classList.remove('entering')));
                }
            } else if (existing) {
                // If overlays are visible, animate out. If maximized (container hidden), remove immediately.
                if (!document.body.classList.contains('code-pane-maximized')) {
                    if (!existing.dataset.removing) {
                        existing.dataset.removing = '1';
                        existing.classList.add('leaving');
                        const cleanup = () => {
                            existing.removeEventListener('transitionend', cleanup);
                            if (existing && existing.parentNode) existing.parentNode.removeChild(existing);
                        };
                        existing.addEventListener('transitionend', cleanup);
                        // Fallback removal in case transitionend doesn't fire
                        setTimeout(() => cleanup(), 300);
                    }
                } else {
                    existing.remove();
                }
            }
        }

        function refreshEditors() {
            Object.values(editors).forEach(editor => editor.refresh());
        }

        // Throttled UI indicator for rule fallback activity
        let _ruleStatusUITs = 0;
        function updateRuleStatusUI(force = false) {
            const now = performance.now();
            if (!force && now - _ruleStatusUITs < 200) return;
            _ruleStatusUITs = now;
            userFunctions.forEach(fn => {
                const active = !!(fn._fallbackUntil && now < fn._fallbackUntil);
                const tab = document.querySelector(`.tab-button[data-tab="${fn.name}"]`);
                if (tab) {
                    tab.classList.toggle('fallback-active', active);
                    if (active) {
                        tab.dataset.tip = `Fallback active for ${fn.name}`;
                    } else {
                        delete tab.dataset.tip;
                    }
                }
            });
        }

        function setupConfigUI() {
            const container = document.getElementById('config-overlay');
            container.innerHTML = '<h2>Configuration</h2>';
            const closeBtn = document.createElement('button');
            closeBtn.className = 'close-button';
            closeBtn.innerHTML = '&times;';
            closeBtn.onclick = () => container.classList.remove('visible');
            container.prepend(closeBtn);
            
            const createSlider = (id, label, min, max, step, value) => {
                const item = document.createElement('div');
                item.className = 'config-item';
                const valueSpan = document.createElement('span');
                valueSpan.textContent = ` ${Number(value).toFixed(2)}`;
                item.innerHTML = `<label for="${id}">${label}</label>`;
                const input = document.createElement('input');
                input.type = 'range'; input.id = id; input.min = min; input.max = max; input.step = step; input.value = value;
                input.addEventListener('input', e => {
                    const newValue = parseFloat(e.target.value);
                    config[id] = newValue;
                    valueSpan.textContent = ` ${newValue.toFixed(2)}`;
                    if (id.endsWith('Weight')) {
                        const fn = userFunctions.find(f => f.name === id.replace('Weight', ''));
                        if(fn) fn.weight = newValue;
                    }
                    if (config.debug) updateAllURLParams();
                });
                input.addEventListener('change', e => {
                    if (!config.debug) updateURL(id, parseFloat(e.target.value));
                    if (id === 'boidSize' || id === 'boidSizeVariance' || id === 'boidCount') {
                        createBoids();
                    }
                });
                item.appendChild(input);
                item.querySelector('label').appendChild(valueSpan);
                container.appendChild(item);
            };

            const createSelect = (id, label, options, value) => {
                const item = document.createElement('div');
                item.className = 'config-item';
                item.innerHTML = `<label for="${id}">${label}</label>`;
                const select = document.createElement('select');
                select.id = id;
                options.forEach(opt => {
                    const option = document.createElement('option');
                    option.value = opt;
                    option.textContent = opt.charAt(0).toUpperCase() + opt.slice(1);
                    if (opt === value) option.selected = true;
                    select.appendChild(option);
                });
                select.addEventListener('change', e => {
                    config[id] = e.target.value;
                    if (config.debug) updateAllURLParams(); else updateURL(id, e.target.value);
                });
                item.appendChild(select);
                container.appendChild(item);
            };

            createSlider('boidCount', 'Boid Count', 10, 1000, 10, config.boidCount);
            createSlider('boidSize', 'Boid Size', 2, 20, 1, config.boidSize);
            createSlider('boidSizeVariance', 'Size Variance', 0, 10, 0.5, config.boidSizeVariance);
            createSelect('boidShape', 'Boid Shape', ['triangle', 'circle', 'oval', 'ring'], config.boidShape);
            createSlider('maxSpeed', 'Max Speed', 0.5, 10, 0.1, config.maxSpeed);
            createSlider('maxForce', 'Max Force', 0.01, 1, 0.01, config.maxForce);
            createSlider('perceptionRadius', 'Perception', 10, 200, 1, config.perceptionRadius);
            createSlider('visualDensity', 'Visual Density', 0, 2, 0.05, config.visualDensity);
            
            userFunctions.forEach(fn => {
                 createSlider(`${fn.name}Weight`, `${fn.name.charAt(0).toUpperCase() + fn.name.slice(1)} Weight`, 0, 5, 0.1, config[`${fn.name}Weight`]);
            });

            // Rule Presets batch reset
            const presetsBox = document.createElement('div');
            presetsBox.className = 'config-item';
            presetsBox.innerHTML = `
                <h3>Rule Presets</h3>
                <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;">
                    <label>Count
                        <input type="number" id="preset-count" min="1" max="${Math.max(4, rulePresets.length)}" value="${(config.presetCount ?? 4)}"
                            style="width:72px;background:#333;color:#fff;border:1px solid #555;border-radius:4px;padding:4px 6px;">
                    </label>
                    <label><input type="checkbox" id="preset-include-core" ${config.presetIncludeCore ? 'checked' : ''}> Include core rules</label>
                    <button id="preset-reset-btn" style="background: var(--primary-color); color: #fff; border: none; padding: 6px 10px; border-radius: 4px; cursor: pointer; font-family: var(--font-mono);">Reset with Presets</button>
                </div>
            `;
            container.appendChild(presetsBox);
            const presetBtn = presetsBox.querySelector('#preset-reset-btn');
            presetBtn.addEventListener('click', () => {
                const countEl = presetsBox.querySelector('#preset-count');
                const includeCoreEl = presetsBox.querySelector('#preset-include-core');
                const n = Math.max(1, Math.min(rulePresets.length, parseInt(countEl.value || '1', 10)));
                const includeCore = !!includeCoreEl.checked;
                // Mirror Count into URL immediately on reset click
                config.presetCount = n;
                if (config.debug) updateAllURLParams(); else updateURL('presetCount', config.presetCount);
                resetRulesWithPresets(n, includeCore);
            });
            // Persist "Include core rules" toggle in URL
            const includeCoreEl = presetsBox.querySelector('#preset-include-core');
            if (includeCoreEl) {
                includeCoreEl.checked = !!config.presetIncludeCore;
                includeCoreEl.addEventListener('change', e => {
                    config.presetIncludeCore = !!e.target.checked;
                    if (config.debug) updateAllURLParams(); else updateURL('presetIncludeCore', config.presetIncludeCore);
                });
            }
            // Persist preset count to URL
            const countEl = presetsBox.querySelector('#preset-count');
            if (countEl) {
                countEl.value = String(config.presetCount ?? 4);
                countEl.addEventListener('change', e => {
                    const val = parseInt(e.target.value || '4', 10);
                    const n = Math.max(1, Math.min(rulePresets.length, isNaN(val) ? 4 : val));
                    config.presetCount = n;
                    if (config.debug) updateAllURLParams(); else updateURL('presetCount', config.presetCount);
                });
            }
            
            const createToggle = (id, label, value) => {
                const item = document.createElement('div');
                item.innerHTML = `<label class="config-item"><input type="checkbox" id="${id}" ${value ? 'checked' : ''}> ${label}</label>`;
                item.querySelector('input').addEventListener('change', e => {
                    config[id] = e.target.checked;
                    logConfig(`${id} changed to ${config[id]}`);
                    if (config.debug) updateAllURLParams(); else updateURL(id, config[id]);
                });
                container.appendChild(item);
            };
            createToggle('visualizeQuadtree', 'Show Quadtree', config.visualizeQuadtree);
            createToggle('debug', 'Debug Mode', config.debug);

            const colorItem = document.createElement('div');
            colorItem.className = 'config-item';
            colorItem.innerHTML = `<label for="hue">Theme Hue</label><input type="color" id="hue-picker" value="${hslToHex(config.hue, 100, 50)}">`;
            colorItem.querySelector('#hue-picker').addEventListener('input', e => {
                const hsl = hexToHsl(e.target.value);
                config.hue = hsl[0];
                document.documentElement.style.setProperty('--hue', config.hue);
                if (config.debug) updateAllURLParams(); else updateURL('hue', config.hue);
            });
            container.appendChild(colorItem);
        }
        
        function setupStatsUI() {
            const container = document.getElementById('stats-overlay');
            container.innerHTML = `
                <button class="close-button">&times;</button>
                <h2>Statistics</h2>
                <p>Particle Count: <span id="particle-count">0</span></p>
                <p>FPS: <span id="fps-counter">0</span></p>
                <div><canvas id="fps-chart" height="80"></canvas></div>
                <p>Update Time: <span id="update-time">0.00</span> ms</p>
                <p>(Mean: <span id="update-time-mean">0.00</span>, StdDev: <span id="update-time-stddev">0.00</span>)</p>
                <div><canvas id="update-time-chart" height="80"></canvas></div>
                <p>Drawables/Frame: <span id="drawables-count">0</span></p>
                <div><canvas id="drawables-chart" height="80"></canvas></div>
                <h3>Flock Coherence</h3>
                <div class="chart-container"><canvas id="polar-spiral-chart"></canvas></div>
                <h3>Mean Direction</h3>
                <div class="chart-container">
                    <canvas id="mean-polar-chart"></canvas>
                    <div class="chart-toggle">
                        <label><input type="checkbox" id="show-stdev-bands" checked>Show StdDev Bands</label>
                    </div>
                </div>
            `;
            container.querySelector('.close-button').onclick = () => container.classList.remove('visible');
            
            charts.fpsChart = new Chart(document.getElementById('fps-chart').getContext('2d'), {
                type: 'line',
                data: { labels: Array(50).fill(''), datasets: [{ label: 'FPS', data: Array(50).fill(0), borderColor: `hsl(${config.hue}, 100%, 50%)`, borderWidth: 1, pointRadius: 0, tension: 0.4 }] },
                options: { scales: { y: { beginAtZero: true, max: 70 } } }
            });

            charts.updateTimeChart = new Chart(document.getElementById('update-time-chart').getContext('2d'), {
                type: 'line',
                data: { labels: Array(50).fill(''), datasets: [{ label: 'Update Time (ms)', data: Array(50).fill(0), borderColor: `hsl(${(config.hue + 120) % 360}, 100%, 50%)`, borderWidth: 1, pointRadius: 0, tension: 0.4 }] },
                options: { scales: { y: { beginAtZero: true } } }
            });

            charts.drawablesChart = new Chart(document.getElementById('drawables-chart').getContext('2d'), {
                type: 'line',
                data: { labels: Array(50).fill(''), datasets: [{ label: 'Drawables / Frame', data: Array(50).fill(0), borderColor: `hsl(${(config.hue + 240) % 360}, 100%, 50%)`, borderWidth: 1, pointRadius: 0, tension: 0.4 }] },
                options: { scales: { y: { beginAtZero: true } } }
            });

            charts.polarCtx = document.getElementById('polar-spiral-chart').getContext('2d');
            charts.meanPolarCtx = document.getElementById('mean-polar-chart').getContext('2d');
            charts.showStdDevBands = document.getElementById('show-stdev-bands');
        }
        
        function setupHelpUI() {
            const container = document.getElementById('help-overlay');
            const urlBase = window.location.pathname;
            container.innerHTML = `
                <button class="close-button">&times;</button>
                <h2>Boids Simulation</h2>
                <p>This is an interactive simulation of flocking behavior, inspired by Craig Reynolds' Boids algorithm.</p>
                <h3>URL Parameters</h3>
                <p>Most settings persist via the URL. Values are JSON-parsed, so booleans and numbers work as expected.</p>
                <ul>
                    <li><code>hue</code>: number (theme hue)</li>
                    <li><code>boidCount</code>, <code>boidSize</code>, <code>boidSizeVariance</code>, <code>boidShape</code> (triangle|circle|oval|ring)</li>
                    <li><code>maxSpeed</code>, <code>maxForce</code>, <code>perceptionRadius</code>, <code>visualDensity</code></li>
                    <li><code>cohesionWeight</code>, <code>separationWeight</code>, <code>alignmentWeight</code>, <code>novelWeight</code></li>
                    <li><code>visualizeQuadtree</code>: boolean, <code>debug</code>: boolean</li>
                    <li><code>codePaneDock</code>: bottom|left|max, <code>codePaneLeftWidth</code>: number</li>
                    <li><code>splitLeftRule</code>, <code>splitRightRule</code>: rule IDs</li>
                    <li><code>presetIncludeCore</code>: boolean — include core rules in batch</li>
                    <li><code>presetCount</code>: number — default count for batch presets</li>
                    <li><code>randomPresets</code>: boolean|number — when true/number, loads random presets on start; number picks that many</li>
                </ul>
                <h4>Examples</h4>
                <ul>
                    <li><code>${urlBase}?presetIncludeCore=false&amp;randomPresets=true</code></li>
                    <li><code>${urlBase}?presetIncludeCore=true&amp;presetCount=6&amp;randomPresets=6</code></li>
                    <li><code>${urlBase}?debug=true&amp;hue=320&amp;boidCount=300</code></li>
                </ul>
                <h3>Change Log</h3>
                <p>
                    v1.7 - Added visual success/error indicators for live code reloading.<br>
                    v1.6 - Added boid shape/size configs and monospace font styling.<br>
                    v1.5 - Added beautiful mean direction polar chart with togglable stdev bands.<br>
                    v1.4 - Added close buttons and expanded statistics panel.<br>
                    v1.3 - Fixed critical scope error for dynamic code.<br>
                    v1.2 - Added dynamic polar spiral graph for flock coherence.<br>
                    v1.1 - Fixed critical errors related to dynamic function creation.<br>
                    v1.0 - Initial implementation.
                </p>`;
            container.querySelector('.close-button').onclick = () => container.classList.remove('visible');
        }

        function setupInfoUI() {
            const container = document.getElementById('info-overlay');
            if (!container) return;
            container.innerHTML = '<button class="close-button">&times;</button>' +
              '<h2>Technical Info</h2>' +
              '<h3>Rule Function Signature</h3>' +
              '<pre style="white-space:pre-wrap;font-size:12px;line-height:1.4">' +
              'function rule(boid, gameState, neighbors, config, mouse, Vector, api) {\n' +
              '  // Return a Vector steering force.\n' +
              '  // Optionally draw visuals via api.addDrawable() or deposit trails via api.depositTrail().\n' +
              '  return new Vector(0,0);\n' +
              '}' +
              '</pre>' +
              '<h3>Rule API</h3>' +
              '<ul>' +
              '<li><code>api.addDrawable((ctx, gameState) =&gt; {...})</code>: enqueue a canvas draw for this frame.</li>' +
              '<li><code>api.depositTrail(x, y, amount=1)</code>: add to pheromone grid (fading heatmap).</li>' +
              '</ul>' +
              '<h3>Render Pipeline (per frame)</h3>' +
              '<ol>' +
              '<li>update(): build quadtree, decay pheromones, run rules (which can register drawables).</li>' +
              '<li>draw(): background, pheromone heatmap, quadtree (optional), boids, custom drawables, HUD.</li>' +
              '</ol>' +
              '<h3>Visual Density</h3>' +
              '<p><code>config.visualDensity</code> in [0,2]: if &lt;1, visuals are probabilistically thinned; if &gt;1, some visuals are duplicated to increase density.</p>' +
              '<h3>Performance Notes</h3>' +
              '<ul><li>Prefer simple strokes/fills; avoid large loops in each drawable.</li>' +
              '<li>Use density slider for heavy visuals; avoid synchronous layout reads in drawables.</li>' +
              '</ul>' +
              '<h3>Coordinate System</h3>' +
              '<p>Origin at top-left; +x to right, +y down. Boids wrap at edges.</p>';
            container.querySelector('.close-button').onclick = () => container.classList.remove('visible');
        }

        function setupCodePane() {
            const tabs = document.querySelectorAll('.tab-button');
            const contents = document.querySelectorAll('.tab-content');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.forEach(t => t.classList.remove('active'));
                    contents.forEach(c => c.classList.remove('active'));
                    tab.classList.add('active');
                    document.getElementById(tab.dataset.tab).classList.add('active');
                    editors[tab.dataset.tab].refresh();
                });
            });

            // Provide lightweight autocompletion with in-scope symbols and common vectors
            function ruleHint(editor) {
                const cur = editor.getCursor();
                const token = editor.getTokenAt(cur);
                const start = token.start;
                const end = cur.ch;
                const word = token.string.trim();
                const from = CodeMirror.Pos(cur.line, start);
                const to = CodeMirror.Pos(cur.line, end);
                const line = editor.getLine(cur.line);
                const before = line.slice(0, cur.ch);
                const isConfigCtx = /(^|\W)config\.$/.test(before);
                const configKeys = Object.keys(config || {}).map(k => `config.${k}`);
                const base = [
                    'boid', 'boid.pos', 'boid.vel', 'boid.acc', 'boid.maxSpeed', 'boid.maxForce', 'boid.size', 'boid.hue',
                    'gameState', 'gameState.width', 'gameState.height', 'gameState.boids', 'neighbors',
                    'config',
                    'mouse', 'mouse.pos.x', 'mouse.pos.y', 'mouse.down',
                    'Vector', 'Vector.sub', 'Vector.dist', 'Vector.random2D',
                    'api', 'api.depositTrail', 'api.addDrawable',
                    'add()', 'sub()', 'mult()', 'div()', 'mag()', 'normalize()', 'limit()', 'heading()', 'clone()',
                    'return new Vector(0, 0)', 'const v = new Vector(0, 0)'
                ];
                const pool = isConfigCtx ? configKeys : base.concat(configKeys);
                // Deduplicate and filter by current token
                const seen = new Set();
                const list = pool.filter(s => {
                    const key = s.toLowerCase();
                    if (seen.has(key)) return false;
                    seen.add(key);
                    return !word || key.startsWith(word.toLowerCase());
                });
                return { list, from, to };
            }

            const originalParents = {};

            for (const fn of userFunctions) {
                const content = document.getElementById(fn.name);
                // Build per-editor toolbar
                const bar = buildEditorBar(fn.name);
                content.prepend(bar);
                const textarea = content.querySelector('textarea');
                textarea.value = defaultFunctionsCode[fn.name];
                editors[fn.name] = CodeMirror.fromTextArea(textarea, {
                    mode: 'javascript', theme: 'dracula', lineNumbers: true,
                    lint: true, gutters: ["CodeMirror-lint-markers"],
                    extraKeys: { 'Ctrl-Space': 'autocomplete' },
                    hintOptions: { hint: ruleHint, completeSingle: false }
                });
                // Store original parent (code-pane) for returning when exiting split
                originalParents[fn.name] = document.getElementById(fn.name).parentElement;

                // Live-compile user rule code into a function with a narrow, explicit scope.
                // Scope parameters available inside the editor code:
                //   boid (Boid), gameState ({boids, quadtree, width, height}), neighbors (Boid[]),
                //   config (object), mouse ({pos, down}), Vector (math helper)
                const updateFunction = debounce((editor) => {
                    const tabButton = document.querySelector(`.tab-button[data-tab="${fn.name}"]`);
                    try {
                        const code = editor.getValue();
                        const params = ['boid', 'gameState', 'neighbors', 'config', 'mouse', 'Vector', 'api'];
                        const dynamicFunc = new Function(...params, code);
                        const prev = fn.updateBoid;

                        // Dry-run with a tiny mock to validate (no side effects expected)
                        const mockBoid = new Boid(0, 0);
                        const mockState = { boids: [mockBoid], quadtree: null, width: 10, height: 10 };
                        const mockNeighbors = [];
                        let ok = true;
                        try {
                            const res = dynamicFunc(mockBoid, mockState, mockNeighbors, config, mouse, Vector, RuleAPI);
                            // Must be Vector or falsy; non-Vector returns are tolerated as no-op
                            if (res && !(res instanceof Vector)) ok = false;
                        } catch (e) {
                            ok = false;
                        }
                        if (!ok) throw new Error('Rule dry-run failed');

                        // Adopt the new function, wrapped with runtime safety
                        fn.updateBoid = (boid, gameState, neighbors) => {
                            try {
                                const out = dynamicFunc(boid, gameState, neighbors, config, mouse, Vector, RuleAPI);
                                return out instanceof Vector ? out : new Vector();
                            } catch (e) {
                                const now = performance.now();
                                if (!fn._lastRuntimeErrorTs || (now - fn._lastRuntimeErrorTs) > 1000) {
                                    console.error(`Runtime error in rule '${fn.name}':`, e);
                                    fn._lastRuntimeErrorTs = now;
                                }
                                // Mark fallback active for a short window and update UI (throttled)
                                fn._fallbackUntil = now + 2000;
                                updateRuleStatusUI();
                                return new Vector();
                            }
                        };

                        console.log(`Rule '${fn.name}' reloaded successfully.`);
                        logConfig(`Rule '${fn.name}' reloaded successfully.`);
                        if (tabButton) {
                           tabButton.classList.add('reloaded-success');
                           setTimeout(() => tabButton.classList.remove('reloaded-success'), 600);
                        }
                    } catch (e) {
                        console.error(`Error reloading rule '${fn.name}':`, e);
                        // Keep previous good function if any; else use no-op
                        fn.updateBoid = typeof fn.updateBoid === 'function' ? fn.updateBoid : () => new Vector();
                        // Also mark fallback indicator briefly to signal error state
                        fn._fallbackUntil = performance.now() + 2000;
                        updateRuleStatusUI();
                        if (tabButton) {
                           tabButton.classList.add('reloaded-error');
                           setTimeout(() => tabButton.classList.remove('reloaded-error'), 600);
                        }
                    }
                }, 500);
                editors[fn.name].on('change', updateFunction);
                // Show autocomplete as you type for convenience
                editors[fn.name].on('inputRead', (cm, change) => {
                    if (!change.text) return;
                    const ch = change.text.join('');
                    if (/^[\w\.$]$/.test(ch)) {
                        cm.showHint({ hint: ruleHint, completeSingle: false });
                    }
                });
                updateFunction(editors[fn.name]); // Initial compilation
            }

            // Split view setup
            const leftSel = document.getElementById('split-left');
            const rightSel = document.getElementById('split-right');
            const splitView = document.getElementById('split-view');
            const splitSash = splitView ? splitView.querySelector('.split-sash') : null;
            const slots = {
                left: document.querySelector('.split-pane[data-slot="left"]'),
                right: document.querySelector('.split-pane[data-slot="right"]'),
            };
            const mounted = {}; // rule -> slot name

            function populateSelects() {
                [leftSel, rightSel].forEach(sel => { sel.innerHTML = ''; });
                userFunctions.forEach(fn => {
                    const optL = document.createElement('option'); optL.value = fn.name; optL.textContent = fn.name;
                    const optR = document.createElement('option'); optR.value = fn.name; optR.textContent = fn.name;
                    leftSel.appendChild(optL); rightSel.appendChild(optR);
                });
            }
            function updateSelectStates() {
                // Ensure distinct selections
                if (leftSel.value === rightSel.value) {
                    const other = userFunctions.find(u => u.name !== leftSel.value);
                    if (other) rightSel.value = other.name;
                }
                // Disable chosen rule in the opposite select
                Array.from(leftSel.options).forEach(o => { o.disabled = (o.value === rightSel.value); });
                Array.from(rightSel.options).forEach(o => { o.disabled = (o.value === leftSel.value); });
            }
            function unmountRule(rule) {
                if (!mounted[rule]) return;
                const content = document.getElementById(rule);
                const parent = originalParents[rule] || document.getElementById('code-pane');
                if (content && parent) { parent.appendChild(content); editors[rule].refresh(); }
                delete mounted[rule];
            }
            function mountRule(rule, slotName) {
                if (!rule || !slots[slotName]) return;
                // If this rule is mounted elsewhere, unmount first
                unmountRule(rule);
                const content = document.getElementById(rule);
                if (content) { slots[slotName].appendChild(content); mounted[rule] = slotName; editors[rule].refresh(); }
            }
            function updateSplitMounts() {
                // Ensure rules are distinct
                updateSelectStates();
                const L = leftSel.value;
                const R = rightSel.value;
                // Unmount any rule not chosen
                Object.keys(mounted).forEach(rule => {
                    if (rule !== L && rule !== R) unmountRule(rule);
                });
                // If a chosen rule is mounted in the wrong place, move it
                if (mounted[L] !== 'left') mountRule(L, 'left');
                if (mounted[R] !== 'right') mountRule(R, 'right');
                applySplitRatio();
                // Ensure both panes are visible (fallback to a different rule if same)
                if (L === R) {
                    const other = userFunctions.find(u => u.name !== L);
                    if (other) { rightSel.value = other.name; mountRule(other.name, 'right'); }
                }
            }
            function showSplitUI(show) {
                const sc = document.getElementById('split-controls');
                const sv = document.getElementById('split-view');
                if (sc) sc.style.display = 'none'; // managed in tabs row now
                if (sv) sv.style.display = show ? 'flex' : 'none';
            }
            function applySplitRatio() {
                if (!slots.left || !slots.right) return;
                const pct = (typeof config.splitLeftPercent === 'number') ? config.splitLeftPercent : 50;
                slots.left.style.flex = `0 0 ${pct}%`;
                slots.right.style.flex = `1 1 auto`;
            }
            // Sash drag to set ratio
            if (splitSash && splitView) {
                let dragging = false;
                const onMove = (evt) => {
                    if (!dragging) return;
                    const x = evt.touches ? evt.touches[0].clientX : evt.clientX;
                    const rect = splitView.getBoundingClientRect();
                    let pct = ((x - rect.left) / rect.width) * 100;
                    pct = Math.max(20, Math.min(80, pct));
                    config.splitLeftPercent = pct;
                    applySplitRatio();
                };
                const onUp = () => {
                    if (!dragging) return;
                    dragging = false;
                    document.removeEventListener('mousemove', onMove);
                    document.removeEventListener('mouseup', onUp);
                    document.removeEventListener('touchmove', onMove);
                    document.removeEventListener('touchend', onUp);
                    if (!config.debug) updateURL('splitLeftPercent', Math.round(config.splitLeftPercent));
                    refreshEditors();
                };
                splitSash.addEventListener('mousedown', () => {
                    dragging = true;
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onUp);
                });
                splitSash.addEventListener('touchstart', () => {
                    dragging = true;
                    document.addEventListener('touchmove', onMove, { passive: false });
                    document.addEventListener('touchend', onUp);
                }, { passive: true });
            }
            // Expose hooks for dock mode changes
            setupCodePane._split = {
                populateSelects, updateSplitMounts, showSplitUI,
                get leftSel() { return leftSel; },
                get rightSel() { return rightSel; },
                unmountAll: () => { Object.keys(mounted).forEach(unmountRule); }
            };
            populateSelects();
            leftSel.value = config.splitLeftRule || 'cohesion';
            rightSel.value = (config.splitRightRule && config.splitRightRule !== leftSel.value)
                ? config.splitRightRule : (userFunctions.find(u => u.name !== leftSel.value) || userFunctions[0]).name;
            updateSelectStates();
            leftSel.addEventListener('change', () => {
                config.splitLeftRule = leftSel.value;
                if (!config.debug) updateURL('splitLeftRule', config.splitLeftRule);
                updateSplitMounts();
            });
            rightSel.addEventListener('change', () => {
                config.splitRightRule = rightSel.value;
                if (!config.debug) updateURL('splitRightRule', config.splitRightRule);
                updateSplitMounts();
            });
            // Per-editor toolbars manage presets and actions
            // Reflect initial split toggle state when first applied to maximized
            updateSplitModeUI();
            // Global new rule button moved to per-editor bars; expose helper if needed
        }

        function buildEditorBar(ruleName) {
            const bar = document.createElement('div'); bar.className = 'editor-bar';
            // Preset select (grouped by category)
            const label = document.createElement('span'); label.style.color = '#ddd'; label.style.fontSize = '12px'; label.textContent = 'Presets (by category)';
            bar.appendChild(label);
            const sel = document.createElement('select'); sel.title = 'Presets (grouped by category)';
            const groups = categorizePresets();
            const order = ['Templates', 'Core', 'Nature', 'AI / ML / CS', 'Physics', 'Math', 'Visual', 'Other'];
            order.forEach(label => {
                if (!groups[label] || groups[label].length === 0) return;
                const og = document.createElement('optgroup'); og.label = label;
                groups[label].forEach((p, idx) => {
                    const o = document.createElement('option'); o.value = p.id; o.textContent = p.name; if (!sel.firstChild && idx === 0) o.selected = true; og.appendChild(o);
                });
                sel.appendChild(og);
            });
            bar.appendChild(sel);
            // Fill button
            const fill = document.createElement('button'); fill.className='bar-btn'; fill.title='Fill with preset'; fill.textContent='Fill';
            fill.addEventListener('click', () => {
                const currentName = bar.closest('.tab-content')?.id;
                const p = rulePresets.find(x => x.id === sel.value) || rulePresets[0];
                if (!currentName || !p) return;
                const ed = editors[currentName]; if (ed) ed.setValue(p.code);
                // Always rename to the preset name for clarity (ensure unique)
                const targetName = sanitizeRuleName(p.name);
                if (currentName !== targetName) {
                    renameRule(currentName, targetName);
                }
            });
            bar.appendChild(fill);
            // Rename button
            const ren = document.createElement('button'); ren.className='bar-btn'; ren.title='Rename rule'; ren.textContent='Rename';
            ren.addEventListener('click', () => {
                const currentName = bar.closest('.tab-content')?.id;
                if (!currentName) return;
                const newName = prompt(`Rename rule '${currentName}' to:`, currentName);
                if (newName && newName !== currentName) renameRule(currentName, newName);
            });
            bar.appendChild(ren);
            // Delete button
            const del = document.createElement('button'); del.className='bar-btn'; del.title='Delete rule'; del.textContent='Delete';
            del.addEventListener('click', () => {
                const currentName = bar.closest('.tab-content')?.id;
                if (!currentName) return;
                if (userFunctions.length <= 1) { alert('At least one rule is required.'); return; }
                if (!confirm(`Delete rule '${currentName}'? This cannot be undone.`)) return;
                deleteRule(currentName);
            });
            bar.appendChild(del);
            // New rule button (local convenience)
            const add = document.createElement('button'); add.className='bar-btn'; add.title='New rule'; add.textContent='New';
            add.addEventListener('click', () => addRule());
            bar.appendChild(add);
            return bar;
        }

        function categorizePresets() {
            const groups = { 'Templates': [], 'Core': [], 'Nature': [], 'AI / ML / CS': [], 'Physics': [], 'Math': [], 'Visual': [], 'Other': [] };
            for (const p of rulePresets) {
                const name = p.name || '';
                if (/^Template\b|^Drawable Template\b/i.test(name)) groups['Templates'].push(p);
                else if (/\(Core\)/i.test(name) || /-core$/.test(p.id)) groups['Core'].push(p);
                else if (/^Nature\b/i.test(name)) groups['Nature'].push(p);
                else if (/^(AI|CS)\b|AI —|AI\s—|AI\s-/i.test(name)) groups['AI / ML / CS'].push(p);
                else if (/^Physics\b/i.test(name)) groups['Physics'].push(p);
                else if (/^Math\b/i.test(name)) groups['Math'].push(p);
                else if (/^Visual\b/i.test(name)) groups['Visual'].push(p);
                else groups['Other'].push(p);
            }
            return groups;
        }

        function sanitizeRuleName(name) {
            let s = String(name).trim();
            s = s.replace(/\s+/g, '-').replace(/[^A-Za-z0-9_-]/g, '').toLowerCase();
            if (!s) s = 'rule';
            let base = s, i = 2;
            while (userFunctions.find(u => u.name === s)) { s = base + '-' + i++; }
            return s;
        }

        function defaultRuleTemplate() {
            // Rotate through presets for variety
            if (typeof config._nextPresetIdx !== 'number') config._nextPresetIdx = 0;
            const preset = rulePresets[config._nextPresetIdx % rulePresets.length];
            config._nextPresetIdx++;
            return preset ? preset.code : `return new Vector();`;
        }

        function addRule(nameRaw) {
            // Choose a preset for the new rule and use its name as the rule name
            if (typeof config._nextPresetIdx !== 'number') config._nextPresetIdx = 0;
            const preset = rulePresets[config._nextPresetIdx % rulePresets.length];
            config._nextPresetIdx++;
            const baseName = sanitizeRuleName(preset?.name || 'custom');
            let name = baseName;
            let i = 2; while (userFunctions.find(u => u.name === name)) { name = `${baseName}-${i++}`; }
            if (userFunctions.find(u => u.name === name)) { alert('Rule already exists.'); return; }
            // Create tab and content
            const tabsBar = document.querySelector('.code-tabs');
            const tabBtn = document.createElement('button');
            tabBtn.className = 'tab-button'; tabBtn.dataset.tab = name; tabBtn.textContent = name.charAt(0).toUpperCase() + name.slice(1);
            tabsBar.insertBefore(tabBtn, tabsBar.querySelector('.dock-controls'));
            const content = document.createElement('div'); content.id = name; content.className = 'tab-content';
            // Per-editor toolbar
            const bar = buildEditorBar(name); content.appendChild(bar);
            const ta = document.createElement('textarea'); content.appendChild(ta);
            document.getElementById('code-pane').appendChild(content);
            // Editor
            const ed = CodeMirror.fromTextArea(ta, { mode:'javascript', theme:'dracula', lineNumbers:true, lint:true, gutters:["CodeMirror-lint-markers"], extraKeys:{'Ctrl-Space':'autocomplete'}, hintOptions:{hint: editor => ruleHint(editor), completeSingle:false} });
            editors[name] = ed;
            // Compile function
            const fnObj = { name, weight: 1.0, updateBoid: null };
            userFunctions.push(fnObj);
            // Hook tab behavior
            tabBtn.addEventListener('click', () => {
                document.querySelectorAll('.tab-button').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                tabBtn.classList.add('active'); content.classList.add('active'); ed.refresh();
            });
            // Set code from chosen preset and compile; rename already set to preset name
            if (preset && preset.code) ed.setValue(preset.code); else ed.setValue('return new Vector();');
            const updateFunction = debounce((editor) => {
                const tabButton = tabBtn;
                try {
                    const code = editor.getValue();
                    const params = ['boid','gameState','neighbors','config','mouse','Vector','api'];
                    const dynamicFunc = new Function(...params, code);
                    // dry-run
                    const mockBoid = new Boid(0,0); const mockState = { boids:[mockBoid], quadtree:null, width:10, height:10 };
                    let ok = true; try { const res = dynamicFunc(mockBoid, mockState, [], config, mouse, Vector, RuleAPI); if (res && !(res instanceof Vector)) ok = false; } catch(e){ ok=false; }
                    if (!ok) throw new Error('Rule dry-run failed');
                    fnObj.updateBoid = (boid, gameState, neighbors) => { try { const out = dynamicFunc(boid, gameState, neighbors, config, mouse, Vector, RuleAPI); return out instanceof Vector ? out : new Vector(); } catch (e) { fnObj._fallbackUntil = performance.now()+2000; updateRuleStatusUI(); return new Vector(); } };
                    tabButton.classList.add('reloaded-success'); setTimeout(()=>tabButton.classList.remove('reloaded-success'),600);
                } catch (e) {
                    console.error(`Error reloading rule '${name}':`, e);
                    fnObj.updateBoid = () => new Vector();
                    tabButton.classList.add('reloaded-error'); setTimeout(()=>tabButton.classList.remove('reloaded-error'),600);
                    fnObj._fallbackUntil = performance.now()+2000; updateRuleStatusUI();
                }
            }, 500);
            ed.on('change', updateFunction);
            ed.on('inputRead', (cm, change) => { if (!change.text) return; const ch = change.text.join(''); if (/^[\w\.$]$/.test(ch)) cm.showHint({ hint: ruleHint, completeSingle:false });});
            updateFunction(ed);
            // Rebuild config UI and split pickers
            config[`${name}Weight`] = 1.0;
            setupConfigUI();
            if (setupCodePane._split) { setupCodePane._split.populateSelects(); setupCodePane._split.updateSplitMounts(); }
        }

        function getCurrentRuleTarget() {
            const pane = document.getElementById('code-pane');
            const maximized = pane.classList.contains('maximized');
            if (maximized && config.splitEnabled) {
                // Default to left selection
                const leftSel = document.getElementById('split-left');
                return leftSel && leftSel.value || null;
            }
            const active = document.querySelector('.tab-button.active');
            return active ? active.dataset.tab : null;
        }

        function renameRule(oldNameRaw, newNameRaw) {
            const oldName = oldNameRaw; const newName = sanitizeRuleName(newNameRaw);
            if (!editors[oldName]) { alert('Rule not found.'); return; }
            if (editors[newName]) { alert('A rule with that name already exists.'); return; }
            // Update userFunctions entry
            const fnObj = userFunctions.find(u => u.name === oldName);
            if (!fnObj) return;
            fnObj.name = newName;
            // Move editor mapping
            editors[newName] = editors[oldName]; delete editors[oldName];
            // Update tab button and content IDs
            const tabBtn = document.querySelector(`.tab-button[data-tab="${oldName}"]`);
            const content = document.getElementById(oldName);
            if (tabBtn) { tabBtn.dataset.tab = newName; tabBtn.textContent = newName.charAt(0).toUpperCase()+newName.slice(1); }
            if (content) { content.id = newName; }
            // Update config weight key
            const oldKey = `${oldName}Weight`; const newKey = `${newName}Weight`;
            config[newKey] = (oldKey in config) ? config[oldKey] : 1.0; delete config[oldKey];
            setupConfigUI();
            // Update split selections
            const leftSel = document.getElementById('split-left');
            const rightSel = document.getElementById('split-right');
            if (leftSel && leftSel.value === oldName) leftSel.value = newName;
            if (rightSel && rightSel.value === oldName) rightSel.value = newName;
            if (setupCodePane._split) { setupCodePane._split.populateSelects(); setupCodePane._split.updateSplitMounts(); }
        }

        function addRuleWithPreset(preset) {
            if (!preset) return;
            addRule(preset.name);
            const name = sanitizeRuleName(preset.name);
            const ed = editors[name];
            if (ed) ed.setValue(preset.code);
        }

        function resetRulesWithPresets(n, includeCore) {
            const coreIds = new Set(['cohesion-core','alignment-core','separation-core','novel-core']);
            const corePresets = rulePresets.filter(p => coreIds.has(p.id));
            const nonCorePresets = rulePresets.filter(p => !coreIds.has(p.id));
            // Shuffle helper
            const shuffle = (arr) => { const a = arr.slice(); for (let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; };
            // Build final selection: [core (optional)] + N random non-core
            const selected = [];
            if (includeCore) selected.push(...corePresets);
            const picks = shuffle(nonCorePresets).slice(0, Math.max(0, Math.min(n, nonCorePresets.length)));
            selected.push(...picks);
            if (selected.length === 0) return;
            // Replace current rules with selected list (first replaces first rule; others added; rest deleted)
            if (userFunctions.length === 0) {
                addRuleWithPreset(selected[0]);
            } else {
                // Replace first
                const first = userFunctions[0].name;
                const ed = editors[first];
                if (ed) ed.setValue(selected[0].code);
                const targetName = sanitizeRuleName(selected[0].name);
                if (first !== targetName) renameRule(first, targetName);
                // Delete all others for a clean slate
                const others = userFunctions.slice(1).map(u => u.name);
                others.forEach(nm => deleteRule(nm));
            }
            // Add remaining selections in order
            for (let i = 1; i < selected.length; i++) addRuleWithPreset(selected[i]);
            // Rebuild UI bits
            if (setupCodePane._split) { setupCodePane._split.populateSelects(); setupCodePane._split.updateSplitMounts(); }
            setupConfigUI();
        }

        function deleteRule(name) {
            if (!editors[name]) return;
            // Remove from userFunctions
            const idx = userFunctions.findIndex(u => u.name === name);
            if (idx >= 0) userFunctions.splice(idx,1);
            // Remove editor DOM
            const wrapper = editors[name].getWrapperElement();
            if (wrapper && wrapper.parentNode) wrapper.parentNode.removeChild(wrapper);
            delete editors[name];
            // Remove tab and content
            const tabBtn = document.querySelector(`.tab-button[data-tab="${name}"]`);
            const content = document.getElementById(name);
            if (tabBtn && tabBtn.parentNode) tabBtn.parentNode.removeChild(tabBtn);
            if (content && content.parentNode) content.parentNode.removeChild(content);
            // Update active tab
            const firstTab = document.querySelector('.tab-button');
            const firstContentId = firstTab ? firstTab.dataset.tab : null;
            if (firstTab) firstTab.classList.add('active');
            if (firstContentId) {
                const firstContent = document.getElementById(firstContentId);
                if (firstContent) firstContent.classList.add('active');
            }
            // Remove weight config and rebuild UI
            delete config[`${name}Weight`];
            setupConfigUI();
            // Update split
            const leftSel = document.getElementById('split-left');
            const rightSel = document.getElementById('split-right');
            if (leftSel && leftSel.value === name) {
                const other = userFunctions[0] && userFunctions[0].name; if (other) leftSel.value = other;
            }
            if (rightSel && rightSel.value === name) {
                const other = userFunctions.find(u => u.name !== (leftSel && leftSel.value)) || userFunctions[0];
                if (other) rightSel.value = other.name;
            }
            if (setupCodePane._split) { setupCodePane._split.populateSelects(); setupCodePane._split.updateSplitMounts(); }
        }
        
        // --- SIMULATION LOGIC ---

        function createBoids() {
            gameState.boids = [];
            for (let i = 0; i < config.boidCount; i++) {
                gameState.boids.push(new Boid(Math.random() * gameState.width, Math.random() * gameState.height));
            }
            logConfig(`Created ${config.boidCount} boids.`);
        }

        function hardReset() {
            // Reset boids and stats without changing code or config
            createBoids();
            fpsHistory.length = 0;
            updateTimeHistory.length = 0;
            drawablesHistory.length = 0;
            angleHistory.length = 0;
            lastTime = performance.now();
            // Clear charts if present
            if (charts.fpsChart) { charts.fpsChart.data.datasets[0].data = []; charts.fpsChart.update('none'); }
            if (charts.updateTimeChart) { charts.updateTimeChart.data.datasets[0].data = []; charts.updateTimeChart.update('none'); }
            if (charts.drawablesChart) { charts.drawablesChart.data.datasets[0].data = []; charts.drawablesChart.update('none'); }
            if (charts.polarCtx) {
                const c = charts.polarCtx.canvas; charts.polarCtx.clearRect(0,0,c.width,c.height);
            }
            if (charts.meanPolarCtx) {
                const c = charts.meanPolarCtx.canvas; charts.meanPolarCtx.clearRect(0,0,c.width,c.height);
            }
            logConfig('Simulation hard reset.');
        }

        // --- MAIN LOOP ---

        function animate(timestamp) {
            const deltaTime = (timestamp - lastTime) || 0;
            lastTime = timestamp;
            fps = 1000 / deltaTime;
            const t0 = performance.now();
            // Clear per-frame drawables before update so rules can register new ones
            drawables.length = 0;
            update();
            const updateTime = performance.now() - t0;
            draw();
            updateStats(updateTime);
            requestAnimationFrame(animate);
        }

        function update() {
            const boundary = new Rectangle(gameState.width / 2, gameState.height / 2, gameState.width / 2, gameState.height / 2);
            gameState.quadtree = new QuadTree(boundary, 4);
            for (let boid of gameState.boids) gameState.quadtree.insert(boid);
            // Pheromone decay
            if (pheromones.grid) {
                const g = pheromones.grid; const d = pheromones.decay;
                for (let i = 0; i < g.length; i++) g[i] *= d;
            }
            // Protect simulation step from rule runtime errors
            for (let boid of gameState.boids) {
                try {
                    boid.update(gameState);
                } catch (e) {
                    if (!update._lastErrorTs || (performance.now() - update._lastErrorTs) > 1000) {
                        console.error('Update step error (continuing):', e);
                        update._lastErrorTs = performance.now();
                    }
                }
            }
        }

        function draw() {
            ctx.fillStyle = 'rgba(26, 26, 26, 0.25)';
            ctx.fillRect(0, 0, gameState.width, gameState.height);
            // Draw pheromone heatmap (lightweight grid rendering)
            if (pheromones.grid) {
                const cell = pheromones.cell; const g = pheromones.grid;
                for (let y = 0; y < pheromones.rows; y++) {
                    for (let x = 0; x < pheromones.cols; x++) {
                        const v = g[y * pheromones.cols + x];
                        if (v > 0.02) {
                            const a = Math.min(0.25, v * 0.08);
                            ctx.fillStyle = `hsla(${(config.hue + 60) % 360}, 100%, 60%, ${a.toFixed(3)})`;
                            ctx.fillRect(x * cell, y * cell, cell, cell);
                        }
                    }
                }
            }
            if (config.visualizeQuadtree) gameState.quadtree.draw(ctx);
            for (let boid of gameState.boids) boid.draw(ctx);
            // Custom rule drawables (if any)
            if (drawables.length) {
                for (const fn of drawables) {
                    try { fn(ctx, gameState); } catch (e) { console.log(e) }
                }
            }
            if (mouse.down) {
                 ctx.beginPath();
                 ctx.arc(mouse.pos.x, mouse.pos.y, 150, 0, Math.PI * 2);
                 const gradient = ctx.createRadialGradient(mouse.pos.x, mouse.pos.y, 10, mouse.pos.x, mouse.pos.y, 150);
                 gradient.addColorStop(0, `hsla(${config.hue}, 100%, 50%, 0.3)`);
                 gradient.addColorStop(1, `hsla(${config.hue}, 100%, 50%, 0)`);
                 ctx.fillStyle = gradient;
                 ctx.fill();
            }
            ctx.fillStyle = `hsl(${config.hue}, 100%, 50%)`;
            ctx.beginPath();
            ctx.arc(mouse.pos.x, mouse.pos.y, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = `hsla(${config.hue}, 100%, 80%, 0.8)`;
            ctx.font = 'bold 36px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(config.header, gameState.width / 2, 50);
            ctx.font = '24px sans-serif';
            ctx.fillText(config.subheader, gameState.width / 2, 90);

            // Debug: show number of drawables this frame (enable with ?debug=true)
            if (config.debug) {
                ctx.save();
                ctx.textAlign = 'left';
                ctx.fillStyle = '#ccc';
                ctx.font = '12px monospace';
                ctx.fillText(`drawables: ${drawables.length}`, 10, 18);
                ctx.restore();
            }
        }

        function updateStats(updateTime) {
            if (isFinite(fps)) {
                document.getElementById('fps-counter').textContent = Math.round(fps);
                fpsHistory.push(fps);
                if (fpsHistory.length > 50) fpsHistory.shift();
                charts.fpsChart.data.datasets[0].data = fpsHistory;
                charts.fpsChart.update('none');
            }
            // Update rule fallback indicators (throttled)
            updateRuleStatusUI();
            document.getElementById('particle-count').textContent = Math.round(config.boidCount);
            if (isFinite(updateTime)) {
                document.getElementById('update-time').textContent = updateTime.toFixed(2);
                updateTimeHistory.push(updateTime);
                if (updateTimeHistory.length > 50) updateTimeHistory.shift();
                const mean = updateTimeHistory.reduce((a, b) => a + b, 0) / updateTimeHistory.length;
                const stdDev = Math.sqrt(updateTimeHistory.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b, 0) / updateTimeHistory.length);
                document.getElementById('update-time-mean').textContent = mean.toFixed(2);
                document.getElementById('update-time-stddev').textContent = stdDev.toFixed(2);
                charts.updateTimeChart.data.datasets[0].data = updateTimeHistory;
                charts.updateTimeChart.update('none');
            }
            // Drawables per frame
            const dCount = Array.isArray(drawables) ? drawables.length : 0;
            const dcEl = document.getElementById('drawables-count');
            if (dcEl) dcEl.textContent = String(dCount);
            drawablesHistory.push(dCount);
            if (drawablesHistory.length > 50) drawablesHistory.shift();
            if (charts.drawablesChart) {
                charts.drawablesChart.data.datasets[0].data = drawablesHistory;
                charts.drawablesChart.update('none');
            }
            if (gameState.boids.length > 0) {
                const sumVec = new Vector(0, 0);
                for (const boid of gameState.boids) sumVec.add(boid.vel.clone().normalize());
                const meanAngle = sumVec.heading();
                const R = sumVec.mag() / gameState.boids.length;
                const stdDev = R < 1 ? Math.sqrt(-2 * Math.log(R)) : 0;
                angleHistory.push({ meanAngle, stdDev });
                if (angleHistory.length > MAX_ANGLE_HISTORY) angleHistory.shift();
            }
            drawPolarSpiralChart();
            drawMeanPolarChart();
        }

        function drawPolarSpiralChart() {
            if (!charts.polarCtx || angleHistory.length < 2) return;
            const ctx = charts.polarCtx;
            const canvas = ctx.canvas;
            const { width, height } = canvas;
            const centerX = width / 2;
            const centerY = height / 2;
            const maxRadius = Math.min(centerX, centerY) * 0.9;
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 1; i <= 4; i++) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, (maxRadius / 4) * i, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.beginPath();
            for (let i = 0; i < angleHistory.length; i++) {
                const record = angleHistory[i];
                const radius = Math.min(record.stdDev / Math.sqrt(2), 1.0) * maxRadius;
                const x = centerX + radius * Math.cos(record.meanAngle);
                const y = centerY + radius * Math.sin(record.meanAngle);
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.strokeStyle = `hsl(${config.hue}, 100%, 50%)`;
            ctx.lineWidth = 2;
            ctx.stroke();
            const lastRecord = angleHistory[angleHistory.length - 1];
            const lastRadius = Math.min(lastRecord.stdDev / Math.sqrt(2), 1.0) * maxRadius;
            const lastX = centerX + lastRadius * Math.cos(lastRecord.meanAngle);
            const lastY = centerY + lastRadius * Math.sin(lastRecord.meanAngle);
            ctx.beginPath();
            ctx.arc(lastX, lastY, 4, 0, Math.PI * 2);
            ctx.fillStyle = 'white';
            ctx.fill();
        }

        function drawMeanPolarChart() {
            if (!charts.meanPolarCtx || angleHistory.length < 2) return;
            const ctx = charts.meanPolarCtx;
            const canvas = ctx.canvas;
            const { width, height } = canvas;
            const centerX = width / 2;
            const centerY = height / 2;
            const maxRadius = Math.min(centerX, centerY) * 0.9;

            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, width, height);
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 5, centerX, centerY, maxRadius);
            bgGradient.addColorStop(0, '#222');
            bgGradient.addColorStop(1, '#111');
            ctx.beginPath();
            ctx.arc(centerX, centerY, maxRadius, 0, Math.PI * 2);
            ctx.fillStyle = bgGradient;
            ctx.fill();

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 1; i <= 4; i++) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, (maxRadius / 4) * i, 0, Math.PI * 2);
                ctx.stroke();
            }
            for (let i = 0; i < 8; i++) {
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + maxRadius * Math.cos(i * Math.PI / 4), centerY + maxRadius * Math.sin(i * Math.PI / 4));
                ctx.stroke();
            }

            if (charts.showStdDevBands.checked) {
                ctx.beginPath();
                for (let i = 0; i < angleHistory.length; i++) {
                    const radius = (i / MAX_ANGLE_HISTORY) * maxRadius;
                    const x = centerX + radius * Math.cos(angleHistory[i].meanAngle + angleHistory[i].stdDev);
                    const y = centerY + radius * Math.sin(angleHistory[i].meanAngle + angleHistory[i].stdDev);
                    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                }
                for (let i = angleHistory.length - 1; i >= 0; i--) {
                    const radius = (i / MAX_ANGLE_HISTORY) * maxRadius;
                    const x = centerX + radius * Math.cos(angleHistory[i].meanAngle - angleHistory[i].stdDev);
                    const y = centerY + radius * Math.sin(angleHistory[i].meanAngle - angleHistory[i].stdDev);
                    ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fillStyle = `hsla(${config.hue}, 100%, 50%, 0.15)`;
                ctx.fill();
            }
            
            ctx.beginPath();
            for (let i = 0; i < angleHistory.length; i++) {
                const radius = (i / MAX_ANGLE_HISTORY) * maxRadius;
                const x = centerX + radius * Math.cos(angleHistory[i].meanAngle);
                const y = centerY + radius * Math.sin(angleHistory[i].meanAngle);
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            const lineGradient = ctx.createLinearGradient(centerX - maxRadius, centerY, centerX + maxRadius, centerY);
            lineGradient.addColorStop(0, `hsl(${config.hue}, 100%, 30%)`);
            lineGradient.addColorStop(0.5, `hsl(${config.hue}, 100%, 50%)`);
            lineGradient.addColorStop(1, `hsl(${config.hue}, 100%, 70%)`);
            ctx.strokeStyle = lineGradient;
            ctx.lineWidth = 2;
            ctx.stroke();

            const lastRecord = angleHistory[angleHistory.length - 1];
            const lastRadius = ((angleHistory.length - 1) / MAX_ANGLE_HISTORY) * maxRadius;
            const lastX = centerX + lastRadius * Math.cos(lastRecord.meanAngle);
            const lastY = centerY + lastRadius * Math.sin(lastRecord.meanAngle);
            ctx.beginPath();
            ctx.arc(lastX, lastY, 4, 0, Math.PI * 2);
            ctx.fillStyle = 'white';
            ctx.fill();

            const meanDeg = (lastRecord.meanAngle * 180 / Math.PI + 360) % 360;
            const stdDevDeg = lastRecord.stdDev * 180 / Math.PI;
            ctx.font = `12px ${getComputedStyle(document.documentElement).getPropertyValue('--font-mono')}`;
            ctx.fillStyle = '#ccc';
            ctx.textAlign = 'left';
            ctx.fillText(`Mean: ${meanDeg.toFixed(1)}°`, 10, 20);
            ctx.fillText(`StdDev: ${stdDevDeg.toFixed(1)}°`, 10, 35);
        }

        // --- COLOR HELPERS ---
        function hslToHex(h, s, l) {
            l /= 100; const a = s * Math.min(l, 1 - l) / 100;
            const f = n => { const k = (n + h / 30) % 12; const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1); return Math.round(255 * color).toString(16).padStart(2, '0'); };
            return `#${f(0)}${f(8)}${f(4)}`;
        }
        function hexToHsl(hex) {
            let r=0,g=0,b=0; if(hex.length==4){r=parseInt(hex[1]+hex[1],16);g=parseInt(hex[2]+hex[2],16);b=parseInt(hex[3]+hex[3],16);}else if(hex.length==7){r=parseInt(hex[1]+hex[2],16);g=parseInt(hex[3]+hex[4],16);b=parseInt(hex[5]+hex[6],16);}
            r/=255;g/=255;b/=255; let cmin=Math.min(r,g,b),cmax=Math.max(r,g,b),delta=cmax-cmin,h=0,s=0,l=0;
            if(delta==0)h=0;else if(cmax==r)h=((g-b)/delta)%6;else if(cmax==g)h=(b-r)/delta+2;else h=(r-g)/delta+4;
            h=Math.round(h*60); if(h<0)h+=360; l=(cmax+cmin)/2; s=delta==0?0:delta/(1-Math.abs(2*l-1)); s=+(s*100).toFixed(1);l=+(l*100).toFixed(1); return[h,s,l];
        }

        // --- START ---
        init();
    })();
    </script>
</body>
</html>
