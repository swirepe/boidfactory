<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>{{Title}}</title>
    <style>
      html, body { height:100%; margin:0; }
      body { background:#05070a; color:#e6edf3; overflow:hidden; font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
      #scene { width:100vw; height:100vh; display:block; }
      .overlay { position:fixed; inset:0; pointer-events:none; display:grid; grid-template-rows:auto 1fr auto; }
      .title { margin:16px 16px 2px; font-weight:700; font-size:clamp(18px,3vw,28px); color: var(--accent, #7dd3fc); }
      .subtitle { margin:0 16px 10px; opacity:.85; }
      .hud { position:fixed; left:12px; bottom:12px; padding:8px 10px; border-radius:10px; border:1px solid #00000040; background:#0b1220cc; backdrop-filter: blur(8px) saturate(120%); font-size:12px; }
    </style>
  </head>
  <body>
    <canvas id="scene"></canvas>
    <div class="overlay">
      <div class="title" id="title"></div>
      <div class="subtitle" id="subtitle"></div>
      <div class="hud" id="hud"></div>
    </div>
    <script>
    'use strict';

    // Config seeded from Go
    const DEFAULT_HUE = {{DefaultHue}};
    const SEED = BigInt({{Seed}});
    const CFG = {
      count: {{CfgCount}},
      vision: {{CfgVision}},
      sep: {{CfgSep}},
      maxSpeed: {{CfgMaxSpeed}},
      minSpeed: {{CfgMinSpeed}},
      maxForce: {{CfgMaxForce}},
      alignW: {{CfgAlignW}},
      cohesionW: {{CfgCohW}},
      separationW: {{CfgSepW}},
      lineWidth: {{CfgLineW}},
      wrap: {{CfgWrap}}
    };

    const params = new URLSearchParams(location.search);
    const BASE_HUE = clampInt(parseInt(params.get('hue')), 0, 360, DEFAULT_HUE);
    const HEADER = params.get('header') || {{HEADER_JSON}};
    const SUBHEADER = params.get('subheader') || {{SUBHEADER_JSON}};

    function clampInt(n, lo, hi, fallback){ n = Number.isFinite(n)?n:fallback; return Math.max(lo, Math.min(hi, n)); }

    // Tiny seeded RNG (xorshift64*)
    let _s = SEED ^ 0x9e3779b97f4a7c15n;
    function rnd(){
      _s ^= _s >> 12n; _s ^= _s << 25n; _s ^= _s >> 27n; const t = (_s * 0x2545F4914F6CDD1Dn) & ((1n<<64n)-1n);
      return Number(t>>11n) / Number(1n<<53n);
    }
    function rand(min, max){ return rnd()*(max-min)+min; }

    // Canvas setup
    const canvas = document.getElementById('scene');
    const ctx = canvas.getContext('2d', { alpha:false });
    let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    function resize(){
      DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvas.width = Math.floor(innerWidth*DPR);
      canvas.height = Math.floor(innerHeight*DPR);
      ctx.setTransform(DPR,0,0,DPR,0,0);
      clearHard();
    }
    addEventListener('resize', resize);
    resize();

    function clearHard(){
      ctx.fillStyle = '#05070a';
      ctx.fillRect(0,0,innerWidth,innerHeight);
    }

    // UI
    const titleEl = document.getElementById('title');
    const subtitleEl = document.getElementById('subtitle');
    const hudEl = document.getElementById('hud');
    titleEl.textContent = `Boids — hue ${BASE_HUE}`;
    subtitleEl.textContent = SUBHEADER.replace(/\+/g,' ');

    // Palette
    let paletteHue = BASE_HUE;

    // Boid state
    const N = CFG.count;
    const x = new Float32Array(N), y = new Float32Array(N), vx = new Float32Array(N), vy = new Float32Array(N);
    for (let i=0;i<N;i++){
      x[i] = rand(0, innerWidth);
      y[i] = rand(0, innerHeight);
      const a = rand(0, Math.PI*2);
      const s = rand(CFG.minSpeed, CFG.maxSpeed);
      vx[i] = Math.cos(a)*s; vy[i] = Math.sin(a)*s;
    }

    // Interaction
    let mouseX = innerWidth*0.5, mouseY = innerHeight*0.5; let mouseDown = false;
    addEventListener('pointermove', (e)=>{ mouseX=e.clientX; mouseY=e.clientY; });
    addEventListener('pointerdown', ()=>{ mouseDown=true; });
    addEventListener('pointerup', ()=>{ mouseDown=false; });

    const TAU = Math.PI*2;

    function limitVec(ix){
      const sp = Math.hypot(vx[ix], vy[ix]);
      const ms = CFG.maxSpeed;
      if (sp > ms){ const s = ms/sp; vx[ix]*=s; vy[ix]*=s; }
    }

    function step(){
      const V = CFG.vision, S = CFG.sep, A = CFG.alignW, C = CFG.cohesionW, D = CFG.separationW, MF = CFG.maxForce;
      for (let i=0;i<N;i++){
        let n=0, ax=0, ay=0, cx=0, cy=0, sx=0, sy=0;
        const xi=x[i], yi=y[i];
        for (let j=0;j<N;j++){
          if (i===j) continue;
          const dx=x[j]-xi, dy=y[j]-yi; const d2=dx*dx+dy*dy; if (d2>V*V) continue; const d=Math.sqrt(d2);
          n++;
          // alignment
          ax+=vx[j]; ay+=vy[j];
          // cohesion target
          cx+=x[j]; cy+=y[j];
          // separation
          if (d < S){ const f=(S-d)/S; sx-=dx/d*f; sy-=dy/d*f; }
        }
        if (n>0){
          ax/=n; ay/=n; // avg velocity
          // steer alignment toward avg vel
          const al=len1(ax,ay); ax/=al; ay/=al; ax*=A; ay*=A;
          // cohesion steer toward center of mass
          cx/=n; cy/=n; cx=(cx-xi); cy=(cy-yi); const cl=len1(cx,cy); if (cl>0){ cx/=cl; cy/=cl; } cx*=C; cy*=C;
          // separation already points away
          sx*=D; sy*=D;
          // add forces, clamp
          vx[i]+=clamp(sx+cx+ax, -MF, MF); vy[i]+=clamp(sy+cy+ay, -MF, MF);
        }

        // Mouse attract/repel
        if (mouseDown){
          const dx=mouseX-x[i], dy=mouseY-y[i]; const d=Math.hypot(dx,dy)+1e-3;
          const f = Math.min(0.6, 120/(d+40));
          vx[i]+=dx/d*f; vy[i]+=dy/d*f;
        }

        limitVec(i);
        x[i]+=vx[i]; y[i]+=vy[i];
        if (CFG.wrap){
          if (x[i]<0) x[i]+=innerWidth; else if (x[i]>innerWidth) x[i]-=innerWidth;
          if (y[i]<0) y[i]+=innerHeight; else if (y[i]>innerHeight) y[i]-=innerHeight;
        } else {
          if (x[i]<0||x[i]>innerWidth) vx[i]*=-1;
          if (y[i]<0||y[i]>innerHeight) vy[i]*=-1;
          x[i]=Math.max(0,Math.min(innerWidth,x[i]));
          y[i]=Math.max(0,Math.min(innerHeight,y[i]));
        }
      }
    }

    function len1(x,y){ const l=Math.hypot(x,y)||1; return l; }
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    let last=performance.now(); let frames=0; let acc=0;
    function render(ts){
      const dt = (ts-last)/1000; last=ts; frames++; acc+=dt; if (acc>0.5){ hudEl.textContent = `FPS: ${Math.round(frames/acc)}`; frames=0; acc=0; }
      ctx.globalCompositeOperation='lighter';
      ctx.globalAlpha=0.12; clearHard(); ctx.globalAlpha=1;
      ctx.lineWidth = CFG.lineWidth;
      for (let i=0;i<N;i++){
        const sp = Math.hypot(vx[i],vy[i]);
        const hue = (paletteHue + sp*30) % 360;
        ctx.strokeStyle = `hsl(${hue} 80% 60%)`;
        ctx.beginPath();
        ctx.moveTo(x[i], y[i]);
        ctx.lineTo(x[i]-vx[i]*2, y[i]-vy[i]*2);
        ctx.stroke();
      }
      requestAnimationFrame(render);
    }

    // Initialize labels
    (function initLabels(){
      const url = new URL(location.href);
      url.searchParams.set('hue', BASE_HUE);
      url.searchParams.set('header', HEADER);
      url.searchParams.set('subheader', SUBHEADER);
      history.replaceState(null,'',url.toString());
      titleEl.textContent = HEADER;
      subtitleEl.textContent = SUBHEADER;
    })();

    requestAnimationFrame(render);
    setInterval(step, 16);

    </script>
  </body>
</html>

<!-- Helper to inject quoted strings without adding a full template engine in JS -->
<script>
// Poor-man’s inlining of quoted string (we replace {{jsonq "..."}} at build time via Go’s simple placeholder replacement above).
</script>
