<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>{{Title}}</title>
    <style>
      :root{
        --bg:#05070a;
        --panel:#0b1220e6;
        --panel-solid:#0b1220f2;
        --border:#0b122055;
        --text:#e6edf3;
        --muted:#94a3b8;
        --accent: hsl(200 80% 60%);
        --shadow: 0 10px 40px #0008, inset 0 0 0 1px #00000040;
      }
      html, body { height:100%; margin:0; }
      body { background:var(--bg); color:var(--text); overflow:hidden; font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
      .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
      #scene { width:100vw; height:100vh; display:block; }
      .overlay { position:fixed; inset:0; pointer-events:none; display:grid; grid-template-rows:auto 1fr auto; }
      .title { margin:16px 16px 2px; font-weight:800; letter-spacing:.3px; font-size:clamp(18px,3vw,30px);
        background: linear-gradient(90deg, color-mix(in oklab, var(--accent) 80%, #fff 20%), color-mix(in oklab, var(--accent) 50%, #60a5fa 50%));
        -webkit-background-clip: text; background-clip: text; color: transparent; -webkit-text-fill-color: transparent;
        text-shadow: 0 2px 12px color-mix(in oklab, var(--accent) 60%, #000 40%);
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
        position: relative;
      }
      .title::after { content: ""; position:absolute; left:16px; right:16px; bottom:-6px; height:2px; border-radius:999px;
        background: linear-gradient(90deg, color-mix(in oklab, var(--accent) 80%, #fff 20%), transparent);
        opacity:.5; filter: blur(.3px);
      }
      .subtitle { margin:0 16px 10px; opacity:.9; color:var(--muted); }
      .hud { position:fixed; left:12px; bottom:12px; padding:8px 10px; border-radius:12px; border: 1px solid var(--border); background: color-mix(in oklab, var(--panel) 92%, #000 8%); backdrop-filter: blur(10px) saturate(120%); font-size:12px; box-shadow: var(--shadow); font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }

      .cfgBtn { position: fixed; top: 12px; right: 12px; z-index: 10; pointer-events: auto; border: 1px solid var(--border); background: color-mix(in oklab, var(--panel) 94%, #000 6%); color: var(--text); border-radius: 10px; padding: 8px 10px; cursor: pointer; box-shadow: var(--shadow); transition: transform .12s ease, box-shadow .2s ease, border-color .2s ease; }
      .cfgBtn:hover { transform: translateY(-1px); box-shadow: 0 16px 46px #000a, inset 0 0 0 1px color-mix(in oklab, var(--accent) 40%, #000 60%); border-color: color-mix(in oklab, var(--accent) 40%, var(--border) 60%); }
      .cfgBtn:focus-visible { outline: 2px solid color-mix(in oklab, var(--accent) 60%, #fff 40%); outline-offset: 2px; }

      .configPanel { position: fixed; top: 56px; right: 12px; width: min(420px, 92vw); max-height: 80vh; overflow: auto; z-index: 20; pointer-events: none; background: var(--panel); color: var(--text); border: 1px solid var(--border); border-radius: 14px; box-shadow: var(--shadow); backdrop-filter: blur(12px) saturate(120%); opacity: 0; transform: translateY(8px); transition: opacity .18s ease, transform .18s ease; }
      .configPanel.open { opacity: 1; transform: translateY(0); pointer-events: auto; }
      .configHeader { display: flex; align-items: center; justify-content: space-between; padding: 12px 14px; border-bottom: 1px solid var(--border); position: sticky; top: 0; background: var(--panel-solid); }
      .configBody { padding: 12px 14px; display: grid; gap: 12px; }
      .configBody .row { display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center; }
      .configBody .rangeRow { display: grid; grid-template-columns: 1fr 76px; gap: 10px; align-items: center; }
      .configBody .val { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; color: var(--muted); }
      .cfgClose, .configBody button { border: 1px solid var(--border); background: color-mix(in oklab, var(--panel) 90%, #000 10%); color: var(--text); border-radius: 8px; padding: 6px 10px; cursor: pointer; box-shadow: inset 0 0 0 1px #00000040; }
      .cfgClose:hover { border-color: color-mix(in oklab, var(--accent) 40%, var(--border) 60%); }

      .configBody input, .configBody select { font-size: 14px; padding: 6px 8px; background: #0f172a; color: var(--text); border: 1px solid var(--border); border-radius: 8px; }
      .configBody input[type=range] { padding: 0; height: 28px; accent-color: var(--accent); background: transparent; }
      .configBody input[type=checkbox] { width: 18px; height: 18px; accent-color: var(--accent); }

      /* Range polish */
      input[type=range]::-webkit-slider-runnable-track { height: 4px; background: #1f2937; border-radius: 999px; }
      input[type=range]::-webkit-slider-thumb { -webkit-appearance:none; appearance:none; margin-top: -6px; width:16px; height:16px; border-radius:50%; background: var(--accent); box-shadow: 0 2px 10px color-mix(in oklab, var(--accent) 50%, #000 50%); border: 1px solid #0006; }
      input[type=range]::-moz-range-track { height: 4px; background: #1f2937; border-radius: 999px; }
      input[type=range]::-moz-range-thumb { width:16px; height:16px; border-radius:50%; background: var(--accent); border: 1px solid #0006; box-shadow: 0 2px 10px color-mix(in oklab, var(--accent) 50%, #000 50%); }

      /* Scrollbar */
      .configPanel::-webkit-scrollbar { width: 10px; }
      .configPanel::-webkit-scrollbar-track { background: transparent; }
      .configPanel::-webkit-scrollbar-thumb { background: #1f2937; border-radius: 999px; border: 2px solid transparent; background-clip: padding-box; }
    </style>
  </head>
  <body>
    <canvas id="scene"></canvas>
    <div class="overlay">
      <div class="title" id="title"></div>
      <div class="subtitle" id="subtitle"></div>
      <div class="hud" id="hud"></div>
    </div>
    <button id="cfgBtn" class="cfgBtn" aria-label="Open config">⚙︎</button>
    <button id="helpBtn" class="cfgBtn" style="right:56px" aria-label="Open help">?</button>
    <div id="config" class="configPanel" hidden>
      <div class="configHeader">
        <strong>Config</strong>
        <button id="cfgClose" class="cfgClose" aria-label="Close">✕</button>
      </div>
      <div id="configBody" class="configBody"></div>
    </div>
    <div id="help" class="configPanel" hidden>
      <div class="configHeader">
        <strong>Help</strong>
        <button id="helpClose" class="cfgClose" aria-label="Close">✕</button>
      </div>
      <div class="configBody">
        <div class="row"><span class="mono">Overview</span><span></span></div>
        <p>Single-file canvas boids with alignment, cohesion, separation; optional quadtree neighbor queries and flow field. Use the gear to tweak parameters; URL updates live so you can bookmark/share states.</p>
        <div class="row"><span class="mono">URL Params</span><span></span></div>
        <p class="mono" style="white-space:pre-wrap">hue, header, subheader, count, vision, sep, maxSpeed, minSpeed, maxForce, alignW, cohesionW, separationW, lineWidth, trailAlpha, wrap, bgGradient, bgHueShift1/2/3, qt, qtCap, flow, flowAmp, flowScale, flowSpeed, blend, shape, spawn</p>
        <div class="row"><span class="mono">Interactions</span><span></span></div>
        <ul>
          <li>Click/press: emit shockwave (pushes boids)</li>
          <li>Toggle quadtree: see spatial partition overlay</li>
          <li>Flow field: drift influenced by noise vectors</li>
        </ul>
        <div class="row"><span class="mono">About</span><span></span></div>
        <p>Generated by the Go dual-mode generator in this repo. No external libs. Works on desktop and mobile.</p>
      </div>
    </div>
    <script>
    'use strict';

    // Config seeded from Go
    const DEFAULT_HUE = {{DefaultHue}};
    const SEED = BigInt({{Seed}});
    const CFG = {
      count: {{CfgCount}},
      vision: {{CfgVision}},
      sep: {{CfgSep}},
      maxSpeed: {{CfgMaxSpeed}},
      minSpeed: {{CfgMinSpeed}},
      maxForce: {{CfgMaxForce}},
      alignW: {{CfgAlignW}},
      cohesionW: {{CfgCohW}},
      separationW: {{CfgSepW}},
      lineWidth: {{CfgLineW}},
      wrap: {{CfgWrap}},
      // extended defaults for parity and variety (injected from Go)
      trailAlpha: {{CfgTrailAlpha}},
      bgGradient: {{CfgBgGradient}},
      bgHueShift1: {{CfgBgHueShift1}},
      bgHueShift2: {{CfgBgHueShift2}},
      bgHueShift3: {{CfgBgHueShift3}},
      qt: {{CfgQt}},
      qtCap: {{CfgQtCap}},
      flow: {{CfgFlow}},
      flowAmp: {{CfgFlowAmp}},
      flowScale: {{CfgFlowScale}},
      flowSpeed: {{CfgFlowSpeed}},
      flowViz: {{CfgFlowViz}},
      flowVizStep: {{CfgFlowVizStep}},
      flowMode: '{{CfgFlowMode}}',
      flowAmpVar: {{CfgFlowAmpVar}},
      flowAniso: {{CfgFlowAniso}},
      flowOctaves: {{CfgFlowOctaves}},
      flowColor: {{CfgFlowColor}},
      flowHueScale: {{CfgFlowHueScale}},
      flowColorMode: '{{CfgFlowColorMode}}',
      showHeader: {{CfgShowHeader}},
      showSubheader: {{CfgShowSubheader}},
      showHud: {{CfgShowHud}},
      shape: '{{CfgShape}}',
      blend: '{{CfgBlend}}',
      spawn: '{{CfgSpawn}}'
    };

    const params = new URLSearchParams(location.search);
    const BASE_HUE = clampInt(parseInt(params.get('hue')), 0, 360, DEFAULT_HUE);
    const HEADER = params.get('header') || {{HEADER_JSON}};
    const SUBHEADER = (params.get('subheader') !== null) ? params.get('subheader') : {{SUBHEADER_JSON}};

    function clampInt(n, lo, hi, fallback){ n = Number.isFinite(n)?n:fallback; return Math.max(lo, Math.min(hi, n)); }

    // Tiny seeded RNG (xorshift64*)
    let _s = SEED ^ 0x9e3779b97f4a7c15n;
    function rnd(){
      _s ^= _s >> 12n; _s ^= _s << 25n; _s ^= _s >> 27n; const t = (_s * 0x2545F4914F6CDD1Dn) & ((1n<<64n)-1n);
      return Number(t>>11n) / Number(1n<<53n);
    }
    function rand(min, max){ return rnd()*(max-min)+min; }

    // Canvas setup
    const canvas = document.getElementById('scene');
    const ctx = canvas.getContext('2d', { alpha:false });
    let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    function resize(){
      DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvas.width = Math.floor(innerWidth*DPR);
      canvas.height = Math.floor(innerHeight*DPR);
      ctx.setTransform(DPR,0,0,DPR,0,0);
      clearHard();
    }
    addEventListener('resize', resize);
    resize();

    function clearHard(){
      if (CFG.bgGradient) {
        const g = ctx.createRadialGradient(innerWidth*0.65, innerHeight*0.35, Math.min(innerWidth, innerHeight)*0.15,
                                           innerWidth*0.5, innerHeight*0.5, Math.hypot(innerWidth, innerHeight)*0.7);
        g.addColorStop(0.0, `hsl(${(BASE_HUE+CFG.bgHueShift1)%360} 80% 10%)`);
        g.addColorStop(0.5, `hsl(${(BASE_HUE+CFG.bgHueShift2)%360} 70% 8%)`);
        g.addColorStop(1.0, `hsl(${(BASE_HUE+CFG.bgHueShift3)%360} 60% 6%)`);
        ctx.fillStyle = g;
      } else {
        ctx.fillStyle = '#05070a';
      }
      ctx.fillRect(0,0,innerWidth,innerHeight);
    }

    // UI
    const titleEl = document.getElementById('title');
    const subtitleEl = document.getElementById('subtitle');
    const hudEl = document.getElementById('hud');
    titleEl.textContent = `Boids — hue ${BASE_HUE}`;
    subtitleEl.textContent = SUBHEADER.replace(/\+/g,' ');

    // Palette
    let paletteHue = BASE_HUE;

    // Boid state
    const N = CFG.count;
    const x = new Float32Array(N), y = new Float32Array(N), vx = new Float32Array(N), vy = new Float32Array(N);
    const sz = new Float32Array(N); // per-boid size scalar
    // Spawn patterns for variety
    (function spawnBoids(){
      const sp = (CFG.spawn||'random').toLowerCase();
      const cx=innerWidth*0.5, cy=innerHeight*0.5; const R=Math.min(innerWidth, innerHeight)*0.38;
      const gridN = Math.ceil(Math.sqrt(N));
      for (let i=0;i<N;i++){
        let px,py;
        switch (sp){
          case 'ring': {
            const a = (i/N)*Math.PI*2; px = cx + Math.cos(a)*R; py = cy + Math.sin(a)*R; break;
          }
          case 'center': {
            const a = rand(0,Math.PI*2); const r = R*0.2*rand(0,1); px = cx + Math.cos(a)*r; py = cy + Math.sin(a)*r; break;
          }
          case 'edge': {
            const p = rand(0,1); if (p<0.25){ px=rand(0,innerWidth); py=0; } else if (p<0.5){ px=innerWidth; py=rand(0,innerHeight);} else if (p<0.75){ px=rand(0,innerWidth); py=innerHeight;} else { px=0; py=rand(0,innerHeight);} break;
          }
          case 'grid': {
            const gx = i % gridN, gy = Math.floor(i / gridN);
            px = (gx+0.5) * (innerWidth/gridN); py = (gy+0.5) * (innerHeight/gridN); break;
          }
          default: {
            px = rand(0, innerWidth); py = rand(0, innerHeight);
          }
        }
        x[i]=px; y[i]=py;
        const a = rand(0, Math.PI*2);
        const s = rand(CFG.minSpeed, CFG.maxSpeed);
        vx[i] = Math.cos(a)*s; vy[i] = Math.sin(a)*s;
        sz[i] = 0.7 + rand(0, 1.6); // varied size per boid
      }
    })();

    // Interaction
    let mouseX = innerWidth*0.5, mouseY = innerHeight*0.5; let mouseDown = false;
    const shocks = [];
    addEventListener('pointermove', (e)=>{ mouseX=e.clientX; mouseY=e.clientY; });
    addEventListener('pointerdown', ()=>{ mouseDown=true; shocks.push({x:mouseX,y:mouseY,t:0}); });
    addEventListener('pointerup', ()=>{ mouseDown=false; });

    const TAU = Math.PI*2;

    function limitVec(ix){
      const sp = Math.hypot(vx[ix], vy[ix]);
      const ms = CFG.maxSpeed;
      if (sp > ms){ const s = ms/sp; vx[ix]*=s; vy[ix]*=s; }
    }

    function step(){
      const V = CFG.vision, S = CFG.sep, A = CFG.alignW, C = CFG.cohesionW, D = CFG.separationW, MF = CFG.maxForce;
      // Flow field time
      flowT += 0.016*CFG.flowSpeed;
      // Build quadtree
      let qt = null;
      if (CFG.qt){ qt = buildQT(); }
      for (let i=0;i<N;i++){
        let n=0, ax=0, ay=0, cx=0, cy=0, sx=0, sy=0;
        const xi=x[i], yi=y[i];
        const neigh = CFG.qt ? queryNeighbors(qt, xi, yi, V, i) : null;
        const loop = CFG.qt ? neigh : indices;
        for (let k=0;k<loop.length;k++){
          const j = loop[k]; if (j===i) continue;
          const dx=x[j]-xi, dy=y[j]-yi; const d2=dx*dx+dy*dy; if (d2>V*V) continue; const d=Math.sqrt(d2);
          n++;
          ax+=vx[j]; ay+=vy[j]; // alignment
          cx+=x[j]; cy+=y[j];   // cohesion target
          if (d < S){ const f=(S-d)/S; sx-=dx/d*f; sy-=dy/d*f; } // separation
        }
        if (n>0){
          ax/=n; ay/=n; // avg velocity
          // steer alignment toward avg vel
          const al=len1(ax,ay); ax/=al; ay/=al; ax*=A; ay*=A;
          // cohesion steer toward center of mass
          cx/=n; cy/=n; cx=(cx-xi); cy=(cy-yi); const cl=len1(cx,cy); if (cl>0){ cx/=cl; cy/=cl; } cx*=C; cy*=C;
          // separation already points away
          sx*=D; sy*=D;
          // add forces, clamp
          vx[i]+=clamp(sx+cx+ax, -MF, MF); vy[i]+=clamp(sy+cy+ay, -MF, MF);
        }
        // Flow field
        if (CFG.flow){ const v=flowVec(x[i], y[i], 1); vx[i]+=v[0]; vy[i]+=v[1]; }
        
        // Mouse attract/repel
        if (mouseDown){
          const dx=mouseX-x[i], dy=mouseY-y[i]; const d=Math.hypot(dx,dy)+1e-3;
          const f = Math.min(0.6, 120/(d+40));
          vx[i]+=dx/d*f; vy[i]+=dy/d*f;
        }
        // Shockwaves
        for (let s=0;s<shocks.length;s++){
          const sh = shocks[s]; const dx=x[i]-sh.x, dy=y[i]-sh.y; const d=Math.hypot(dx,dy)+1e-3; const R = 220+sh.t*420; const w = Math.max(0, 1 - Math.abs(d-R)/60);
          if (w>0){ const str = 0.8*w; vx[i]+=dx/d*str; vy[i]+=dy/d*str; }
        }

        limitVec(i);
        x[i]+=vx[i]; y[i]+=vy[i];
        if (CFG.wrap){
          x[i] = wrapCoord(x[i], innerWidth);
          y[i] = wrapCoord(y[i], innerHeight);
        } else {
          if (x[i]<0||x[i]>innerWidth) vx[i]*=-1;
          if (y[i]<0||y[i]>innerHeight) vy[i]*=-1;
          x[i]=Math.max(0,Math.min(innerWidth,x[i]));
          y[i]=Math.max(0,Math.min(innerHeight,y[i]));
        }
      }
    }

    function len1(x,y){ const l=Math.hypot(x,y)||1; return l; }
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function wrapCoord(v, max){ v = v % max; if (v < 0) v += max; return v; }

    let last=performance.now(); let frames=0; let acc=0; let flowT=0;
    let _prevHeader=null, _prevSubheader=null, _prevHud=null;
    function render(ts){
      const dt = (ts-last)/1000; last=ts; frames++; acc+=dt; if (acc>0.5){ hudEl.textContent = `FPS: ${Math.round(frames/acc)}`; frames=0; acc=0; }
      // Apply overlay visibility toggles
      const sh = !!CFG.showHeader; if (_prevHeader!==sh){ titleEl.style.display = sh ? '' : 'none'; _prevHeader=sh; }
      const ss = !!CFG.showSubheader; const hasSub = !!(SUBHEADER||''); if (_prevSubheader !== (ss&&hasSub)){ subtitleEl.style.display = (ss&&hasSub) ? '' : 'none'; _prevSubheader = (ss&&hasSub); }
      const hd = !!CFG.showHud; if (_prevHud!==hd){ hudEl.style.display = hd ? '' : 'none'; _prevHud=hd; }
      // Clear/fade background in normal compose so it doesn't brighten
      const prevOp = ctx.globalCompositeOperation;
      ctx.globalCompositeOperation='source-over';
      ctx.globalAlpha=CFG.trailAlpha; clearHard(); ctx.globalAlpha=1;
      // Switch to draw mode (e.g., additive trails for boids)
      ctx.globalCompositeOperation=CFG.blend || 'lighter';
      ctx.lineWidth = CFG.lineWidth;
      // Draw overlays (quadtree, flow) in normal composition to avoid additive brightening
      if (CFG.qt || CFG.flowViz){
        // Draw overlays in normal composition to avoid additive brightening
        const saved = ctx.globalCompositeOperation;
        ctx.globalCompositeOperation='source-over';
        if (CFG.qt) drawQT();
        if (CFG.flowViz) drawFlowViz();
        ctx.globalCompositeOperation=saved;
      }
      for (let i=0;i<N;i++){
        const spd = Math.hypot(vx[i],vy[i]);
        let hue = (paletteHue + spd*30) % 360;
        if (CFG.flowColor){
          const v = flowVec(x[i], y[i], 1);
          const ang = Math.atan2(v[1], v[0]);
          const mag = Math.hypot(v[0], v[1]);
          const k = Math.max(0, Number(CFG.flowHueScale)||0) / 180; // 0..1
          if (String(CFG.flowColorMode||'angle') === 'strength'){
            hue = (hue + Math.min(360, mag*360) * k) % 360;
          } else {
            hue = (hue + (ang/Math.PI)*180 * k) % 360;
          }
        }
        const mode = (CFG.shape||'trail').toLowerCase();
        switch (mode){
          case 'triangle': {
            const ang = Math.atan2(vy[i], vx[i]);
            const size = (3 + Math.min(8, spd*1.8)) * sz[i];
            const x1=x[i]+Math.cos(ang)*size, y1=y[i]+Math.sin(ang)*size;
            const x2=x[i]+Math.cos(ang+2.5)*size*0.7, y2=y[i]+Math.sin(ang+2.5)*size*0.7;
            const x3=x[i]+Math.cos(ang-2.5)*size*0.7, y3=y[i]+Math.sin(ang-2.5)*size*0.7;
            ctx.fillStyle = `hsl(${hue} 80% 60% / 0.9)`;
            ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.lineTo(x3,y3); ctx.closePath(); ctx.fill();
            break;
          }
          case 'dot': {
            const r = (1 + Math.min(3, spd*0.6)) * sz[i];
            ctx.fillStyle = `hsl(${hue} 80% 60%)`;
            ctx.beginPath(); ctx.arc(x[i], y[i], r, 0, Math.PI*2); ctx.fill();
            break;
          }
          case 'ring': {
            const r = (2 + Math.min(6, spd*1.2)) * sz[i];
            ctx.strokeStyle = `hsl(${hue} 80% 70% / 0.9)`;
            const lw = Math.max(0.6, Math.min(3, r*0.18));
            const prev = ctx.lineWidth; ctx.lineWidth = lw;
            ctx.beginPath(); ctx.arc(x[i], y[i], r, 0, Math.PI*2); ctx.stroke();
            ctx.lineWidth = prev;
            break;
          }
          case 'comet': {
            ctx.strokeStyle = `hsl(${hue} 80% 60%)`;
            ctx.beginPath();
            const len = 3.5 * sz[i];
            ctx.moveTo(x[i], y[i]);
            ctx.lineTo(x[i]-vx[i]*len, y[i]-vy[i]*len);
            ctx.stroke();
            break;
          }
          default: {
            ctx.strokeStyle = `hsl(${hue} 80% 60%)`;
            ctx.beginPath();
            const len = 2 * sz[i];
            ctx.moveTo(x[i], y[i]);
            ctx.lineTo(x[i]-vx[i]*len, y[i]-vy[i]*len);
            ctx.stroke();
          }
        }
      }
      // Age shockwaves
      for (let s=shocks.length-1; s>=0; s--) { shocks[s].t += dt; if (shocks[s].t > 2.5) shocks.splice(s,1); }
      requestAnimationFrame(render);
    }

    // URL overrides for config (parity with Python script)
    (function urlOverride(){
      const intKeys = ['count','vision','sep','qtCap','bgHueShift1','bgHueShift2','bgHueShift3','flowOctaves'];
      const numKeys = ['maxSpeed','minSpeed','maxForce','alignW','cohesionW','separationW','trailAlpha','lineWidth','glowBase','glowMax','glowScale','cometSize','flowAmp','flowScale','flowSpeed','flowVizStep','flowAmpVar','flowAniso','flowHueScale'];
      const boolKeys = ['wrap','bgGradient','qt','flow','flowViz','showHud','showHeader','showSubheader','flowColor'];
      const strKeys = ['shape','blend','spawn','flowMode','flowColorMode'];
      for (const k of intKeys) { const v = params.get(k); if (v!=null && v!=='') CFG[k] = Math.max(-99999, Math.min(99999, parseInt(v))); }
      for (const k of numKeys) { const v = params.get(k); if (v!=null && v!=='') CFG[k] = Number(v); }
      for (const k of boolKeys) { const v = params.get(k); if (v!=null && v!=='') CFG[k] = (String(v).toLowerCase()==='true' || String(v)==='1'); }
      for (const k of strKeys) { const v = params.get(k); if (v!=null && v!=='') CFG[k] = v; }
      const cms = params.get('clickModes'); if (cms) CFG.clickModes = cms.split(',');
    })();

    function updateUrlFromCfg(extra={}){
      const url = new URL(location.href);
      url.searchParams.set('hue', String(BASE_HUE));
      url.searchParams.set('header', HEADER);
      if (SUBHEADER !== undefined && SUBHEADER !== null) url.searchParams.set('subheader', SUBHEADER);
      const keys = [
        'count','vision','sep','maxSpeed','minSpeed','maxForce','alignW','cohesionW','separationW','trailAlpha','lineWidth','wrap',
        'bgGradient','bgHueShift1','bgHueShift2','bgHueShift3',
        'qt','qtCap',
        'flow','flowAmp','flowScale','flowSpeed','flowViz','flowVizStep','flowAmpVar','flowAniso','flowOctaves','flowMode','flowColor','flowHueScale','flowColorMode',
        'shape','blend','spawn','showHud','showHeader','showSubheader'
      ];
      for (const k of keys) { if (CFG[k] !== undefined) url.searchParams.set(k, String(CFG[k])); }
      for (const [k,v] of Object.entries(extra)) url.searchParams.set(k, v);
      history.replaceState(null,'',url.toString());
    }

    // Initialize labels and sync URL
    (function initLabels(){
      titleEl.textContent = HEADER;
      subtitleEl.textContent = SUBHEADER || '';
      updateUrlFromCfg();
      // Accent color matches hue
      document.documentElement.style.setProperty('--accent', `hsl(${BASE_HUE} 80% 60%)`);
      buildConfigUI();
      const cfgEl = document.getElementById('config');
      document.getElementById('cfgBtn').onclick = ()=>{ cfgEl.classList.contains('open') ? closeConfig(cfgEl) : openConfig(cfgEl); };
      document.getElementById('cfgClose').onclick = ()=>{ closeConfig(cfgEl); };
      const helpEl = document.getElementById('help');
      document.getElementById('helpBtn').onclick = ()=>{ helpEl.classList.contains('open') ? closeConfig(helpEl) : openConfig(helpEl); };
      document.getElementById('helpClose').onclick = ()=>{ closeConfig(helpEl); };
    })();

    requestAnimationFrame(render);
    setInterval(step, 16);

    // Config UI builder (sliders + toggles bound to CFG)
    function buildConfigUI(){
      const root = document.getElementById('configBody');
      root.innerHTML = '';

      const addRange = (label, key, min, max, step, isInt=false)=>{
        const row = document.createElement('div'); row.className='rangeRow';
        const wrap = document.createElement('div'); wrap.className='row';
        const l = document.createElement('label'); l.textContent = label;
        const val = document.createElement('span'); val.className='val'; val.style.minWidth='56px'; val.style.textAlign='right';
        const input = document.createElement('input'); input.type='range'; input.min=min; input.max=max; input.step=step;
        const get = ()=> CFG[key];
        const set = (v)=>{ CFG[key] = isInt ? Math.round(v) : Number(v); };
        input.value = String(get()); val.textContent = String(get());
        input.addEventListener('input', ()=>{ set(input.value); val.textContent = String(get()); updateUrlFromCfg(); });
        wrap.appendChild(l); wrap.appendChild(val);
        row.appendChild(wrap); row.appendChild(input); root.appendChild(row);
      };

      const addCheck = (label, key)=>{
        const row = document.createElement('div'); row.className='row';
        const l = document.createElement('label'); l.textContent = label;
        const input = document.createElement('input'); input.type='checkbox'; input.checked = !!CFG[key];
        input.addEventListener('change', ()=>{ CFG[key] = !!input.checked; updateUrlFromCfg(); });
        row.appendChild(l); row.appendChild(input); root.appendChild(row);
      };

      addRange('Count', 'count', 50, 1000, 1, true);
      addRange('Vision', 'vision', 20, 220, 1);
      addRange('Separation dist', 'sep', 4, 80, 1);
      addRange('Max speed', 'maxSpeed', 0.2, 6, 0.1);
      addRange('Min speed', 'minSpeed', 0.0, 3, 0.1);
      addRange('Max force', 'maxForce', 0.01, 0.5, 0.01);
      addRange('Align weight', 'alignW', 0, 3, 0.05);
      addRange('Cohesion weight', 'cohesionW', 0, 3, 0.05);
      addRange('Separation weight', 'separationW', 0, 3, 0.05);
      addRange('Line width', 'lineWidth', 0.2, 6, 0.1);
      addRange('Trail alpha', 'trailAlpha', 0.0, 0.5, 0.01);
      addCheck('Wrap', 'wrap');
      addCheck('Show header', 'showHeader');
      addCheck('Show subheader', 'showSubheader');
      addCheck('Background gradient', 'bgGradient');
      addRange('BG hue shift 1', 'bgHueShift1', 0, 360, 1, true);
      addRange('BG hue shift 2', 'bgHueShift2', 0, 360, 1, true);
      addRange('BG hue shift 3', 'bgHueShift3', 0, 360, 1, true);
      addCheck('Quadtree (viz)', 'qt');
      addRange('Quadtree cap', 'qtCap', 4, 64, 1, true);
      addCheck('Flow field', 'flow');
      addCheck('Flow viz (overlay)', 'flowViz');
      addRange('Flow amplitude', 'flowAmp', 0, 2, 0.05);
      addRange('Flow scale', 'flowScale', 0.0005, 0.02, 0.0005);
      addRange('Flow speed', 'flowSpeed', 0, 3, 0.05);
      addRange('Flow grid size', 'flowVizStep', 12, 200, 4, true);
      addRange('Flow amp variation', 'flowAmpVar', 0, 1, 0.05);
      addRange('Flow anisotropy (Y)', 'flowAniso', -0.9, 3, 0.1);
      const addSelect = (label, key, options)=>{
        const row = document.createElement('div'); row.className='row';
        const l = document.createElement('label'); l.textContent = label;
        const sel = document.createElement('select');
        for (const opt of options){ const o=document.createElement('option'); o.value=opt; o.textContent=opt; sel.appendChild(o); }
        sel.value = String(CFG[key]||options[0]);
        sel.addEventListener('change', ()=>{ CFG[key]=sel.value; updateUrlFromCfg(); });
        row.appendChild(l); row.appendChild(sel); root.appendChild(row);
      };
      addSelect('Flow mode', 'flowMode', ['angle','curl','turbulence']);
      addRange('Flow octaves', 'flowOctaves', 1, 6, 1, true);
      addCheck('Flow color', 'flowColor');
      addRange('Flow hue influence', 'flowHueScale', 0, 180, 5);

      addSelect('Blend', 'blend', ['lighter','plus-lighter','screen','source-over']);
      addSelect('Shape', 'shape', ['trail','triangle','dot','comet','ring']);
      addSelect('Spawn', 'spawn', ['random','ring','center','edge','grid']);
    }

    function openConfig(el){
      if (!el) return; el.hidden = false; requestAnimationFrame(()=> el.classList.add('open'));
    }
    function closeConfig(el){
      if (!el) return; el.classList.remove('open');
      el.addEventListener('transitionend', function handler(){ el.removeEventListener('transitionend', handler); el.hidden = true; }, { once:true });
    }

    // Simple quadtree implementation for neighbor queries and visualization
    const indices = Array.from({length:N}, (_,i)=>i);
    let qtree=null;
    function QTNode(x,y,w,h,depth){ this.x=x; this.y=y; this.w=w; this.h=h; this.d=depth; this.p=[]; this.c=null; }
    function subdiv(n){
      const hw=n.w/2, hh=n.h/2;
      n.c=[ new QTNode(n.x, n.y, hw, hh, n.d+1), new QTNode(n.x+hw, n.y, hw, hh, n.d+1), new QTNode(n.x, n.y+hh, hw, hh, n.d+1), new QTNode(n.x+hw, n.y+hh, hw, hh, n.d+1) ];
      for (const idx of n.p){ insert(n, idx); }
      n.p.length=0;
    }
    function insert(n, i){
      if (n.c){ return insert(n.c[childIndex(n, x[i], y[i])], i); }
      n.p.push(i);
      if (n.p.length > CFG.qtCap && n.w>32 && n.h>32 && n.d<12){ subdiv(n); }
      return true;
    }
    function childIndex(n, px, py){ const right = px >= n.x + n.w/2; const bottom = py >= n.y + n.h/2; return (bottom?2:0) + (right?1:0); }
    function buildQT(){
      qtree = new QTNode(0,0,innerWidth,innerHeight,0);
      for (let i=0;i<N;i++){ insert(qtree, i); }
      return qtree;
    }
    function drawQT(){ if (!qtree) return; ctx.save(); ctx.strokeStyle='#1f2937'; drawNode(qtree); ctx.restore(); }
    function drawNode(n){ if (!n) return; ctx.strokeRect(n.x, n.y, n.w, n.h); if (n.c){ for (const c of n.c) drawNode(c); } }
    function queryNeighbors(root, px, py, rad, selfIdx){ if (!root) return indices; const out=[]; queryNode(root, px, py, rad, out); return out; }
    function queryNode(n, px, py, r, out){ if (!n || !intersects(n, px, py, r)) return; if (n.c){ for (const c of n.c) queryNode(c, px, py, r, out); } else { for (const i of n.p) out.push(i); } }
    function intersects(n, px, py, r){ const nx=Math.max(n.x, Math.min(px, n.x+n.w)); const ny=Math.max(n.y, Math.min(py, n.y+n.h)); const dx=px-nx, dy=py-ny; return dx*dx+dy*dy <= r*r; }

    // Flow field visualization overlay
    function drawFlowViz(){
      const s = Math.max(8, (CFG.flowVizStep|0) || 56);
      ctx.save();
      ctx.lineWidth = 1;
      for (let yy=0; yy<=innerHeight; yy+=s){
        for (let xx=0; xx<=innerWidth; xx+=s){
          const v = flowVec(xx, yy, 1);
          const l = Math.hypot(v[0], v[1]) || 1;
          const dx = v[0]/l, dy = v[1]/l;
          const L = Math.max(6, s*0.35);
          const x1 = xx - dx*L*0.5, y1 = yy - dy*L*0.5;
          const x2 = xx + dx*L*0.5, y2 = yy + dy*L*0.5;
          const ang = Math.atan2(dy, dx);
          const hue = (BASE_HUE + (ang/Math.PI)*90 + 360) % 360;
          ctx.strokeStyle = `hsl(${hue} 70% 65% / 0.6)`;
          ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
          // arrow head
          const ah = Math.max(4, L*0.18);
          const a1 = ang + 2.6, a2 = ang - 2.6;
          ctx.beginPath();
          ctx.moveTo(x2,y2);
          ctx.lineTo(x2 + Math.cos(a1)*ah*0.6, y2 + Math.sin(a1)*ah*0.6);
          ctx.moveTo(x2,y2);
          ctx.lineTo(x2 + Math.cos(a2)*ah*0.6, y2 + Math.sin(a2)*ah*0.6);
          ctx.stroke();
        }
      }
      ctx.restore();
    }

    // Simple 2D noise-based flow
    let noiseSeed = (DEFAULT_HUE * 1664525 + 1013904223) >>> 0;
    function fract(x){ return x - Math.floor(x); }
    function _rand(ix, iy){ const k = ((ix|0) * 374761393 + (iy|0) * 668265263 + noiseSeed) >>> 0; return fract(Math.sin(k) * 43758.5453); }
    function noise2(x, y){ const xi = Math.floor(x), yi = Math.floor(y); const xf = x - xi, yf = y - yi; const u = xf*xf*(3-2*xf), v = yf*yf*(3-2*yf); const v00 = _rand(xi, yi), v10 = _rand(xi+1, yi), v01 = _rand(xi, yi+1), v11 = _rand(xi+1, yi+1); const x1 = v00*(1-u) + v10*u, x2 = v01*(1-u) + v11*u; return x1*(1-v) + x2*v; }
    function perlinVec(x, y, scale, amp){ const n = noise2(x*scale, y*scale); const a = n * Math.PI*2; return [Math.cos(a)*amp, Math.sin(a)*amp]; }
    // Advanced flow vector with modes and non-uniform variation
    function flowVec(x, y, ampMul){
      const s = Math.max(1e-6, Number(CFG.flowScale)||0.001);
      const sy = s * (1 + Number(CFG.flowAniso||0));
      const mode = String(CFG.flowMode||'angle').toLowerCase();
      let vx=0, vy=0;
      if (mode === 'curl'){
        const nx = (x+flowT*60)*s, ny=(y-flowT*60)*sy;
        const e = 1.2; // step in noise space
        const dny = noise2(nx, ny+e) - noise2(nx, ny-e);
        const dnx = noise2(nx+e, ny) - noise2(nx-e, ny);
        vx = dny; vy = -dnx; // perpendicular of gradient
        const l = Math.hypot(vx,vy)||1; vx/=l; vy/=l;
      } else if (mode === 'turbulence'){
        let nx = (x+flowT*60)*s, ny=(y-flowT*60)*sy;
        let amp=1, freq=1, sx=0, syy=0; const oct=Math.max(1,Math.min(6,(CFG.flowOctaves|0)||3));
        for(let o=0;o<oct;o++){
          const n = noise2(nx*freq, ny*freq); const a = n*Math.PI*2; sx += Math.cos(a)*amp; syy += Math.sin(a)*amp; amp*=0.5; freq*=2;
        }
        const l = Math.hypot(sx,syy)||1; vx=sx/l; vy=syy/l;
      } else {
        const n = noise2((x+flowT*60)*s, (y-flowT*60)*sy); const a = n*Math.PI*2; vx=Math.cos(a); vy=Math.sin(a);
      }
      // amplitude modulation
      let amp = Number(CFG.flowAmp||0) * (ampMul||1);
      const varAmt = Number(CFG.flowAmpVar||0);
      if (varAmt>0){
        const nv = noise2((x+123.4+flowT*30)*(s*1.2), (y-99.7-flowT*30)*(sy*1.2));
        amp *= (1 + (nv*2-1)*varAmt);
      }
      return [vx*amp, vy*amp];
    }

    </script>
  </body>
</html>

<!-- Helper to inject quoted strings without adding a full template engine in JS -->
<script>
// Poor-man’s inlining of quoted string (we replace {{jsonq "..."}} at build time via Go’s simple placeholder replacement above).
</script>
